#lang racket

(define (k-smallest-pairs nums1 nums2 k)
  (define (heap? x) (and (vector? x) (= (vector-length x) 3)))
  (define (heap-ref i) (vector-ref i 0))
  (define (heap-left i) (+ i 1))
  (define (heap-right i) (+ i 2))
  (define (heap-parent i) (quotient (- i 1) 2))
  (define (heap-swap a b)
    (let ((t (vector-ref a 0)))
      (vector-set! a 0 (vector-ref b 0))
      (vector-set! b 0 t)
      (vector-set! a 1 (vector-ref b 1))
      (vector-set! b 1 t)
      (vector-set! a 2 (vector-ref b 2))
      (vector-set! b 2 t)))
  (define (heapify-up h i)
    (when (> i 0)
      (let ((p (heap-parent i)))
        (when (> (heap-ref h) (heap-ref h p))
          (heap-swap h h p)
          (heapify-up h p)))))
  (define (heapify-down h i)
    (let ((l (heap-left i))
          (r (heap-right i))
          (smallest i))
      (when (and (< l (vector-length h)) (> (heap-ref h) (heap-ref h l)))
        (set! smallest l))
      (when (and (< r (vector-length h)) (> (heap-ref h) (heap-ref h r)))
        (set! smallest r))
      (when (not (= i smallest))
        (heap-swap h h smallest)
        (heapify-down h smallest))))
  (define (heap-insert h val i j)
    (vector-set! h (vector-length h) val)
    (vector-set! h (+ (vector-length h) 1) i)
    (vector-set! h (+ (vector-length h) 2) j)
    (heapify-up h (- (vector-length h) 1)))
  (define (heap-extract-min h)
    (let ((min (vector-ref h 0))
          (i (vector-ref h 1))
          (j (vector-ref h 2)))
      (vector-set! h 0 (vector-ref h (- (vector-length h) 1)))
      (vector-set! h 1 (vector-ref h (+ (- (vector-length h) 1) 1)))
      (vector-set! h 2 (vector-ref h (+ (- (vector-length h) 1) 2)))
      (vector-shrink! h 3)
      (heapify-down h 0)
      (list min i j)))
  (define (heap-empty? h) (= (vector-length h) 0))
  (define (heap-size h) (quotient (- (vector-length h) 1) 3))
  (define (heap-peek h) (list (heap-ref h) (vector-ref h 1) (vector-ref h 2)))
  (define (heap-init h)
    (for ([i (in-range (min (length nums1) k))])
      (heap-insert h (+ (list-ref nums1 i) (list-ref nums2 0)) i 0)))
  (define result '())
  (define h (make-vector 0))
  (heap-init h)
  (let loop ()
    (when (and (not (heap-empty? h)) (< (length result) k))
      (let* ((val (heap-extract-min h))
             (sum (car val))
             (i (cadr val))
             (j (caddr val)))
        (set! result (append result (list (list (list-ref nums1 i) (list-ref nums2 j)))))
        (when (< (+ j 1) (length nums2))
          (heap-insert h (+ (list-ref nums1 i) (list-ref nums2 (+ j 1))) i (+ j 1))))
      (loop)))
  result)