(define/contract (min-jumps arr)
  (-> (listof exact-integer?) exact-integer?)
  (let ([n (length arr)])
    (if (= n 1) 0
        (let ([visited (make-hash)]
              [queue (cons 0 '())]
              [steps 0])
          (hash-set! visited 0 #t)
          (let loop ()
            (when (not (null? queue))
              (let ([size (length queue)])
                (for ([i (in-range size)])
                  (let ([current (car queue)])
                    (set! queue (cdr queue))
                    (when (= current (sub1 n)) (return steps))
                    (for-each (lambda (next)
                                (when (and (< next n) (not (hash-has-key? visited next)))
                                  (hash-set! visited next #t)
                                  (set! queue (append queue (list next)))))
                              (list (+ current 1) (- current 1) (+ current (* 2 (abs (list-ref arr current))))))
                    (when (and (< current (sub1 n)) (not (hash-has-key? visited (+ current 1))))
                      (hash-set! visited (+ current 1) #t)
                      (set! queue (append queue (list (+ current 1)))))
                    (when (and (> current 0) (not (hash-has-key? visited (- current 1))))
                      (hash-set! visited (- current 1) #t)
                      (set! queue (append queue (list (- current 1)))))
                    (when (and (< current (sub1 n)) (not (hash-has-key? visited (+ current (* 2 (abs (list-ref arr current)))))))
                      (hash-set! visited (+ current (* 2 (abs (list-ref arr current)))) #t)
                      (set! queue (append queue (list (+ current (* 2 (abs (list-ref arr current))))))))))
                (set! steps (+ steps 1))
                (loop)))
          steps))))