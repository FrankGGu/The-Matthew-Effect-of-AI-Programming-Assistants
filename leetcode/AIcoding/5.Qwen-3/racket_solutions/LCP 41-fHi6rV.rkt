(define (solution board, n)
  (define (flip x y)
    (define (check dx dy)
      (let loop ((x (+ x dx)) (y (+ y dy)) (count 0))
        (cond ((or (< x 0) (>= x n) (< y 0) (>= y n)) #f)
              ((equal? (list-ref board x) (list-ref (list-ref board x) y)) #t)
              ((equal? (list-ref (list-ref board x) y) "B") (loop (+ x dx) (+ y dy) (+ count 1)))
              (else #f))))
    (let loop ((dx '(-1 0 1)) (dy '(-1 0 1)))
      (when (and (not (equal? (list-ref (list-ref board x) y) "B")) (not (equal? (list-ref (list-ref board x) y) "W")))
        (for-each (lambda (dxdy)
                    (let ((dx (car dxdy)) (dy (cadr dxdy)))
                      (when (and (not (= dx 0)) (not (= dy 0)) (check dx dy))
                        (let loop ((x (+ x dx)) (y (+ y dy)))
                          (when (and (>= x 0) (< x n) (>= y 0) (< y n) (equal? (list-ref (list-ref board x) y) "B"))
                            (set! board (set-list-ref board x (set-list-ref (list-ref board x) y "W")))
                            (loop (+ x dx) (+ y dy)))))))
                '(( -1 -1 ) ( -1 0 ) ( -1 1 ) ( 0 -1 ) ( 0 1 ) ( 1 -1 ) ( 1 0 ) ( 1 1 )))))
    (void))
  (for-each (lambda (i)
              (for-each (lambda (j)
                          (when (and (= (list-ref (list-ref board i) j) "W") (not (equal? (list-ref (list-ref board i) j) "B")))
                            (flip i j)))
                        (range n)))
            (range n))
  (apply + (map (lambda (row) (count (lambda (cell) (equal? cell "W")) row)) board)))