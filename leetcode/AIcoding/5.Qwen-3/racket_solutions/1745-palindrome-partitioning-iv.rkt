#lang racket

(define (is-palindrome s l r)
  (let loop ([l l] [r r])
    (if (>= l r) #t
        (if (= (string-ref s l) (string-ref s r))
            (loop (+ l 1) (- r 1))
            #f))))

(define (check-partition s)
  (define n (string-length s))
  (define dp (make-vector n #f))
  (vector-set! dp 0 #t)
  (for ([i (in-range 1 n)])
    (when (is-palindrome s 0 i)
      (vector-set! dp i #t))
    (for ([j (in-range 0 i)])
      (when (and (vector-ref dp j) (is-palindrome s (+ j 1) i))
        (vector-set! dp i #t)
        (break))))
  (vector-ref dp (- n 1)))

(define (partition s)
  (define n (string-length s))
  (define res '())
  (define (backtrack start path)
    (when (= start n)
      (set! res (cons (reverse path) res))
      (return))
    (for ([i (in-range start n)])
      (when (is-palindrome s start i)
        (backtrack (+ i 1) (cons (substring s start (+ i 1)) path)))))
  (backtrack 0 '())
  res)

(define (count-palindromic-substrings s)
  (define n (string-length s))
  (define dp (make-vector n #f))
  (for ([i (in-range n)])
    (vector-set! dp i #t)
    (for ([j (in-range 0 i)])
      (when (and (is-palindrome s j i) (vector-ref dp j))
        (vector-set! dp i #t)
        (break))))
  (vector-ref dp (- n 1)))

(define (palindrome-partitioning-iv s)
  (define n (string-length s))
  (define dp (make-vector n #f))
  (vector-set! dp 0 #t)
  (for ([i (in-range 1 n)])
    (for ([j (in-range 0 i)])
      (when (and (vector-ref dp j) (is-palindrome s (+ j 1) i))
        (vector-set! dp i #t)
        (break)))
    (when (is-palindrome s 0 i)
      (vector-set! dp i #t)))
  (vector-ref dp (- n 1)))