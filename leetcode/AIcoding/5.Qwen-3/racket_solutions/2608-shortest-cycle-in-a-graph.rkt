#lang racket

(define (shortest-cycle n edges)
  (define graph (make-hash))
  (for ([u (in-range n)])
    (hash-set! graph u '()))
  (for ([edge (in-list edges)])
    (define u (car edge))
    (define v (cadr edge))
    (hash-set! graph u (cons v (hash-ref graph u)))
    (hash-set! graph v (cons u (hash-ref graph v))))

  (define visited (make-vector n #f))
  (define result +inf.0)

  (define (bfs start)
    (define dist (make-vector n -1))
    (define q (queue))
    (queue-add! q start)
    (vector-set! dist start 0)
    (let loop ()
      (when (not (queue-empty? q))
        (define u (queue-remove! q))
        (for ([v (hash-ref graph u)])
          (when (= (vector-ref dist v) -1)
            (vector-set! dist v (+ (vector-ref dist u) 1))
            (queue-add! q v)
            (when (and (not (equal? u v)) (equal? (vector-ref dist v) 1))
              (set! result (min result (vector-ref dist v)))))))
        (loop)))
    (void))

  (for ([i (in-range n)])
    (when (not (vector-ref visited i))
      (bfs i)
      (for ([j (in-range n)])
        (vector-set! visited j #f))))

  (if (exact-positive-integer? result) result -1))