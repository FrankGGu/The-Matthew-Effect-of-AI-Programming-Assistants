#lang racket

(define (count-smaller-numbers-after-self nums)
  (define (merge-sort arr start end)
    (if (> start end)
        '()
        (let ((mid (quotient (+ start end) 2)))
          (let ((left (merge-sort arr start mid)))
                (right (merge-sort arr (+ mid 1) end)))
            (let ((result '()))
              (let loop ((i 0) (j 0) (left left) (right right) (count 0))
                (cond ((and (null? left) (null? right)) (append (reverse result) (list count)))
                      ((null? left) (set! result (append result (list (car right))))
                       (loop i (+ j 1) left (cdr right) count))
                      ((null? right) (set! result (append result (list (car left))))
                       (loop (+ i 1) j (cdr left) right count))
                      ((< (car left) (car right))
                       (set! result (append result (list (car left))))
                       (loop (+ i 1) j (cdr left) right count))
                      (else
                       (set! count (+ count (- (length left) i)))
                       (set! result (append result (list (car right))))
                       (loop i (+ j 1) left (cdr right) count)))))))))

  (define (get-indexes arr)
    (define (helper arr index)
      (if (null? arr)
          '()
          (cons (cons (car arr) index)
                (helper (cdr arr) (+ index 1)))))
    (helper arr 0))

  (define indexed-nums (get-indexes nums))
  (define sorted (merge-sort indexed-nums 0 (- (length nums) 1)))
  (define result (make-vector (length nums) 0))
  (for-each (lambda (x)
              (vector-set! result (cdr x) (car x)))
            sorted)
  (vector->list result))

(count-smaller-numbers-after-self '(5 2 6 1))