(define (minimum-sum nums k)
  (define (heap? i) (< i (vector-length heap)))
  (define (swap i j)
    (let ((t (vector-ref heap i)))
      (vector-set! heap i (vector-ref heap j))
      (vector-set! heap j t)))
  (define (sift-down i)
    (let loop ((i i))
      (let* ((l (+ i 1))
             (r (+ l 1))
             (min-i i))
        (when (heap? l) (when (< (vector-ref heap l) (vector-ref heap min-i)) (set! min-i l)))
        (when (heap? r) (when (< (vector-ref heap r) (vector-ref heap min-i)) (set! min-i r)))
        (when (not (= i min-i))
          (swap i min-i)
          (loop min-i)))))
  (define (extract-min)
    (let ((min (vector-ref heap 0)))
      (vector-set! heap 0 (vector-ref heap (- (vector-length heap) 1)))
      (vector-set! heap (sub1 (vector-length heap)) #f)
      (sift-down 0)
      min))
  (define (insert x)
    (vector-set! heap (sub1 (vector-length heap)) x)
    (let loop ((i (sub1 (vector-length heap))))
      (let ((p (quotient (- i 1) 2)))
        (when (and (> i 0) (< (vector-ref heap i) (vector-ref heap p)))
          (swap i p)
          (loop p)))))
  (define heap (make-vector (length nums)))
  (for-each (lambda (x) (insert x)) nums)
  (let loop ((k k))
    (if (= k 0)
        (apply + (vector->list heap))
        (let ((min (extract-min)))
          (insert (add1 min))
          (loop (sub1 k)))))
  (apply + (vector->list heap)))