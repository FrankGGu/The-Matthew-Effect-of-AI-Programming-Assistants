#lang racket

(define (min-operations s)
  (define MOD 1000000007)
  (define len (string-length s))
  (define fact (make-vector (+ len 1) 1))
  (for ([i (in-range 1 (add1 len))])
    (vector-set! fact i (* (vector-ref fact (sub1 i)) i)))
  (define inv-fact (make-vector (+ len 1) 1))
  (define (mod-exp a b)
    (cond [(= b 0) 1]
          [(even? b) (let ([x (mod-exp a (quotient b 2))]) (modulo (* x x) MOD))]
          [else (modulo (* a (mod-exp a (sub1 b))) MOD)]))
  (define (mod-inv x)
    (mod-exp x (- MOD 2)))
  (for ([i (in-range 1 (add1 len))])
    (vector-set! inv-fact i (mod-inv (vector-ref fact i))))
  (define count (make-hash))
  (for ([c (in-string s)])
    (hash-set! count c (+ (hash-ref count c 0) 1)))
  (define (get-lex-order c)
    (for/sum ([i (in-range (char->integer #\a) (char->integer c))])
      (if (hash-has-key? count (integer->char i))
          (vector-ref fact (hash-count count))
          0)))
  (define res 0)
  (for ([i (in-range len)])
    (define c (string-ref s i))
    (define total (vector-ref fact (sub1 (- len i))))
    (define current-count (hash-ref count c))
    (define less (get-lex-order c))
    (set! res (modulo (+ res (* less (vector-ref inv-fact (sub1 (- len i)))) ) MOD))
    (hash-set! count c (sub1 current-count))
    (when (= (hash-ref count c) 0)
      (hash-remove! count c)))
  res)