#lang racket

(define (max-product-subsequence k nums)
  (define n (length nums))
  (define dp (make-vector (+ n 1) (make-vector (+ k 1) 0)))
  (define (update i j val)
    (when (<= j k)
      (vector-set! (vector-ref dp i) j val)))
  (for ([i (in-range 1 n)])
    (for ([j (in-range 0 (+ k 1))])
      (let ([prev (vector-ref (vector-ref dp (- i 1)) j)])
        (if (= j 0)
            (update i j (max prev 1))
            (update i j prev))))
    (for ([j (in-range 0 (+ k 1))])
      (when (>= j (abs (list-ref nums (- i 1))))
        (let ([val (* (vector-ref (vector-ref dp (- i 1)) (- j (abs (list-ref nums (- i 1))))) (list-ref nums (- i 1)))])
          (update i j (max (vector-ref (vector-ref dp i) j) val))))))
  (vector-ref (vector-ref dp n) k))