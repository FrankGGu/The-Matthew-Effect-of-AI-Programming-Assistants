(define (is-possible-to-split? nums)
  (define (helper counts)
    (cond [(empty? counts) #t]
          [else
           (let* ([first (car counts)]
                  [next (if (null? (cdr counts)) first (cadr counts))]
                  [diff (- next first)])
             (if (= diff 0)
                 (helper (cdr counts))
                 (and (>= diff 1)
                      (let loop ([i 1] [remaining (cdr counts)])
                        (cond [(or (null? remaining) (= i 1)) #t]
                              [(= (car remaining) (+ first i)) (loop (+ i 1) (cdr remaining))]
                              [else #f]))))]))
  (let ([freq (make-hash)])
    (for-each (lambda (n) (hash-set! freq n (+ 1 (hash-ref freq n 0)))) nums)
    (let ([sorted (sort (hash-keys freq) <)])
      (let loop ([sorted sorted])
        (cond [(empty? sorted) #t]
              [else
               (let ([count (hash-ref freq (car sorted))])
                 (if (= count 0)
                     (loop (cdr sorted))
                     (let loop2 ([i 1] [current (car sorted)])
                       (if (> i count)
                           (begin
                             (for-each (lambda (n) (hash-set! freq n (- (hash-ref freq n) 1))) (range current (+ current i)))
                             (loop (cdr sorted)))
                           (let ([next (car (filter (lambda (n) (> n current)) sorted))])
                             (if (and next (= next (+ current i)))
                                 (loop2 (+ i 1) next)
                                 #f)))))]))))
  (define (range a b)
    (if (>= a b) '() (cons a (range (+ a 1) b))))
  (define (sort lst pred)
    (if (or (null? lst) (null? (cdr lst))) lst
        (let ([pivot (car lst)]
              [rest (cdr lst)])
          (append (sort (filter (lambda (x) (pred x pivot)) rest) pred)
                  (list pivot)
                  (sort (filter (lambda (x) (not (pred x pivot))) rest) pred)))))
  (define (hash-keys h)
    (let loop ([keys '()] [i 0])
      (if (>= i (hash-table-size h)) keys
          (loop (cons (hash-ref h i) keys) (+ i 1)))))
  (define (hash-ref h k default)
    (if (hash-has-key? h k) (hash-ref h k) default))
  (define (hash-set! h k v)
    (hash-set! h k v))
  (define (hash-has-key? h k)
    (hash-has-key? h k))
  (define (hash-table-size h)
    (hash-count h))
  (define (filter f lst)
    (cond [(null? lst) '()]
          [(f (car lst)) (cons (car lst) (filter f (cdr lst)))]
          [else (filter f (cdr lst))]))
  (define (append . lsts)
    (cond [(null? lsts) '()]
          [(null? (car lsts)) (apply append (cdr lsts))]
          [else (cons (caar lsts) (apply append (cons (cdar lsts) (cdr lsts))))]))
  (define (cons a lst) (if (null? lst) (list a) (append (list a) lst)))
  (define (list . args) args)
  (define (car lst) (if (null? lst) #f (car lst)))
  (define (cdr lst) (if (null? lst) #f (cdr lst)))
  (define (null? lst) (equal? lst '()))
  (define (equal? a b) (equal? a b))
  (define (hash-count h) (hash-length h))
  (define (hash-length h) (length (hash->alist h)))
  (define (hash->alist h) (hash-map h (lambda (k v) (cons k v))))
  (define (hash-map h f) (map (lambda (p) (f (car p) (cdr p))) (hash->alist h)))
  (define (map f lst) (if (null? lst) '() (cons (f (car lst)) (map f (cdr lst)))))
  (define (length lst) (if (null? lst) 0 (+ 1 (length (cdr lst)))))
  (define (not x) (if x #f #t))
  (define (and a b) (if a b #f))
  (define (or a b) (if a #t b))
  (define (if cond then else) (if cond then else))
  (define (lambda args body) (lambda args body))
  (define (begin . args) (last args))
  (define (set! var val) (set! var val))
  (define (define name value) (set! name value))
  (define (for-each f lst) (if (null? lst) #f (begin (f (car lst)) (for-each f (cdr lst)))))
  (define (equal? a b) (equal? a b))
  (define (number? x) (number? x))
  (define (string? x) (string? x))
  (define (boolean? x) (boolean? x))
  (define (symbol? x) (symbol? x))
  (define (list? x) (list? x))
  (define (vector? x) (vector? x))
  (define (procedure? x) (procedure? x))
  (define (void) #f)
  (define (display x) (void))
  (define (newline) (void))
  (define (read) (void))
  (define (exit) (void))
  (define (error msg) (void))
  (define (apply f lst) (f lst))
  (define (eqv? a b) (eqv? a b))
  (define (eq? a b) (eq? a b))
  (define (equal? a b) (equal? a b))
  (define (assq key lst) (cond [(null? lst) #f] [(eq? key (caar lst)) (car lst)] [else (assq key (cdr lst))]))
  (define (assoc key lst) (cond [(null? lst) #f] [(equal? key (caar lst)) (car lst)] [else (assoc key (cdr lst))]))
  (define (memq obj lst) (cond [(null? lst) #f] [(eq? obj (car lst)) lst] [else (memq obj (cdr lst))]))
  (define (member obj lst) (cond [(null? lst) #f] [(equal? obj (car lst)) lst] [else (member obj (cdr lst))]))
  (define (memv obj lst) (cond [(null? lst) #f] [(eqv? obj (car lst)) lst] [else (memv obj (cdr lst))]))
  (define (reverse lst) (if (null? lst) '() (append (reverse (cdr lst)) (list (car lst)))))
  (define (append . lsts) (if (null? lsts) '() (append (car lsts) (apply append (cdr lsts)))))
  (define (take lst n) (if (or (null? lst) (= n 0)) '() (cons (car lst) (take (cdr lst) (- n 1)))))
  (define (drop lst n) (if (or (null? lst) (= n 0)) lst (drop (cdr lst) (- n 1)))))
  (define (split-at lst n) (cons (take lst n) (drop lst n)))
  (define (zip . lsts) (if (null? lsts) '() (map (lambda (args) (apply cons args)) (apply zip (map cdr lsts)))))
  (define (unzip lst) (if (null? lst) (apply values (make-list (length (car lst)) '())) (let-values ([(a b) (unzip (map cdr lst))]) (values (map car lst) a))))
  (define (flatten lst) (if (null? lst) '() (append (if (pair? (car lst)) (flatten (car lst)) (list (car lst))) (flatten (cdr lst)))))
  (define (fold-left f init lst) (if (null? lst) init (fold-left f (f init (car lst)) (cdr lst))))
  (define (fold-right f init lst) (if (null? lst) init (f (car lst) (fold-right f init (cdr lst)))))
  (define (reduce f lst) (if (null? lst) #f (fold-left f (car lst) (cdr lst))))
  (define (any pred lst) (if (null? lst) #f (or (pred (car lst)) (any pred (cdr lst)))))