#lang racket

(define-struct deque (front rear size) #:mutable)

(define (make-deque)
  (make-deque #f #f 0))

(define (is-empty dq)
  (not (deque-front dq)))

(define (get-size dq)
  (deque-size dq))

(define (add-first dq item)
  (when (is-empty dq)
    (set-deque-front! dq (cons item #f))
    (set-deque-rear! dq (deque-front dq))
    (set-deque-size! dq 1)
    (void))
  (let ((new-node (cons item (deque-front dq))))
    (set-deque-front! dq new-node)
    (set-deque-size! dq (+ (deque-size dq) 1))
    (void)))

(define (add-last dq item)
  (when (is-empty dq)
    (set-deque-front! dq (cons item #f))
    (set-deque-rear! dq (deque-front dq))
    (set-deque-size! dq 1)
    (void))
  (let ((new-node (cons item #f)))
    (set-cdr! (deque-rear dq) new-node)
    (set-deque-rear! dq new-node)
    (set-deque-size! dq (+ (deque-size dq) 1))
    (void)))

(define (remove-first dq)
  (when (is-empty dq)
    (error "Deque is empty"))
  (let ((item (car (deque-front dq))))
    (set-deque-front! dq (cdr (deque-front dq)))
    (set-deque-size! dq (- (deque-size dq) 1))
    (if (is-empty dq)
        (set-deque-rear! dq #f)
        (void))
    item))

(define (remove-last dq)
  (when (is-empty dq)
    (error "Deque is empty"))
  (let ((item (car (deque-rear dq))))
    (if (= (deque-size dq) 1)
        (begin
          (set-deque-front! dq #f)
          (set-deque-rear! dq #f))
        (let ((current (deque-front dq)))
          (while (not (equal? (cdr (cdr current)) (deque-rear dq)))
            (set! current (cdr current)))
          (set-cdr! current #f)
          (set-deque-rear! dq current)))
    (set-deque-size! dq (- (deque-size dq) 1))
    item))

(define (peek-first dq)
  (when (is-empty dq)
    (error "Deque is empty"))
  (car (deque-front dq)))

(define (peek-last dq)
  (when (is-empty dq)
    (error "Deque is empty"))
  (car (deque-rear dq)))