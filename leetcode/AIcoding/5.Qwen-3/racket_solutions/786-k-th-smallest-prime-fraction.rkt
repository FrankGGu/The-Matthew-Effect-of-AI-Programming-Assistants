(define (kth-smallest-prime-fraction fractions k)
  (define (compare a b)
    (let ((num1 (car a)) (den1 (cadr a))
          (num2 (car b)) (den2 (cadr b)))
      (< (* num1 den2) (* num2 den1))))

  (define (heapify arr i size)
    (let ((smallest i)
          (left (+ (* 2 i) 1))
          (right (+ (* 2 i) 2)))
      (when (< left size)
        (when (compare (list-ref arr left) (list-ref arr smallest))
          (set! smallest left)))
      (when (< right size)
        (when (compare (list-ref arr right) (list-ref arr smallest))
          (set! smallest right)))
      (when (not (= smallest i))
        (let ((temp (list-ref arr i)))
          (set! arr (append (take arr i) (list (list-ref arr smallest)) (drop arr (+ i 1))))
          (set! arr (append (take arr smallest) (list temp) (drop arr (+ smallest 1))))
          (heapify arr smallest size))))

  (define (build-heap arr)
    (let loop ((i (quotient (- (length arr) 1) 2)))
      (when (>= i 0)
        (heapify arr i (length arr))
        (loop (- i 1)))))

  (define (extract-min arr)
    (let ((min (list-ref arr 0)))
      (set! arr (append (take arr 1) (drop arr 2)))
      (heapify arr 0 (length arr))
      min))

  (define (heap-sort arr)
    (build-heap arr)
    (let loop ((result '()) (arr arr) (size (length arr)))
      (if (= size 0)
          result
          (let ((min (extract-min arr)))
            (loop (cons min result) arr (- size 1))))))

  (let ((sorted (heap-sort fractions)))
    (list-ref sorted (- k 1))))