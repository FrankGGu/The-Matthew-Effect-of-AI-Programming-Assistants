#lang racket

(define/contract (remove-stones-to-minimize-the-total piles k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)
  (define (heapq)
    (let ((heap (make-vector 0)))
      (define (push x)
        (vector-set! heap (vector-length heap) x)
        (let loop ((i (- (vector-length heap) 1)))
          (when (> i 0)
            (let ((p (quotient i 2)))
              (when (> (vector-ref heap p) (vector-ref heap i))
                (let ((t (vector-ref heap p)))
                  (vector-set! heap p (vector-ref heap i))
                  (vector-set! heap i t)
                  (loop p)))))))
      (define (pop)
        (let ((res (vector-ref heap 0)))
          (vector-set! heap 0 (vector-ref heap (- (vector-length heap) 1)))
          (vector-set! heap (sub1 (vector-length heap)) #f)
          (let loop ((i 0))
            (let ((l (+ i 1))
                  (r (+ i 2)))
              (when (< i (quotient (vector-length heap) 2))
                (let ((min-child (if (and (< r (vector-length heap)) (< (vector-ref heap l) (vector-ref heap r))) l r)))
                  (when (> (vector-ref heap i) (vector-ref heap min-child))
                    (let ((t (vector-ref heap i)))
                      (vector-set! heap i (vector-ref heap min-child))
                      (vector-set! heap min-child t)
                      (loop min-child)))))))
          res)
      (define (size) (vector-length heap))
      (define (peek) (vector-ref heap 0))
      (define (empty?) (= (vector-length heap) 0))
      (lambda (m) (cond ((eq? m 'push) push) ((eq? m 'pop) pop) ((eq? m 'size) size) ((eq? m 'peek) peek) ((eq? m 'empty?) empty?))))
  (let ((h (heapq)))
    (for-each (lambda (x) ((h 'push) x)) piles)
    (let loop ()
      (when (and (> k 0) (not ((h 'empty?) )))
        (let ((val ((h 'pop) )))
          ((h 'push) (quotient val 2))
          (set! k (- k 1)))
        (loop)))
    (apply + (for/list ((i (in-range (h 'size)))) ((h 'pop) )))))