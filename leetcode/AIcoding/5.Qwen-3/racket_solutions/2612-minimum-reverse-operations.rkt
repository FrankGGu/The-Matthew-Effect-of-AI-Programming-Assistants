#lang racket

(define (min-reverse-operations n edges)
  (define adj (make-hash))
  (for-each (lambda (e)
              (let ([u (car e)] [v (cadr e)])
                (hash-set! adj u (cons v (hash-ref adj u '())))
                (hash-set! adj v (cons u (hash-ref adj v '())))))
            edges)
  (define dist (make-vector n -1))
  (define q (queue))
  (vector-set! dist 0 0)
  (enqueue! q 0)
  (define (bfs)
    (when (not (queue-empty? q))
      (define u (dequeue! q))
      (for-each (lambda (v)
                  (when (= (vector-ref dist v) -1)
                    (vector-set! dist v (+ (vector-ref dist u) 1))
                    (enqueue! q v)))
                (hash-ref adj u '()))
      (bfs)))
  (bfs)
  (vector->list dist))

(define (main)
  (define n (read))
  (define m (read))
  (define edges (for/list ([i m]) (list (read) (read))))
  (displayln (min-reverse-operations n edges)))

(main)