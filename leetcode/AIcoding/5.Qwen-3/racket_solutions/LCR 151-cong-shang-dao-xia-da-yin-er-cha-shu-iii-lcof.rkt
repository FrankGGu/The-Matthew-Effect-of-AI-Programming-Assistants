#lang racket

(define (level-order root)
  (if (not root)
      '()
      (let loop ((queue (list root)) (result '()))
        (if (null? queue)
            (reverse result)
            (let* ((size (length queue))
                   (current-level '())
                   (next-queue '()))
              (for ((i (in-range size)))
                (let ((node (car queue)))
                  (set! current-level (cons (node-val node) current-level))
                  (when (node-left node)
                    (set! next-queue (cons (node-left node) next-queue)))
                  (when (node-right node)
                    (set! next-queue (cons (node-right node) next-queue)))
                  (set! queue (cdr queue))))
              (loop next-queue (cons current-level result)))))))

(define (node-val node) (vector-ref node 0))
(define (node-left node) (vector-ref node 1))
(define (node-right node) (vector-ref node 2))