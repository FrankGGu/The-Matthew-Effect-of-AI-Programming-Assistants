(define (solve board)
  (define (in-bounds x y)
    (and (>= x 0) (< x (length board)) (>= y 0) (< y (length (list-ref board 0)))))
  (define (bfs x y)
    (define queue (list (cons x y)))
    (set! queue (reverse queue))
    (let loop ()
      (when (not (null? queue))
        (let* ((p (car queue))
               (x (car p))
               (y (cdr p)))
          (set! queue (cdr queue))
          (when (and (in-bounds x y) (char=? #\O (list-ref (list-ref board x) y)))
            (list-set! (list-ref board x) y #\A)
            (set! queue (append queue (list (cons (add1 x) y) (cons (sub1 x) y) (cons x (add1 y)) (cons x (sub1 y)))))))
        (loop))))
  (when (not (null? board))
    (let ((rows (length board)) (cols (length (list-ref board 0))))
      (for-each (lambda (i)
                  (bfs 0 i)
                  (bfs (sub1 rows) i))
                (range cols))
      (for-each (lambda (j)
                  (bfs j 0)
                  (bfs j (sub1 cols)))
                (range rows))
      (for-each (lambda (i)
                  (for-each (lambda (j)
                              (when (char=? #\O (list-ref (list-ref board i) j))
                                (list-set! (list-ref board i) j #\X)))
                            (range (length (list-ref board i)))))
                (range rows))
      (for-each (lambda (i)
                  (for-each (lambda (j)
                              (when (char=? #\A (list-ref (list-ref board i) j))
                                (list-set! (list-ref board i) j #\O)))
                            (range (length (list-ref board i)))))
                (range rows))))
  board)