#lang racket

(define (longest-palindromic-subsequence-after-at-most-k-operations s k)
  (define n (string-length s))
  (define dp (make-vector n (make-vector n 0)))
  (for ([i (in-range n)])
    (vector-set! (vector-ref dp i) i 1))
  (for ([length (in-range 2 (add1 n))])
    (for ([i (in-range 0 (- n length +1))])
      (define j (+ i length -1))
      (if (= (string-ref s i) (string-ref s j))
          (vector-set! (vector-ref dp i) j (+ 2 (vector-ref (vector-ref dp (+ i 1)) (- j 1))))
          (vector-set! (vector-ref dp i) j (max (vector-ref (vector-ref dp i) (- j 1)) (vector-ref (vector-ref dp (+ i 1)) j))))))
  (define (dfs i j ops)
    (cond [(>= i j) 0]
          [(= (string-ref s i) (string-ref s j)) (+ 2 (dfs (+ i 1) (- j 1) ops))]
          [else (if (< ops k)
                    (max (dfs (+ i 1) j (+ ops 1)) (dfs i (- j 1) (+ ops 1)))
                    (max (dfs (+ i 1) j ops) (dfs i (- j 1) ops)))]))
  (define (helper i j ops)
    (cond [(>= i j) 0]
          [(= (string-ref s i) (string-ref s j)) (+ 2 (helper (+ i 1) (- j 1) ops))]
          [else (if (< ops k)
                    (max (helper (+ i 1) j (+ ops 1)) (helper i (- j 1) (+ ops 1)))
                    (max (helper (+ i 1) j ops) (helper i (- j 1) ops)))]))
  (define memo (make-hash))
  (define (memoize i j ops)
    (let ([key (cons (cons i j) ops)])
      (if (hash-has-key? memo key)
          (hash-ref memo key)
          (let ([res (helper i j ops)])
            (hash-set! memo key res)
            res))))
  (define (dfs i j ops)
    (cond [(>= i j) 0]
          [(= (string-ref s i) (string-ref s j)) (+ 2 (dfs (+ i 1) (- j 1) ops))]
          [else (if (< ops k)
                    (max (dfs (+ i 1) j (+ ops 1)) (dfs i (- j 1) (+ ops 1)))
                    (max (dfs (+ i 1) j ops) (dfs i (- j 1) ops)))]))
  (if (<= k 0)
      (vector-ref (vector-ref dp 0) (- n 1))
      (let ([max-len (vector-ref (vector-ref dp 0) (- n 1))])
        (let loop ([i 0] [j (- n 1)] [ops 0])
          (if (>= i j)
              max-len
              (if (= (string-ref s i) (string-ref s j))
                  (loop (+ i 1) (- j 1) ops)
                  (if (< ops k)
                      (max (loop (+ i 1) j (+ ops 1)) (loop i (- j 1) (+ ops 1)))
                      (max (loop (+ i 1) j ops) (loop i (- j 1) ops)))))))))
  (define (solve)
    (let ([len (vector-ref (vector-ref dp 0) (- n 1))])
      (if (<= k 0)
          len
          (let ([max-len len])
            (let loop ([i 0] [j (- n 1)] [ops 0])
              (if (>= i j)
                  max-len
                  (if (= (string-ref s i) (string-ref s j))
                      (loop (+ i 1) (- j 1) ops)
                      (if (< ops k)
                          (max (loop (+ i 1) j (+ ops 1)) (loop i (- j 1) (+ ops 1)))
                          (max (loop (+ i 1) j ops) (loop i (- j 1) ops)))))))))
  (solve))