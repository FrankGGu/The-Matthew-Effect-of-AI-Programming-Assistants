#lang racket

(define (find-minimum-effort-to-reach-end rows cols grid)
  (define directions (list (cons 1 0) (cons -1 0) (cons 0 1) (cons 0 -1)))
  (define (get-value x y) (list-ref (list-ref grid y) x))
  (define (in-bounds? x y) (and (>= x 0) (< x cols) (>= y 0) (< y rows)))
  (define (bfs)
    (define dist (make-vector (* rows cols) +inf.0))
    (vector-set! dist 0 0)
    (define pq (make-heap #<))
    (heap-add! pq (cons 0 0))
    (let loop ()
      (when (not (heap-empty? pq))
        (define current (heap-remove! pq))
        (define cost (car current))
        (define pos (cdr current))
        (define x (remainder pos cols))
        (define y (quotient pos cols))
        (when (and (= x (sub1 cols)) (= y (sub1 rows)))
          (return cost))
        (for-each
         (lambda (d)
           (define nx (+ x (car d)))
           (define ny (+ y (cdr d)))
           (when (in-bounds? nx ny)
             (define new-cost (max cost (abs (- (get-value x y) (get-value nx ny)))))
             (define new-pos (+ nx (* ny cols)))
             (when (< new-cost (vector-ref dist new-pos))
               (vector-set! dist new-pos new-cost)
               (heap-add! pq (cons new-cost new-pos)))))
         directions)
        (loop))))
  (bfs))

(define (main)
  (define input (current-input))
  (define lines (string-split input "\n"))
  (define rows (string->number (list-ref lines 0)))
  (define cols (string->number (list-ref lines 1)))
  (define grid (map (lambda (l) (map string->number (string-split l " "))) (take lines (add1 rows))))
  (display (find-minimum-effort-to-reach-end rows cols grid)))

(main)