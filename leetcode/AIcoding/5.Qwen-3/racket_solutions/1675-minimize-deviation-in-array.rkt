#lang racket

(define (minimum-deviation nums)
  (define (get-min-deviation nums)
    (define pq (make-heap #f))
    (for-each (lambda (n)
                (heap-add! pq (cons n (if (even? n) n (* n 2)))))
              nums)
    (define max-val (apply max (map car nums)))
    (define res max-val)
    (let loop ()
      (let* ((current (heap-remove! pq))
             (val (car current))
             (next (cdr current)))
        (set! res (min res (- max-val val)))
        (when (and (even? next) (< next max-val))
          (heap-add! pq (cons next (if (even? next) next (* next 2))))
          (set! max-val (max max-val next)))
        (unless (heap-empty? pq)
          (loop))))
    res))
  (get-min-deviation nums))