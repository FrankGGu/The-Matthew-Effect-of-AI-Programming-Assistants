#lang racket

(define (k-smallest-pairs nums1 nums2 k)
  (define (heap? x) (and (vector? x) (= (vector-length x) 3)))
  (define (heap-ref h i) (vector-ref h i))
  (define (heap-set! h i v) (vector-set! h i v))
  (define (heap-size h) (heap-ref h 0))
  (define (heap-elt h) (heap-ref h 1))
  (define (heap-idx h) (heap-ref h 2))
  (define (heap-empty? h) (= (heap-size h) 0))
  (define (heap-parent i) (quotient (sub1 i) 2))
  (define (heap-left i) (+ (* 2 i) 1))
  (define (heap-right i) (+ (* 2 i) 2))
  (define (heap-swap h i j)
    (let ([tmp (heap-ref h i)])
      (heap-set! h i (heap-ref h j))
      (heap-set! h j tmp)))
  (define (heap-bubble-up h i)
    (cond [(= i 0) #f]
          [else
           (let ([p (heap-parent i)])
             (if (<= (heap-elt h) (heap-elt h p))
                 #f
                 (begin
                   (heap-swap h i p)
                   (heap-bubble-up h p))))]))
  (define (heap-bubble-down h i)
    (let ([l (heap-left i)]
          [r (heap-right i)])
      (let ([smallest i])
        (when (< l (heap-size h))
          (when (<= (heap-elt h l) (heap-elt h smallest))
            (set! smallest l)))
        (when (< r (heap-size h))
          (when (<= (heap-elt h r) (heap-elt h smallest))
            (set! smallest r)))
        (if (= smallest i)
            #f
            (begin
              (heap-swap h i smallest)
              (heap-bubble-down h smallest))))))
  (define (heap-insert h val idx)
    (heap-set! h (heap-size h) (list val idx))
    (heap-set! h 0 (add1 (heap-size h)))
    (heap-bubble-up h (heap-size h - 1)))
  (define (heap-extract-min h)
    (let ([min (heap-elt h 0)]
          [idx (heap-idx h 0)])
      (heap-set! h 0 (heap-ref h (sub1 (heap-size h))))
      (heap-set! h 0 (sub1 (heap-size h)))
      (heap-bubble-down h 0)
      (list min idx)))
  (define (heap-make)
    (vector 0 #f #f))
  (define (make-pair a b) (list a b))
  (define (pair-sum p) (+ (car p) (cadr p)))
  (define (pair-first p) (car p))
  (define (pair-second p) (cadr p))
  (define (pair-index p) (caddr p))
  (define (pair-set-index p i) (append (take p 2) (list i)))
  (define (get-pair i j)
    (make-pair (list-ref nums1 i) (list-ref nums2 j)))
  (define (get-sum i j) (+ (list-ref nums1 i) (list-ref nums2 j)))
  (define (heap-init)
    (let ([h (heap-make)])
      (for ([i (in-range (min k (length nums1)))])
        (heap-insert h (get-sum i 0) i))
      h))
  (define (solve)
    (let ([result '()]
          [h (heap-init)])
      (let loop ()
        (when (and (not (heap-empty? h)) (< (length result) k))
          (let* ([min-elt (heap-extract-min h)]
                 [sum (car min-elt)]
                 [i (cadr min-elt)]
                 [j (if (null? (cddr min-elt)) 0 (caddr min-elt))])
            (set! result (append result (list (get-pair i j))))
            (when (< (add1 j) (length nums2))
              (heap-insert h (get-sum i (add1 j)) i))
            (loop)))
      result))
  (solve))