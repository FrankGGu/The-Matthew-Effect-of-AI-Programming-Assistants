#lang racket

(define (max-fruits-fruit-orchard grid k)
  (define rows (length grid))
  (define cols (length (car grid)))
  (define directions '((0 1) (1 0) (0 -1) (-1 0)))
  (define (in-bounds? x y)
    (and (>= x 0) (< x rows) (>= y 0) (< y cols)))
  (define (get-value x y)
    (if (in-bounds? x y) (list-ref (list-ref grid x) y) 0))
  (define (bfs start-x start-y)
    (define visited (make-hash))
    (define q (queue (cons start-x start-y)))
    (hash-set! visited (cons start-x start-y) #t)
    (define total 0)
    (define steps 0)
    (define (process)
      (when (not (queue-empty? q))
        (define size (queue-length q))
        (do ((i 0 (+ i 1))) ((= i size))
          (define pos (queue-dequeue q))
          (define x (car pos))
          (define y (cdr pos))
          (set! total (+ total (get-value x y)))
          (when (<= steps k)
            (for-each
             (lambda (d)
               (define nx (+ x (car d)))
               (define ny (+ y (cadr d)))
               (when (and (in-bounds? nx ny) (not (hash-has-key? visited (cons nx ny))))
                 (hash-set! visited (cons nx ny) #t)
                 (queue-enqueue q (cons nx ny))))
             directions))
        (set! steps (+ steps 1))
        (process)))
    (process)
    total)
  (define max-total 0)
  (for ([x (in-range rows)])
    (for ([y (in-range cols)])
      (when (= (get-value x y) 1)
        (define result (bfs x y))
        (set! max-total (max max-total result))))
  max-total)