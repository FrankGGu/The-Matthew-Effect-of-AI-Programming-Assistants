#lang racket

(define (max-weighted-k-edge-path n edges k)
  (define graph (make-hash))
  (for-each (lambda (e)
              (let ([u (car e)] [v (cadr e)] [w (caddr e)])
                (hash-update! graph u (lambda (lst) (cons (cons v w) lst)) '())))
  (define dp (make-vector (+ n 1) #f))
  (define (dfs node visited)
    (if (>= (vector-ref visited node) k)
        (if (= k 0) 0 -inf.0)
        (let ([res -inf.0])
          (for-each (lambda (neighbor)
                      (let ([next-node (car neighbor)]
                            [weight (cdr neighbor)])
                        (when (not (vector-ref visited next-node))
                          (vector-set! visited next-node #t)
                          (let ([sub-res (dfs next-node visited)])
                            (when (not (equal? sub-res -inf.0))
                              (set! res (max res (+ weight sub-res)))))
                          (vector-set! visited next-node #f)))
                    (hash-ref graph node '()))
          res)))
  (define max-result -inf.0)
  (for-each (lambda (i)
              (define visited (make-vector (+ n 1) #f))
              (vector-set! visited i #t)
              (let ([res (dfs i visited)])
                (when (not (equal? res -inf.0))
                  (set! max-result (max max-result res))))
              (vector-set! visited i #f))
            (range 1 (+ n 1)))
  (if (equal? max-result -inf.0) -1 max-result))