#lang racket

(define (alien-order words)
  (define adj (make-hash))
  (define in-degree (make-hash))
  (define (add-node! c)
    (when (not (hash-has-key? adj c))
      (hash-set! adj c '())
      (hash-set! in-degree c 0)))
  (for-each (lambda (w)
              (for-each add-node! (string->list w)))
            words)
  (for-each (lambda (i)
              (define w1 (list-ref words i))
              (define w2 (list-ref words (add1 i)))
              (define len (min (string-length w1) (string-length w2)))
              (for ([j (in-range len)])
                (define c1 (string-ref w1 j))
                (define c2 (string-ref w2 j))
                (when (not (= c1 c2))
                  (when (not (member c2 (hash-ref adj c1)))
                    (hash-set! adj c1 (cons c2 (hash-ref adj c1)))
                    (hash-set! in-degree c2 (+ 1 (hash-ref in-degree c2))))
                  (break)))
            (in-range (sub1 (length words))))
  (define q (queue))
  (for ([(c _) in (hash->list in-degree)])
    (when (= 0 (hash-ref in-degree c))
      (queue-push! q c)))
  (define result '())
  (let loop ()
    (when (not (queue-empty? q))
      (define c (queue-pop! q))
      (set! result (cons c result))
      (for-each (lambda (neighbor)
                  (hash-set! in-degree neighbor (- (hash-ref in-degree neighbor) 1))
                  (when (= 0 (hash-ref in-degree neighbor))
                    (queue-push! q neighbor)))
                (hash-ref adj c))
      (loop)))
  (if (= (length result) (hash-count in-degree))
      (list->string (reverse result))
      ""))