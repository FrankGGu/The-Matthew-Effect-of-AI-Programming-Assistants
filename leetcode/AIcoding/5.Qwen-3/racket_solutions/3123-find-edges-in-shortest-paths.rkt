#lang racket

(define (find-edges-in-shortest-paths n edges)
  (define graph (make-hash))
  (for ([e edges])
    (let ([u (car e)] [v (cadr e)] [w (caddr e)])
      (hash-set! graph u (cons (list v w) (hash-ref graph u '())))
      (hash-set! graph v (cons (list u w) (hash-ref graph v '())))))

  (define (dijkstra start)
    (define dist (make-hash))
    (define visited (make-hash))
    (for ([i (in-range n)]) (hash-set! dist i +inf.0))
    (hash-set! dist start 0)
    (define pq (list (cons 0 start)))
    (while (not (null? pq))
      (let* ([current (caar pq)] [u (cdar pq)])
        (set! pq (cdr pq))
        (when (and (not (hash-has-key? visited u)) (= current (hash-ref dist u)))
          (hash-set! visited u #t)
          (for ([neighbor (hash-ref graph u '())])
            (let ([v (car neighbor)] [w (cadr neighbor)])
              (when (> (hash-ref dist v) (+ current w))
                (hash-set! dist v (+ current w))
                (set! pq (cons (cons (+ current w) v) pq))))))))
    (hash->list dist))

  (define dists (map dijkstra (range n)))
  (define result '())
  (for ([e edges])
    (let ([u (car e)] [v (cadr e)] [w (caddr e)])
      (let ([d1 (hash-ref (list-ref dists u) v)]
            [d2 (hash-ref (list-ref dists v) u)])
        (when (= (+ d1 w) (hash-ref (list-ref dists u) v))
          (set! result (cons e result))))))
  (reverse result))