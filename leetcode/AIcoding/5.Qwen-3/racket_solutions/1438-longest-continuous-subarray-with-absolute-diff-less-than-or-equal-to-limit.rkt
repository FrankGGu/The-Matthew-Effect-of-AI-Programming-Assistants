#lang racket

(define (longest-subarray nums limit)
  (define (get-max q)
    (if (null? q) 0 (caar q)))
  (define (get-min q)
    (if (null? q) 0 (cadar q)))
  (define (remove-old q i)
    (filter (lambda (x) (not (= (car x) i))) q))
  (define (add-to-queue q i val)
    (let loop ((q q) (new-q '()))
      (cond ((null? q) (cons (list i val) new-q))
            ((<= (cadr (car q)) val) (cons (list i val) (append new-q (cdr q))))
            (else (loop (cdr q) (cons (car q) new-q))))))
  (define (solve)
    (let loop ((left 0) (max-len 0) (max-queue '()) (min-queue '()))
      (if (= left (length nums))
          max-len
          (let* ((right (length nums))
                 (current (list-ref nums left))
                 (new-max-queue (add-to-queue max-queue left current))
                 (new-min-queue (add-to-queue min-queue left current))
                 (current-max (get-max new-max-queue))
                 (current-min (get-min new-min-queue))
                 (diff (- current-max current-min)))
            (if (> diff limit)
                (loop (+ left 1) max-len '() '())
                (loop (+ left 1) (max max-len (- right left)) new-max-queue new-min-queue))))))
  (solve))