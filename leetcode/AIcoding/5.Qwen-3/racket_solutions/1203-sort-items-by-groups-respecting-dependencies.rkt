#lang racket

(define (sort-items-by-groups-respecting-dependencies n m group items)
  (define graph (make-hash))
  (define in-degree (make-hash))
  (define group-graph (make-hash))
  (define group-in-degree (make-hash))

  (for ([i (in-range n)])
    (hash-set! graph i '())
    (hash-set! in-degree i 0)
    (hash-set! group-graph (car items) '())
    (hash-set! group-in-degree (car items) 0)
    (set! items (cdr items)))

  (for ([i (in-range n)])
    (define g (list-ref group i))
    (when (not (hash-has-key? group-graph g))
      (hash-set! group-graph g '())
      (hash-set! group-in-degree g 0)))

  (for ([i (in-range n)])
    (define g (list-ref group i))
    (when (not (equal? (list-ref items i) -1))
      (define dep (list-ref items i))
      (hash-set! graph i (cons dep (hash-ref graph i)))
      (hash-set! in-degree i (+ 1 (hash-ref in-degree i))))
    (when (not (equal? g -1))
      (define g2 (list-ref group (list-ref items i)))
      (when (and (not (equal? (list-ref items i) -1)) (not (equal? g g2)))
        (unless (member g2 (hash-ref group-graph g))
          (hash-set! group-graph g (cons g2 (hash-ref group-graph g)))
          (hash-set! group-in-degree g2 (+ 1 (hash-ref group-in-degree g2)))))))

  (define (topo-sort nodes in-degree graph)
    (define q (queue))
    (for ([n nodes])
      (when (= (hash-ref in-degree n) 0)
        (queue-add! q n)))
    (define result '())
    (let loop ()
      (when (not (queue-empty? q))
        (define u (queue-remove! q))
        (set! result (cons u result))
        (for ([v (hash-ref graph u)])
          (hash-set! in-degree v (- (hash-ref in-degree v) 1))
          (when (= (hash-ref in-degree v) 0)
            (queue-add! q v)))
        (loop))
      result))

  (define group-ids (remove-duplicates (filter (lambda (x) (not (equal? x -1))) group)))
  (define group-sorted (topo-sort group-ids group-in-degree group-graph))

  (define (get-group-members g)
    (filter (lambda (i) (= (list-ref group i) g)) (range n)))

  (define result '())
  (for ([g group-sorted])
    (define members (get-group-members g))
    (define sorted-members (topo-sort members in-degree graph))
    (set! result (append result sorted-members)))

  result)