#lang racket

(define (shortest-path grid k)
  (define rows (length grid))
  (define cols (if (null? grid) 0 (length (car grid))))
  (define visited (make-hash))
  (define (valid? r c)
    (and (<= 0 r (- rows 1)) (<= 0 c (- cols 1))))
  (define (bfs)
    (define q (queue))
    (queue-put! q (list 0 0 k 0))
    (hash-set! visited (cons 0 0) k)
    (let loop ()
      (when (not (queue-empty? q))
        (define current (queue-get! q))
        (define r (first current))
        (define c (second current))
        (define rem (third current))
        (define dist (fourth current))
        (when (and (= r (- rows 1)) (= c (- cols 1)))
          (values dist #t))
        (for-each
         (lambda (dir)
           (define nr (+ r (car dir)))
           (define nc (+ c (cadr dir)))
           (when (valid? nr nc)
             (define new-rem (if (= (list-ref (list-ref grid nr) nc) 1) (- rem 1) rem))
             (when (and (>= new-rem 0) (not (hash-has-key? visited (cons nr nc))) (or (not (hash-has-key? visited (cons nr nc))) (> (hash-ref visited (cons nr nc)) new-rem)))
               (hash-set! visited (cons nr nc) new-rem)
               (queue-put! q (list nr nc new-rem (+ dist 1))))))
         '((0 1) (1 0) (0 -1) (-1 0)))
        (loop)))
    (values -1 #f))
  (define-values (res ok) (bfs))
  (if ok res -1))