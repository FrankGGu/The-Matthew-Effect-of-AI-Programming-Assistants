#lang racket

(define (minimum-cost-path start end grid)
  (define rows (length grid))
  (define cols (if (null? grid) 0 (length (car grid))))
  (define directions '((0 . 1) (1 . 0) (0 . -1) (-1 . 0)))
  (define (get-value x y)
    (if (and (<= 0 x (sub1 rows)) (<= 0 y (sub1 cols)))
        (list-ref (list-ref grid x) y)
        #f))
  (define (valid? x y)
    (and (<= 0 x (sub1 rows)) (<= 0 y (sub1 cols))))
  (define (bfs)
    (define visited (make-hash))
    (define pq (priority-queue '()))
    (priority-queue-add! pq (cons 0 start) <)
    (hash-set! visited start 0)
    (let loop ()
      (when (not (priority-queue-empty? pq))
        (define current (priority-queue-remove! pq))
        (define cost (car current))
        (define pos (cdr current))
        (when (equal? pos end)
          (return cost))
        (for-each
         (lambda (dir)
           (define dx (car dir))
           (define dy (cdr dir))
           (define nx (+ (car pos) dx))
           (define ny (+ (cdr pos) dy))
           (when (valid? nx ny)
             (define new-cost (+ cost (get-value nx ny)))
             (define new-pos (cons nx ny))
             (when (or (not (hash-has-key? visited new-pos))
                       (< new-cost (hash-ref visited new-pos)))
               (hash-set! visited new-pos new-cost)
               (priority-queue-add! pq (cons new-cost new-pos) <))))
         directions)
        (loop)))
    #f)
  (bfs))