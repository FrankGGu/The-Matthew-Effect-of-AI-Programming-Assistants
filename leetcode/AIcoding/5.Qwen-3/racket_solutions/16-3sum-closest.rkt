(define (three-sum-closest nums target)
  (define (abs x) (if (< x 0) (- x) x))
  (define (sort lst)
    (cond ((null? lst) '())
          ((null? (cdr lst)) lst)
          (else (let ((pivot (car lst))
                      (rest (cdr lst)))
                  (append (sort (filter (lambda (x) (<= x pivot)) rest))
                          (list pivot)
                          (sort (filter (lambda (x) (> x pivot)) rest))))))
  (define sorted (sort nums))
  (define len (length sorted))
  (define closest (list-ref sorted 0))
  (define closest-diff (abs (- target (apply + (take sorted 3)))))
  (define (update-closest current)
    (let ((diff (abs (- target current))))
      (when (< diff closest-diff)
        (set! closest-diff diff)
        (set! closest current))))
  (define (loop i)
    (when (< i (- len 2))
      (let ((j (+ i 1))
            (k (- len 1)))
        (let loop-jk ()
          (when (<= j k)
            (let ((sum (+ (list-ref sorted i) (list-ref sorted j) (list-ref sorted k))))
              (update-closest sum)
              (if (< sum target)
                  (loop-jk (add1 j) k)
                  (loop-jk j (sub1 k))))))
      (loop (add1 i))))
  (loop 0)
  closest)