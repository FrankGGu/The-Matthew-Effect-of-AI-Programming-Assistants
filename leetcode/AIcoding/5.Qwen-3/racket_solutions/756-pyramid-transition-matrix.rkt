(define (make-heap lst)
  (let ((heap (list->vector lst)))
    (let loop ((i (quotient (- (vector-length heap) 1) 2)))
      (when (>= i 0)
        (let ((left (+ (* 2 i) 1))
              (right (+ (* 2 i) 2)))
          (when (and (< left (vector-length heap))
                     (> (vector-ref heap left) (vector-ref heap i)))
            (let ((tmp (vector-ref heap i)))
              (vector-set! heap i (vector-ref heap left))
              (vector-set! heap left tmp)))
          (when (and (< right (vector-length heap))
                     (> (vector-ref heap right) (vector-ref heap i)))
            (let ((tmp (vector-ref heap i)))
              (vector-set! heap i (vector-ref heap right))
              (vector-set! heap right tmp)))
          (loop (- i 1)))))
    heap))

(define (heap-pop heap)
  (let ((result (vector-ref heap 0)))
    (vector-set! heap 0 (vector-ref heap (- (vector-length heap) 1)))
    (vector-set! heap (- (vector-length heap) 1) #f)
    (let loop ((i 0))
      (let ((left (+ (* 2 i) 1))
            (right (+ (* 2 i) 2)))
        (when (and (< left (vector-length heap))
                   (> (vector-ref heap left) (vector-ref heap i)))
          (let ((tmp (vector-ref heap i)))
            (vector-set! heap i (vector-ref heap left))
            (vector-set! heap left tmp)
            (loop left)))
        (when (and (< right (vector-length heap))
                   (> (vector-ref heap right) (vector-ref heap i)))
          (let ((tmp (vector-ref heap i)))
            (vector-set! heap i (vector-ref heap right))
            (vector-set! heap right tmp)
            (loop right)))))
    result))

(define (pyramid-transition-matrix bottom k)
  (define (build-next-level current next-level)
    (if (null? current)
        (if (= (length next-level) 1)
            #t
            #f)
        (let ((current-pair (list (car current) (cadr current))))
          (if (not (member current-pair k))
              #f
              (let ((next-pair (list (cadr current) (caddr current))))
                (build-next-level (cdr current) (append next-level (list (car current) (cadr current)))))))))

  (define (dfs bottom)
    (if (= (length bottom) 1)
        #t
        (let ((next-levels (filter (lambda (x) (equal? (take bottom 2) x)) k)))
          (if (null? next-levels)
              #f
              (let loop ((levels next-levels))
                (if (null? levels)
                    #f
                    (let ((next-bottom (append (list (caar levels)) (cdr bottom))))
                      (if (dfs next-bottom)
                          #t
                          (loop (cdr levels)))))))))

  (dfs bottom))