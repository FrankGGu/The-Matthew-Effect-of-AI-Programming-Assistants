#lang racket

(define (min-sum-squared-diff nums k)
  (define (heap? x) (and (vector? x) (= (vector-length x) 2)))
  (define (heap-empty? h) (= (vector-ref h 1) 0))
  (define (heap-ref h i) (vector-ref h (+ i 1)))
  (define (heap-size h) (vector-ref h 1))
  (define (heap-set! h i v) (vector-set! h (+ i 1) v))
  (define (heap-parent i) (quotient (- i 1) 2))
  (define (heap-left i) (+ (* 2 i) 1))
  (define (heap-right i) (+ (* 2 i) 2))
  (define (heap-up h i)
    (let loop ()
      (when (> i 0)
        (let* ([p (heap-parent i)]
               [p-val (heap-ref h p)]
               [i-val (heap-ref h i)])
          (when (> p-val i-val)
            (swap h i p)
            (loop))))))
  (define (heap-down h i)
    (let loop ()
      (let ([l (heap-left i)]
            [r (heap-right i)])
        (let ([smallest i])
          (when (< l (heap-size h))
            (when (> (heap-ref h l) (heap-ref h smallest))
              (set! smallest l)))
          (when (< r (heap-size h))
            (when (> (heap-ref h r) (heap-ref h smallest))
              (set! smallest r)))
          (when (not (= smallest i))
            (swap h i smallest)
            (loop))))))
  (define (swap h i j)
    (let ([t (heap-ref h i)])
      (heap-set! h i (heap-ref h j))
      (heap-set! h j t)))
  (define (heap-insert h val)
    (let ([size (heap-size h)])
      (heap-set! h (+ size 1) val)
      (heap-up h size)
      (vector-set! h 1 (+ (heap-size h) 1))))
  (define (heap-extract-max h)
    (let ([max-val (heap-ref h 0)])
      (swap h 0 (- (heap-size h) 1))
      (heap-set! h (heap-size h) #f)
      (vector-set! h 1 (- (heap-size h) 1))
      (heap-down h 0)
      max-val))
  (define (heapify h)
    (let loop ([i (quotient (heap-size h) 2)])
      (when (>= i 0)
        (heap-down h i)
        (loop (- i 1)))))
  (define (build-heap lst)
    (let ([h (vector 0 (length lst))])
      (for ([i (in-range (length lst))])
        (vector-set! h (+ i 1) (list-ref lst i)))
      (heapify h)
      h))
  (let ([h (build-heap nums)])
    (for ([_ (in-range k)])
      (let ([val (heap-extract-max h)])
        (heap-insert h (- val 1))))
    (apply + (map (lambda (x) (* x x)) (vector->list (vector-take h (heap-size h)))))))