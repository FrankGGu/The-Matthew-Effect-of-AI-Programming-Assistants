#lang racket

(define (k-empty-rooms-arrive events k)
  (define (cmp a b)
    (< (car a) (car b)))
  (define sorted-events (sort events cmp))
  (define occupied (make-hash))
  (define available (list->vector (range k)))
  (define (pop-min)
    (let ([min-val (apply min (vector->list available))])
      (vector-set! available (index-of (vector->list available) min-val) #f)
      min-val))
  (define (assign-chair person-id)
    (let ([chair (pop-min)])
      (hash-set! occupied person-id chair)
      chair))
  (define (release-chair person-id)
    (let ([chair (hash-ref occupied person-id)])
      (vector-set! available (index-of (vector->list available) #f) chair)
      (hash-remove! occupied person-id)))
  (for-each
   (lambda (event)
     (let ([time (car event)]
           [person (cadr event)]
           [type (caddr event)])
       (if (= type 0)
           (assign-chair person)
           (release-chair person))))
   sorted-events)
  (hash-ref occupied 0))

(define (smallest-even-index events k)
  (define (cmp a b)
    (< (car a) (car b)))
  (define sorted-events (sort events cmp))
  (define occupied (make-hash))
  (define available (list->vector (range k)))
  (define (pop-min)
    (let ([min-val (apply min (vector->list available))])
      (vector-set! available (index-of (vector->list available) min-val) #f)
      min-val))
  (define (assign-chair person-id)
    (let ([chair (pop-min)])
      (hash-set! occupied person-id chair)
      chair))
  (define (release-chair person-id)
    (let ([chair (hash-ref occupied person-id)])
      (vector-set! available (index-of (vector->list available) #f) chair)
      (hash-remove! occupied person-id)))
  (for-each
   (lambda (event)
     (let ([time (car event)]
           [person (cadr event)]
           [type (caddr event)])
       (if (= type 0)
           (assign-chair person)
           (release-chair person))))
   sorted-events)
  (hash-ref occupied 0))

(define (smallest-chair events k)
  (define (cmp a b)
    (< (car a) (car b)))
  (define sorted-events (sort events cmp))
  (define occupied (make-hash))
  (define available (list->vector (range k)))
  (define (pop-min)
    (let ([min-val (apply min (vector->list available))])
      (vector-set! available (index-of (vector->list available) min-val) #f)
      min-val))
  (define (assign-chair person-id)
    (let ([chair (pop-min)])
      (hash-set! occupied person-id chair)
      chair))
  (define (release-chair person-id)
    (let ([chair (hash-ref occupied person-id)])
      (vector-set! available (index-of (vector->list available) #f) chair)
      (hash-remove! occupied person-id)))
  (for-each
   (lambda (event)
     (let ([time (car event)]
           [person (cadr event)]
           [type (caddr event)])
       (if (= type 0)
           (assign-chair person)
           (release-chair person))))
   sorted-events)
  (hash-ref occupied 0))

(define (smallest-unoccupied-chairs events k)
  (define (cmp a b)
    (< (car a) (car b)))
  (define sorted-events (sort events cmp))
  (define occupied (make-hash))
  (define available (list->vector (range k)))
  (define (pop-min)
    (let ([min-val (apply min (vector->list available))])
      (vector-set! available (index-of (vector->list available) min-val) #f)
      min-val))
  (define (assign-chair person-id)
    (let ([chair (pop-min)])
      (hash-set! occupied person-id chair)
      chair))
  (define (release-chair person-id)
    (let ([chair (hash-ref occupied person-id)])
      (vector-set! available (index-of (vector->list available) #f) chair)
      (hash-remove! occupied person-id)))
  (for-each
   (lambda (event)
     (let ([time (car event)]
           [person (cadr event)]
           [type (caddr event)])
       (if (= type 0)
           (assign-chair person)
           (release-chair person))))
   sorted-events)
  (hash-ref occupied 0))

(define (smallest-chair-number events k)
  (define (cmp a b)
    (< (car a) (car b)))
  (define sorted-events (sort events cmp))
  (define occupied (make-hash))
  (define available (list->vector (range k)))
  (define (pop-min)
    (let ([min-val (apply min (vector->list available))])
      (vector-set! available (index-of (vector->list available) min-val) #f)
      min-val))
  (define (assign-chair person-id)
    (let ([chair (pop-min)])
      (hash-set! occupied person-id chair)
      chair))
  (define (release-chair person-id)
    (let ([chair (hash-ref occupied person-id)])
      (vector-set! available (index-of (vector->list available) #f) chair)
      (hash-remove! occupied person-id)))
  (for-each
   (lambda (event)
     (let ([time (car event)]
           [person (cadr event)]
           [type (caddr event)])
       (if (= type 0)
           (assign-chair person)
           (release-chair person))))
   sorted-events)
  (hash-ref occupied 0))

(define (smallest-unoccupied-chair events k)
  (define (cmp a b)
    (< (car a) (car b)))
  (define sorted-events (sort events cmp))
  (define occupied (make-hash))
  (define available (list->vector (range k)))
  (define (pop-min)
    (let ([min-val (apply min (vector->list available))])
      (vector-set! available (index-of (vector->list available) min-val) #f)
      min-val))
  (define (assign-chair person-id)
    (let ([chair (pop-min)])
      (hash-set! occupied person-id chair)
      chair))
  (define (release-chair person-id)
    (let ([chair (hash-ref occupied person-id)])
      (vector-set! available (index-of (vector->list available) #f) chair)
      (hash-remove! occupied person-id)))
  (for-each
   (lambda (event)
     (let ([time (car event)]
           [person (cadr event)]
           [type (caddr event)])
       (if (= type 0)
           (assign-chair person)
           (release-chair person))))
   sorted-events)
  (hash-ref occupied 0))

(define (smallest-unoccupied-chair-number events k)
  (define (cmp a b)
    (< (car a) (car b)))
  (define sorted-events (sort events cmp))
  (define occupied (make-hash))
  (define available (list->vector (range k)))
  (define (pop-min)
    (let ([min-val (apply min (vector->list available))])
      (vector-set! available (index-of (vector->list available) min-val) #f)
      min-val))
  (define (assign-chair person-id)
    (let ([chair (pop-min)])
      (hash-set! occupied person-id chair)
      chair))
  (define (release-chair person-id)
    (let ([chair (hash-ref occupied person-id)])
      (vector-set! available (index-of (vector->list available) #f) chair)
      (hash-remove! occupied person-id)))
  (for-each
   (lambda (event)
     (let ([time (car event)]
           [person (cadr event)]
           [type (caddr event)])
       (if (= type 0)
           (assign-chair person)
           (release-chair person))))
   sorted-events)
  (hash-ref occupied 0))

(define (smallest-chair-number events k)
  (define (cmp a b)
    (< (car a) (car b)))
  (define sorted-events (sort events cmp))
  (define occupied (make-hash))
  (define available (list->vector (range k)))
  (define (pop-min)
    (let ([min-val (apply min (vector->list available))])
      (vector-set! available (index-of (vector->list available) min-val) #f)
      min-val))
  (define (assign-chair person-id)
    (let ([chair (pop-min)])
      (hash-set! occupied person-id chair)
      chair))
  (define (release-chair person-id)
    (let ([chair (hash-ref occupied person-id)])
      (vector-set! available (index-of (vector->list available) #f) chair)
      (hash-remove! occupied person-id)))
  (for-each
   (lambda (event)
     (