#lang racket

(define (minimum-time-to-visit-cell-in-a-grid grid)
  (define rows (length grid))
  (define cols (length (car grid)))
  (define directions '((0 1) (1 0) (-1 0) (0 -1)))
  (define visited (make-hash))
  (define pq (priority-queue '()))
  (when (and (= (vector-ref (vector-ref grid 0) 0) 0) (or (= rows 1) (= cols 1)))
    (priority-queue-add! pq (cons 0 (cons 0 0)) <))
  (when (and (> (vector-ref (vector-ref grid 0) 0) 0) (or (= rows 1) (= cols 1)))
    (priority-queue-add! pq (cons (if (= rows 1) (vector-ref (vector-ref grid 0) 1) (vector-ref (vector-ref grid 1) 0)) (cons 0 0)) <))
  (define (valid? x y)
    (and (>= x 0) (< x rows) (>= y 0) (< y cols)))
  (define (get-time x y)
    (if (hash-has-key? visited (cons x y))
        (hash-ref visited (cons x y))
        #f))
  (define (update-time x y t)
    (hash-set! visited (cons x y) t)
    (priority-queue-add! pq (cons t (cons x y)) <))
  (let loop ()
    (when (not (priority-queue-empty? pq))
      (define current (priority-queue-remove! pq))
      (define t (car current))
      (define x (caadr current))
      (define y (cdadr current))
      (when (and (= x (sub1 rows)) (= y (sub1 cols)))
        (return t))
      (for-each
       (lambda (d)
         (define nx (+ x (car d)))
         (define ny (+ y (cadr d)))
         (when (valid? nx ny)
           (define nt (+ t (if (<= (vector-ref (vector-ref grid nx) ny) t) 1 (max 0 (- (vector-ref (vector-ref grid nx) ny) t)))))
           (when (or (not (get-time nx ny)) (< nt (get-time nx ny)))
             (update-time nx ny nt))))
       directions)
      (loop)))
  #f)