#lang racket

(define (subarray-bitwise-or-closest-to-k nums k)
  (define n (length nums))
  (define res (vector 0))
  (define min-diff (vector +inf.0))
  (define (abs x) (if (< x 0) (- x) x))
  (define (update-res current)
    (let ([diff (abs (- current k))])
      (when (< diff (vector-ref min-diff 0))
        (vector-set! min-diff 0 diff)
        (vector-set! res 0 current))))
  (for ([i (in-range n)])
    (define s (make-hash))
    (hash-set! s (bitwise-ior (list-ref nums i) 0) #t)
    (update-res (list-ref nums i))
    (for ([j (in-range i -1 -1)])
      (define val (bitwise-ior (list-ref nums j) (hash-key (hash-ref s (bitwise-ior (list-ref nums j) (if (> j i) (list-ref nums j) 0))))))
      (hash-set! s val #t)
      (update-res val)))
  (vector-ref res 0))