#lang racket

(define (k-sum nums k)
  (define (heap-push h x)
    (set! h (cons x h))
    (let loop ((i 0))
      (when (< i (sub1 (length h)))
        (define j (if (< (+ i 1) (length h)) (min (+ i 1) (sub1 (length h))) i))
        (when (> (list-ref h i) (list-ref h j))
          (define tmp (list-ref h i))
          (set! h (list-set h i (list-ref h j)))
          (set! h (list-set h j tmp))
          (loop j)))))

  (define (heap-pop h)
    (define val (car h))
    (set! h (cdr h))
    (let loop ((i 0))
      (when (< i (sub1 (length h)))
        (define j (if (< (+ i 1) (length h)) (min (+ i 1) (sub1 (length h))) i))
        (when (> (list-ref h i) (list-ref h j))
          (define tmp (list-ref h i))
          (set! h (list-set h i (list-ref h j)))
          (set! h (list-set h j tmp))
          (loop j))))
    val)

  (define (heapify h)
    (let loop ((i (quotient (length h) 2 -1)))
      (when (>= i 0)
        (let loop2 ((j i))
          (when (< j (length h))
            (define k (if (< (+ j 1) (length h)) (min (+ j 1) (sub1 (length h))) j))
            (when (> (list-ref h j) (list-ref h k))
              (define tmp (list-ref h j))
              (set! h (list-set h j (list-ref h k)))
              (set! h (list-set h k tmp))
              (loop2 k))))
        (loop (sub1 i)))))

  (define (top-k-sums nums k)
    (define sum (apply + nums))
    (define min-heap (list sum))
    (for ([i (in-range (length nums))])
      (define new-heap (list))
      (for ([s (in-list min-heap)])
        (define new-s (- s (list-ref nums i)))
        (set! new-heap (append new-heap (list new-s))))
      (set! min-heap (append min-heap new-heap))
      (heapify min-heap))
    (define result (list))
    (for ([_ (in-range k)])
      (set! result (append result (list (heap-pop min-heap)))))
    (last result))

  (top-k-sums nums k))