#lang racket

(define (fraction-to-recurring-decimal n d)
  (define (abs x) (if (< x 0) (- x) x))
  (define (sign x) (if (< x 0) -1 1))
  (define (div a b)
    (let ((s (sign a)))
      (if (= s 1)
          (quotient a b)
          (- (quotient (- a) b)))))
  (define (mod a b)
    (remainder a b))
  (define (get-remainder a b seen)
    (cond ((= (mod a b) 0) '())
          ((assoc a seen) (cdr (assoc a seen)))
          (else
           (let ((next (cons (div a b) (get-remainder (mod a b) b (cons (cons a (length seen)) seen)))))
             next))))
  (define (format-result integer-part decimal-part)
    (if (null? decimal-part)
        (number->string integer-part)
        (string-append (number->string integer-part) "." (apply string-append (map number->string decimal-part)))))
  (if (= d 0)
      "0"
      (let* ((sign (if (or (and (positive? n) (negative? d)) (and (negative? n) (positive? d))) "-" ""))
             (n (abs n))
             (d (abs d))
             (integer-part (div n d))
             (remainder (mod n d))
             (decimal-part (get-remainder (* remainder 10) d '()))
             (result (format-result integer-part decimal-part)))
        (if (and (not (null? decimal-part)) (equal? (last decimal-part) 0))
            (substring result 0 (- (string-length result) 2))
            (string-append sign result)))))