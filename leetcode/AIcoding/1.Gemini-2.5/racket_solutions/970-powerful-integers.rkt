(require racket/set)

(define (powerful-integers x y bound)
  (let ((powerful-set (set)))
    (let loop-x ((current-x-power 1))
      (when (<= current-x-power bound)
        (let loop-y ((current-y-power 1))
          (when (<= (+ current-x-power current-y-power) bound)
            (set! powerful-set (set-add powerful-set (+ current-x-power current-y-power)))
            (when (> y 1)
              (loop-y (* current-y-power y))))))
        (when (> x 1)
          (loop-x (* current-x-power x))))))
    (set->list powerful-set)))