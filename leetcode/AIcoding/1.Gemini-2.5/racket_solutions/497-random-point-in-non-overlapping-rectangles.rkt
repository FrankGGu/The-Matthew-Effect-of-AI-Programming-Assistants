(require racket/random)

(struct solution (rects cumulative-areas total-area) #:transparent)

(define (solution-init rects)
  (let loop ((rects-list rects)
             (current-cumulative-area 0)
             (cumulative-areas-list '()))
    (if (null? rects-list)
        (solution rects (reverse cumulative-areas-list) current-cumulative-area)
        (let* ((rect (car rects-list))
               (x1 (list-ref rect 0))
               (y1 (list-ref rect 1))
               (x2 (list-ref rect 2))
               (y2 (list-ref rect 3))
               (width (+ (- x2 x1) 1))
               (height (+ (- y2 y1) 1))
               (area (* width height))
               (new-cumulative-area (+ current-cumulative-area area)))
          (loop (cdr rects-list)
                new-cumulative-area
                (cons new-cumulative-area cumulative-areas-list))))))

(define (solution-pick s)
  (let* ((total-area (solution-total-area s))
         (target-area (+ 1 (random total-area)))
         (rects (solution-rects s))
         (cumulative-areas (solution-cumulative-areas s)))
    (let loop ((idx 0))
      (if (< idx (length rects))
          (if (<= target-area (list-ref cumulative-areas idx))
              (let* ((chosen-rect (list-ref rects idx))
                     (x1 (list-ref chosen-rect 0))
                     (y1 (list-ref chosen-rect 1))
                     (x2 (list-ref chosen-rect 2))
                     (y2 (list-ref chosen-rect 3))
                     (rand-x (+ x1 (random (+ (- x2 x1) 1))))
                     (rand-y (+ y1 (random (+ (- y2 y1) 1)))))
                (list rand-x rand-y))
              (loop (+ idx 1)))
          (error "Internal error: target-area out of bounds, should not happen")))))