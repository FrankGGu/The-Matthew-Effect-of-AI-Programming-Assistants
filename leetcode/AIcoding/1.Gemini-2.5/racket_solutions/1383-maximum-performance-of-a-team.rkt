#lang racket

(define (heap-parent i) (quotient (- i 1) 2))
(define (heap-left i) (+ (* 2 i) 1))
(define (heap-right i) (+ (* 2 i) 2))

(define (vector-swap! v i j)
  (let ((temp (vector-ref v i)))
    (vector-set! v i (vector-ref v j))
    (vector-set! v j temp)))

(define (heapify-down! heap-vec heap-size i)
  (let loop ((idx i))
    (let* ((l (heap-left idx))
           (r (heap-right idx))
           (smallest idx))
      (when (and (< l heap-size)
                 (< (vector-ref heap-vec l) (vector-ref heap-vec smallest)))
        (set! smallest l))
      (when (and (< r heap-size)
                 (< (vector-ref heap-vec r) (vector-ref heap-vec smallest)))
        (set! smallest r))
      (when (not (= smallest idx))
        (vector-swap! heap-vec idx smallest)
        (loop smallest)))))

(define (heapify-up! heap-vec i)
  (let loop ((idx i))
    (let ((p (heap-parent idx)))
      (when (and (> idx 0)
                 (< (vector-ref heap-vec idx) (vector-ref heap-vec p)))
        (vector-swap! heap-vec idx p)
        (loop p)))))

(define (heap-add! heap-vec heap-size val)
  (vector-set! heap-vec heap-size val)
  (heapify-up! heap-vec heap-size)
  (+ heap-size 1))

(define (heap-pop-min! heap-vec heap-size)
  (when (> heap-size 0)
    (let ((min-val (vector-ref heap-vec 0)))
      (vector-set! heap-vec 0 (vector-ref heap-vec (- heap-size 1)))
      (heapify-down! heap-vec (- heap-size 1) 0)
      (values min-val (- heap-size 1)))))

(define (max-performance n speeds efficiencies k)
  (let* ((engineers (map (lambda (e s) (cons e s)) efficiencies speeds))
         (sorted-engineers (sort engineers (lambda (a b) (> (car a) (car b)))))
         (min-heap-vec (make-vector n 0))
         (heap-current-size 0)
         (current-speed-sum 0)
         (max-perf 0)
         (MOD 1000000007))

    (for-each (lambda (engineer)
                (let* ((e (car engineer))
                       (s (cdr engineer)))
                  (set! heap-current-size (heap-add! min-heap-vec heap-current-size s))
                  (set! current-speed-sum (+ current-speed-sum s))

                  (when (> heap-current-size k)
                    (let-values (((popped-speed new-size) (heap-pop-min! min-heap-vec heap-current-size)))
                      (set! heap-current-size new-size)
                      (set! current-speed-sum (- current-speed-sum popped-speed))))

                  (set! max-perf (max max-perf (* current-speed-sum e)))))
              sorted-engineers)
    (modulo max-perf MOD)))