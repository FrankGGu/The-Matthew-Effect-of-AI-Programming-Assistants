#lang racket

(define-struct string-builder (chars) #:mutable)

(define (make-string-builder)
  (make-string-builder '()))

(define (string-builder-add-char! sb char)
  (set-string-builder-chars! sb (cons char (string-builder-chars sb))))

(define (string-builder-build sb)
  (list->string (reverse (string-builder-chars sb))))

(define-struct heap (vec size comp) #:mutable)

(define (heap-parent i) (quotient (- i 1) 2))
(define (heap-left i) (+ (* 2 i) 1))
(define (heap-right i) (+ (* 2 i) 2))

(define (heap-swap! h i j)
  (let ((temp (vector-ref (heap-vec h) i)))
    (vector-set! (heap-vec h) i (vector-ref (heap-vec h) j))
    (vector-set! (heap-vec h) j temp)))

(define (heap-sift-up! h i)
  (let loop ((idx i))
    (let ((p (heap-parent idx)))
      (when (and (> idx 0) ((heap-comp h) (vector-ref (heap-vec h) idx) (vector-ref (heap-vec h) p)))
        (heap-swap! h idx p)
        (loop p)))))

(define (heap-sift-down! h i)
  (let loop ((idx i))
    (let* ((l (heap-left idx))
           (r (heap-right idx))
           (largest idx))
      (when (and (< l (heap-size h)) ((heap-comp h) (vector-ref (heap-vec h) l) (vector-ref (heap-vec h) largest)))
        (set! largest l))
      (when (and (< r (heap-size h)) ((heap-comp h) (vector-ref (heap-vec h) r) (vector-ref (heap-vec h) largest)))
        (set! largest r))
      (when (not (= largest idx))
        (heap-swap! h idx largest)
        (loop largest)))))

(define (make-heap comp)
  (make-heap (make-vector 100000 #f) 0 comp))

(define (heap-push! h item)
  (when (= (heap-size h) (vector-length (heap-vec h)))
    (error "Heap capacity exceeded"))
  (vector-set! (heap-vec h) (heap-size h) item)
  (set-heap-size! h (+ (heap-size h) 1))
  (heap-sift-up! h (- (heap-size h) 1)))

(define (heap-pop! h)
  (when (zero? (heap-size h))
    (error "Heap is empty"))
  (let ((root (vector-ref (heap-vec h) 0)))
    (set-heap-size! h (- (heap-size h) 1))
    (when (> (heap-size h) 0)
      (vector-set! (heap-vec h) 0 (vector-ref (heap-vec h) (heap-size h)))
      (heap-sift-down! h 0))
    root))

(define (heap-peek h)
  (when (zero? (heap-size h))
    (error "Heap is empty"))
  (vector-ref (heap-vec h) 0))

(define (heap-empty? h)
  (zero? (heap-size h)))

(define (minimum-string-after-removing-stars s)
  (let* ((n (string-length s))
         (removed (make-vector n #f))
         (pq-comp (lambda (item1 item2)
                    (let ((char1 (car item1))
                          (idx1 (cdr item1))
                          (char2 (car item2))
                          (idx2 (cdr item2)))
                      (or (> char1 char2)
                          (and (= char1 char2) (> idx1 idx2))))))
         (pq (make-heap pq-comp)))

    (for ((i (in-range n)))
      (let ((c (string-ref s i)))
        (if (char=? c #\*)
            (begin
              (when (not (heap-empty? pq))
                (let loop ()
                  (let ((top-item (heap-peek pq)))
                    (when (vector-ref removed (cdr top-item))
                      (heap-pop! pq)
                      (when (not (heap-empty? pq))
                        (loop))))))
                (when (not (heap-empty? pq))
                  (let ((item-to-remove (heap-pop! pq)))
                    (vector-set! removed (cdr item-to-remove) #t)))))
            (heap-push! pq (cons c i)))))

    (let ((result-chars (make-string-builder)))
      (for ((i (in-range n)))
        (when (and (char-alphabetic? (string-ref s i))
                   (not (vector-ref removed i)))
          (string-builder-add-char! result-chars (string-ref s i))))
      (string-builder-build result-chars))))