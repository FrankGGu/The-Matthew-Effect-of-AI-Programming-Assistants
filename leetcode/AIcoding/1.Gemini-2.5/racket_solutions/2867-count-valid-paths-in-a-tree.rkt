(require racket/vector)
(require racket/queue)

(define (sieve n)
  (define is-prime (make-vector (+ n 1) #t))
  (vector-set! is-prime 0 #f)
  (vector-set! is-prime 1 #f)
  (for ([p (in-range 2 (add1 n))])
    (when (vector-ref is-prime p)
      (for ([multiple (in-range (* p p) (add1 n) p)])
        (vector-set! is-prime multiple #f))))
  is-prime)

(define (build-adj n edges)
  (define adj (make-vector (+ n 1) '()))
  (for ([edge edges])
    (define u (car edge))
    (define v (cadr edge))
    (vector-set! adj u (cons v (vector-ref adj u)))
    (vector-set! adj v (cons u (vector-ref adj v))))
  adj)

(define (get-component-size start-node adj is-prime visited)
  (define q (make-queue))
  (queue-put! q start-node)
  (vector-set! visited start-node #t)
  (define current-component-size 0)

  (let loop ()
    (when (not (queue-empty? q))
      (define curr (queue-get! q))
      (set! current-component-size (add1 current-component-size))
      (for ([neighbor (vector-ref adj curr)])
        (when (and (vector-ref is-prime neighbor)
                   (not (vector-ref visited neighbor)))
          (vector-set! visited neighbor #t)
          (queue-put! q neighbor)))
      (loop)))
  current-component-size)

(define (count-valid-paths-in-tree n edges)
  (define max-node n)
  (define is-prime (sieve max-node))
  (define adj (build-adj max-node edges))
  (define visited (make-vector (add1 max-node) #f))
  (define total-valid-paths 0)

  (for ([u (in-range 1 (add1 max-node))])
    (when (and (vector-ref is-prime u)
               (not (vector-ref visited u)))
      (define component-size (get-component-size u adj is-prime visited))
      (set! total-valid-paths
            (+ total-valid-paths
               (/ (* component-size (add1 component-size)) 2)))))
  total-valid-paths)