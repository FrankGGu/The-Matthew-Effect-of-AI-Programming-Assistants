(define (find-largest-palindrome-divisible-by-k n k-divisor)
  (define (is-n-digit? num n-digits-min n-digits-max)
    (and (>= num n-digits-min) (<= num n-digits-max)))

  (define (make-palindrome num)
    (let* ((s (number->string num))
           (rev-s (string-reverse s)))
      (string->number (string-append s rev-s))))

  (let* ((max-factor (- (expt 10 n) 1))
         (min-factor (expt 10 (sub1 n))))

    (call/cc
     (lambda (return)
       (if (= n 1)
           (let loop-p ((p 9))
             (if (= (remainder p k-divisor) 0)
                 (let loop-f1 ((f1 9))
                   (if (= (remainder p f1) 0)
                       (let ((f2 (quotient p f1)))
                         (if (is-n-digit? f2 min-factor max-factor)
                             (return p)
                             (loop-f1 (sub1 f1))))
                       (loop-f1 (sub1 f1))))
                 (loop-p (sub1 p))))
           (let loop-i ((i max-factor))
             (let ((p (make-palindrome i)))
               (if (= (remainder p k-divisor) 0)
                   (let loop-j ((j max-factor))
                     (if (and (>= j min-factor) (>= j (quotient (+ p max-factor -1) max-factor)))
                         (if (= (remainder p j) 0)
                             (let ((k (quotient p j)))
                               (if (is-n-digit? k min-factor max-factor)
                                   (return p)
                                   (loop-j (sub1 j))))
                             (loop-j (sub1 j)))
                         (loop-i (sub1 i))))
                   (loop-i (sub1 i)))))))
       #f))))