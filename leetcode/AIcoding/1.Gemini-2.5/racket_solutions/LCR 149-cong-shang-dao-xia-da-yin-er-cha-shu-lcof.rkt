#lang racket

(struct TreeNode (val left right) #:transparent)

(define (levelOrder root)
  (if (null? root)
      '()
      (let loop ((q (list root)) (result '()))
        (if (empty? q)
            (reverse result)
            (let* ((level-size (length q))
                   (current-level-nodes '())
                   (next-q '()))
              (let process-level ((i 0) (current-q q))
                (if (= i level-size)
                    (loop (reverse next-q) (cons (reverse current-level-nodes) result))
                    (let* ((curr (car current-q))
                           (remaining-q (cdr current-q)))
                      (set! current-level-nodes (cons (TreeNode-val curr) current-level-nodes))
                      (when (TreeNode-left curr)
                        (set! next-q (cons (TreeNode-left curr) next-q)))
                      (when (TreeNode-right curr)
                        (set! next-q (cons (TreeNode-right curr) next-q)))
                      (process-level (+ i 1) remaining-q)))))))))