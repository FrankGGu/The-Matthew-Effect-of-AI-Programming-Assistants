(define (append-k-integers-with-minimal-sum nums k)
  (let* ((sorted-unique-nums (sort (remove-duplicates nums) <)))
    (let-values (((final-sum final-count final-next-available-int)
                  (for/fold ((current-sum 0)
                             (count 0)
                             (next-available-int 1))
                            ((num (in-list sorted-unique-nums)))
                    (if (= count k)
                        (values current-sum count next-available-int)
                        (let* ((gap-size (- num next-available-int)))
                          (if (> gap-size 0)
                              (let* ((to-append (min (- k count) gap-size)))
                                (if (> to-append 0)
                                    (let* ((first-val next-available-int)
                                           (last-val (+ first-val to-append -1))
                                           (sum-to-add (/ (* to-append (+ first-val last-val)) 2)))
                                      (values (+ current-sum sum-to-add)
                                              (+ count to-append)
                                              (+ num 1)))
                                    (values current-sum count (+ num 1))))
                              (values current-sum count (+ num 1))))))))
      (if (< final-count k)
          (let* ((remaining-to-append (- k final-count))
                 (first-val final-next-available-int)
                 (last-val (+ first-val remaining-to-append -1))
                 (sum-to-add (/ (* remaining-to-append (+ first-val last-val)) 2)))
            (+ final-sum sum-to-add))
          final-sum))))