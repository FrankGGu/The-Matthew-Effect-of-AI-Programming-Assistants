(define (min-capacity nums k)
  (define (can-rob-k? capacity k-target nums-list)
    (let* ((final-state (foldl (lambda (n acc)
                                  (let* ((rob-prev (car acc))
                                         (not-rob-prev (cadr acc))
                                         (current-rob-val (if (<= n capacity)
                                                              (+ not-rob-prev 1)
                                                              0))
                                         (current-not-rob-val (max rob-prev not-rob-prev)))
                                    (list current-rob-val current-not-rob-val)))
                                (list 0 0) ; Initial (rob-prev, not-rob-prev)
                                nums-list))
           (final-rob (car final-state))
           (final-not-rob (cadr final-state)))
      (>= (max final-rob final-not-rob) k-target)))

  (let* ((min-val (apply min nums))
         (max-val (apply max nums))
         (low min-val)
         (high max-val)
         (ans max-val))

    (let loop ((l low) (h high) (current-ans ans))
      (if (> l h)
          current-ans
          (let* ((mid (+ l (quotient (- h l) 2))))
            (if (can-rob-k? mid k nums)
                (loop l (- mid 1) mid)
                (loop (+ mid 1) h current-ans)))))))