import collections

class Solution:
    def minimizeMalwareSpread(self, graph: list[list[int]], initial: list[int]) -> int:
        N = len(graph)

        # 1. Component Discovery (BFS)
        # visited: keeps track of visited nodes during BFS
        # component_id_map: maps each node to its connected component ID
        # component_sizes: maps component_id to the number of nodes in that component
        visited = [False] * N
        component_id_map = [-1] * N 
        component_sizes = {} 

        current_component_id = 0

        for i in range(N):
            if not visited[i]:
                current_component_nodes = []
                q = collections.deque([i])
                visited[i] = True
                component_id_map[i] = current_component_id
                current_component_nodes.append(i)

                while q:
                    u = q.popleft()
                    for v in range(N):
                        if graph[u][v] == 1 and not visited[v]:
                            visited[v] = True
                            component_id_map[v] = current_component_id
                            current_component_nodes.append(v)
                            q.append(v)

                component_sizes[current_component_id] = len(current_component_nodes)
                current_component_id += 1

        # 2. Populate initial_in_component_counts
        # initial_in_component_counts: maps component_id to the count of initial malware nodes in it
        initial_in_component_counts = {} 

        for node in initial:
            comp_id = component_id_map[node]
            initial_in_component_counts[comp_id] = initial_in_component_counts.get(comp_id, 0) + 1

        # 3. Find Best Node to Remove
        min_infected_count = float('inf')
        best_node_to_remove = -1

        # Sort the initial list to easily handle the tie-breaking rule
        # (return the smallest index if multiple nodes yield the same minimum spread).
        initial.sort() 

        for node_to_remove in initial:
            current_infected_count = 0
            comp_id_of_removed_node = component_id_map[node_to_remove]

            for comp_id in component_sizes:
                count_initial_in_this_comp = initial_in_component_counts.get(comp_id, 0)

                if comp_id == comp_id_of_removed_node:
                    # If this is the component containing the node we are considering removing
                    # Check if it still has other initial nodes after removing 'node_to_remove'
                    if count_initial_in_this_comp - 1 > 0:
                        current_infected_count += component_sizes[comp_id]
                else:
                    # For other components, if they have any initial nodes, they will be infected
                    if count_initial_in_this_comp > 0:
                        current_infected_count += component_sizes[comp_id]

            # Update minimum infected count and best node
            if current_infected_count < min_infected_count:
                min_infected_count = current_infected_count
                best_node_to_remove = node_to_remove
            elif current_infected_count == min_infected_count:
                # Tie-breaking: if counts are equal, choose the node with the smallest index.
                # Since 'initial' is sorted, 'node_to_remove' will be greater than or equal
                # to the current 'best_node_to_remove' if they are from the same count group.
                # So, we only update if 'node_to_remove' is strictly smaller (which would
                # only happen if 'best_node_to_remove' was initialized to a higher value or
                # if we didn't sort 'initial'). With sorted 'initial', the first one found
                # will already be the smallest. Using min() is robust.
                best_node_to_remove = min(best_node_to_remove, node_to_remove)

        return best_node_to_remove