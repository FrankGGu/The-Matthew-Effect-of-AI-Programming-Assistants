var minMalwareSpread = function(graph, initial) {
    const n = graph.length;
    const parent = Array(n).fill(0).map((_, i) => i);
    const componentSize = Array(n).fill(1); // Stores size of component if index is root

    function find(i) {
        if (parent[i] === i) {
            return i;
        }
        parent[i] = find(parent[i]);
        return parent[i];
    }

    function union(i, j) {
        let rootI = find(i);
        let rootJ = find(j);

        if (rootI !== rootJ) {
            // Union by size
            if (componentSize[rootI] < componentSize[rootJ]) {
                [rootI, rootJ] = [rootJ, rootI]; // Swap to ensure rootI is the larger component
            }
            parent[rootJ] = rootI;
            componentSize[rootI] += componentSize[rootJ];
            return true;
        }
        return false;
    }

    // Build DSU
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            if (graph[i][j] === 1) {
                union(i, j);
            }
        }
    }

    // Count infected nodes per component
    const infectedCountPerComponent = new Map(); // Map: root -> count of initial infected nodes in component
    for (const node of initial) {
        const root = find(node);
        infectedCountPerComponent.set(root, (infectedCountPerComponent.get(root) || 0) + 1);
    }

    // Sort initial array to handle tie-breaking (smallest index)
    initial.sort((a, b) => a - b);

    let maxSavedNodes = -1;
    let nodeToRemove = initial[0]; // Default to the smallest index in initial if no better option found

    for (const node of initial) {
        const root = find(node);
        const numInfectedInThisComponent = infectedCountPerComponent.get(root);

        if (numInfectedInThisComponent === 1) {
            // This component has only one infected node (the current 'node').
            // Removing 'node' will prevent this component from being infected.
            const currentComponentTotalNodes = componentSize[root];

            if (currentComponentTotalNodes > maxSavedNodes) {
                maxSavedNodes = currentComponentTotalNodes;
                nodeToRemove = node;
            } else if (currentComponentTotalNodes === maxSavedNodes) {
                // If multiple nodes offer the same maximum save, choose the one with the smallest index.
                // Since 'initial' is sorted, if we encounter a node with the same 'maxSavedNodes',
                // and it's smaller than the current 'nodeToRemove', it would have been processed earlier.
                // Thus, 'nodeToRemove' will already hold the smallest index. No action needed here.
            }
        }
    }

    return nodeToRemove;
};