#include <vector>
#include <numeric>
#include <algorithm>
#include <map>
#include <set>

class Solution {
public:
    int minMalwareSpread(std::vector<std::vector<int>>& graph, std::vector<int>& initial) {
        int N = graph.size();

        std::vector<int> component_id(N, -1);
        std::map<int, int> comp_sizes;
        int current_component_id = 0;

        for (int i = 0; i < N; ++i) {
            if (component_id[i] == -1) {
                std::vector<int> q;
                q.push_back(i);
                component_id[i] = current_component_id;
                int head = 0;
                int current_comp_size = 0;

                while(head < q.size()){
                    int u = q[head++];
                    current_comp_size++;

                    for (int v = 0; v < N; ++v) {
                        if (graph[u][v] == 1 && component_id[v] == -1) {
                            component_id[v] = current_component_id;
                            q.push_back(v);
                        }
                    }
                }
                comp_sizes[current_component_id] = current_comp_size;
                current_component_id++;
            }
        }

        std::map<int, int> comp_initial_nodes_count;
        for (int node : initial) {
            comp_initial_nodes_count[component_id[node]]++;
        }

        int total_infected_initial = 0;
        for (auto const& [comp_id, size] : comp_sizes) {
            if (comp_initial_nodes_count.count(comp_id) && comp_initial_nodes_count[comp_id] > 0) {
                total_infected_initial += size;
            }
        }

        std::sort(initial.begin(), initial.end());

        int min_infected_nodes = N + 1;
        int result_node = -1; 

        for (int node_to_remove : initial) {
            int current_infected_nodes = 0;
            int comp_id_of_removed = component_id[node_to_remove];

            if (comp_initial_nodes_count[comp_id_of_removed] == 1) {
                current_infected_nodes = total_infected_initial - comp_sizes[comp_id_of_removed];
            } else {
                current_infected_nodes = total_infected_initial;
            }

            if (current_infected_nodes < min_infected_nodes) {
                min_infected_nodes = current_infected_nodes;
                result_node = node_to_remove;
            } else if (current_infected_nodes == min_infected_nodes) {
                result_node = std::min(result_node, node_to_remove);
            }
        }

        return result_node;
    }
};