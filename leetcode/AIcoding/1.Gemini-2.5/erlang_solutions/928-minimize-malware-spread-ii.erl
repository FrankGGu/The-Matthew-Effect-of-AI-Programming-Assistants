-module(solution).
-export([min_malware_spread/2]).

build_adj(Graph) ->
    N = length(Graph),
    Adj = array:new([{size, N}, {default, []}]),
    build_adj_loop(0, Graph, Adj).

build_adj_loop(I, [], Adj) ->
    array:to_list(Adj);
build_adj_loop(I, [Row | Rest], Adj) ->
    Adj1 = build_adj_row(I, 0, Row, Adj),
    build_adj_loop(I + 1, Rest, Adj1).

build_adj_row(I, J, [], Adj) -> Adj;
build_adj_row(I, J, [0 | Rest], Adj) ->
    build_adj_row(I, J + 1, Rest, Adj);
build_adj_row(I, J, [1 | Rest], Adj) ->
    Adj1 = array:set(I, [J | array:get(I, Adj)], Adj),
    Adj2 = array:set(J, [I | array:get(J, Adj)], Adj1), % Graph is undirected
    build_adj_row(I, J + 1, Rest, Adj2).

find_components(N, AdjList, InitialSet) ->
    Visited = array:new([{size, N}, {default, false}]),
    NodeToCompId = array:new([{size, N}, {default, -1}]),
    CompInfo = [], % [{CompId, Size, InitialNodesInComp}]
    find_components_loop(0, N, AdjList, InitialSet, Visited, NodeToCompId, CompInfo, 0).

find_components_loop(I, N, _AdjList, _InitialSet, _Visited, NodeToCompId, CompInfo, _CompIdCounter) when I >= N ->
    {lists:reverse(CompInfo), NodeToCompId};
find_components_loop(I, N, AdjList, InitialSet, Visited, NodeToCompId, CompInfo, CompIdCounter) ->
    case array:get(I, Visited) of
        true ->
            find_components_loop(I + 1, N, AdjList, InitialSet, Visited, NodeToCompId, CompInfo, CompIdCounter);
        false ->
            {NewCompInfoElem, NewVisited, NewNodeToCompId} =
                bfs(I, AdjList, InitialSet, Visited, NodeToCompId, CompIdCounter),
            find_components_loop(I + 1, N, AdjList, InitialSet, NewVisited, NewNodeToCompId, [NewCompInfoElem | CompInfo], CompIdCounter + 1)
    end.

bfs(StartNode, AdjList, InitialSet, Visited, NodeToCompId, CompId) ->
    Q = queue:in(StartNode, queue:new()),
    Visited1 = array:set(StartNode, true, Visited),
    NodeToCompId1 = array:set(StartNode, CompId, NodeToCompId),
    ComponentNodes = [],
    InitialNodesInComp = [],
    bfs_loop(Q, AdjList, InitialSet, Visited1, NodeToCompId1, CompId, ComponentNodes, InitialNodesInComp).

bfs_loop(Q, AdjList, InitialSet, Visited, NodeToCompId, CompId, ComponentNodes, InitialNodesInComp) ->
    case queue:out(Q) of
        {{value, Curr}, Q1} ->
            ComponentNodes1 = [Curr | ComponentNodes],
            InitialNodesInComp1 =
                case sets:is_element(Curr, InitialSet) of
                    true -> [Curr | InitialNodesInComp];
                    false -> InitialNodesInComp
                end,
            {Q2, Visited1, NodeToCompId1} =
                lists:foldl(fun(Neighbor, {AccQ, AccVisited, AccNodeToCompId}) ->
                                case array:get(Neighbor, AccVisited) of
                                    false ->
                                        {queue:in(Neighbor, AccQ),
                                         array:set(Neighbor, true, AccVisited),
                                         array:set(Neighbor, CompId, AccNodeToCompId)};
                                    true ->
                                        {AccQ, AccVisited, AccNodeToCompId}
                                end
                            end, {Q1, Visited, NodeToCompId}, array:get(Curr, AdjList)),
            bfs_loop(Q2, AdjList, InitialSet, Visited1, NodeToCompId1, CompId, ComponentNodes1, InitialNodesInComp1);
        empty ->
            {{CompId, length(ComponentNodes), InitialNodesInComp}, Visited, NodeToCompId}
    end.

min_malware_spread(Graph, Initial) ->
    N = length(Graph),
    AdjList = build_adj(Graph),
    InitialSet = sets:from_list(Initial),

    {CompInfoList, _NodeToCompId} = find_components(N, AdjList, InitialSet),

    % Calculate saved nodes for each initial node
    SavedNodesMap = maps:new(),
    SavedNodesMap1 = lists:foldl(fun({_CompId, Size, InitialNodesInComp}, AccMap) ->
                                    case length(InitialNodesInComp) of
                                        1 ->
                                            Node = hd(InitialNodesInComp),
                                            maps:put(Node, Size, AccMap);
                                        _ ->
                                            AccMap
                                    end
                                end, SavedNodesMap, CompInfoList),

    % Find the best node to remove
    SortedInitial = lists:sort(Initial), % Sort for tie-breaking by smallest index

    % Default result if no node saves any spread, pick smallest initial node
    case SortedInitial of
        [] -> -1; % Problem constraints state 1 <= initial.length, so this case won't occur.
        [DefaultBest | _] ->
            find_best_node(SortedInitial, SavedNodesMap1, -1, DefaultBest)
    end.

find_best_node([], _SavedNodesMap, _MaxSaved, BestNode) ->
    BestNode;
find_best_node([CurrNode | Rest], SavedNodesMap, MaxSaved, BestNode) ->
    CurrentSaved = maps:get(CurrNode, SavedNodesMap, 0), % Default to 0 if node not in map (e.g., not in any single-initial component)
    case CurrentSaved > MaxSaved of
        true ->
            find_best_node(Rest, SavedNodesMap, CurrentSaved, CurrNode);
        false ->
            find_best_node(Rest, SavedNodesMap, MaxSaved, BestNode)
    end.