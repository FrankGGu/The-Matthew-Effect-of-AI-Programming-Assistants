-module(solution).
-export([min_malware_spread/2]).

find(I, #{parent := ParentMap, size := SizeMap} = DSUState) ->
    case maps:get(I, ParentMap) of
        I -> {I, DSUState};
        ParentI ->
            {Root, NewDSUState} = find(ParentI, DSUState),
            NewParentMap = maps:put(I, Root, maps:get(parent, NewDSUState)),
            {Root, NewDSUState#{parent := NewParentMap}}
    end.

union(I, J, DSUState) ->
    {RootI, DSUState1} = find(I, DSUState),
    {RootJ, DSUState2} = find(J, DSUState1),

    if RootI =:= RootJ ->
        DSUState2;
    else
        SizeMap = maps:get(size, DSUState2),
        SizeI = maps:get(RootI, SizeMap),
        SizeJ = maps:get(RootJ, SizeMap),

        if SizeI >= SizeJ ->
            NewParentMap = maps:put(RootJ, RootI, maps:get(parent, DSUState2)),
            NewSizeMap = maps:put(RootI, SizeI + SizeJ, maps:remove(RootJ, SizeMap)),
            DSUState2#{parent := NewParentMap, size := NewSizeMap};
        true ->
            NewParentMap = maps:put(RootI, RootJ, maps:get(parent, DSUState2)),
            NewSizeMap = maps:put(RootJ, SizeI + SizeJ, maps:remove(RootI, SizeMap)),
            DSUState2#{parent := NewParentMap, size := NewSizeMap}
        end
    end.

min_malware_spread(Graph, Initial) ->
    N = length(Graph),

    ParentMap0 = maps:from_list([{I, I} || I <- lists:seq(0, N-1)]),
    SizeMap0 = maps:from_list([{I, 1} || I <- lists:seq(0, N-1)]),
    DSUState0 = #{parent => ParentMap0, size => SizeMap0},

    DSUState1 = build_components(Graph, N, DSUState0, 0, 0),

    InitialCountPerRoot0 = maps:new(),
    InitialCountPerRoot = lists:foldl(
        fun(Node, Acc) ->
            {Root, _DSUState} = find(Node, DSUState1),
            maps:update_with(Root, fun(V) -> V + 1 end, 1, Acc)
        end, InitialCountPerRoot0, Initial),

    SortedInitial = lists:sort(Initial),

    DefaultResultNode = hd(SortedInitial),
    DefaultMaxSavedNodes = -1,

    {ResultNode, _MaxSavedNodes} = lists:foldl(
        fun(I, {CurrentResultNode, CurrentMaxSavedNodes}) ->
            {RootI, _DSUState} = find(I, DSUState1),
            ComponentSize = maps:get(RootI, maps:get(size, DSUState1)),
            InitialNodesInComponent = maps:get(RootI, InitialCountPerRoot, 0),

            NodesSaved = 0,
            if InitialNodesInComponent == 1 ->
                NodesSaved = ComponentSize;
            true ->
                ok
            end,

            if NodesSaved > CurrentMaxSavedNodes ->
                {I, NodesSaved};
            NodesSaved == CurrentMaxSavedNodes ->
                {CurrentResultNode, CurrentMaxSavedNodes};
            true ->
                {CurrentResultNode, CurrentMaxSavedNodes}
            end
        end, {DefaultResultNode, DefaultMaxSavedNodes}, SortedInitial),

    ResultNode.

build_components(Graph, N, DSUState, I, J) when I < N ->
    case J < N of
        true ->
            case I =:= J of
                true ->
                    build_components(Graph, N, DSUState, I, J + 1);
                false ->
                    case lists:nth(J + 1, lists:nth(I + 1, Graph)) of
                        1 ->
                            NewDSUState = union(I, J, DSUState),
                            build_components(Graph, N, NewDSUState, I, J + 1);
                        0 ->
                            build_components(Graph, N, DSUState, I, J + 1)
                    end
            end;
        false ->
            build_components(Graph, N, DSUState, I + 1, 0)
    end;
build_components(_Graph, _N, DSUState, _I, _J) ->
    DSUState.