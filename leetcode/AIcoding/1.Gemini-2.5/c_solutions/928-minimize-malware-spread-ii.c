#include <stdlib.h>
#include <stdbool.h>

static int* parent_dsu;
static int* component_size_dsu;

static int find_set(int v) {
    if (v == parent_dsu[v])
        return v;
    return parent_dsu[v] = find_set(parent_dsu[v]);
}

static void union_sets(int a, int b) {
    a = find_set(a);
    b = find_set(b);
    if (a != b) {
        // Union by size for efficiency
        if (component_size_dsu[a] < component_size_dsu[b]) {
            int temp = a;
            a = b;
            b = temp;
        }
        parent_dsu[b] = a;
        component_size_dsu[a] += component_size_dsu[b];
    }
}

int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize) {
    int N = graphSize;

    // Step 1: Create a set of initial malware nodes for quick lookup.
    bool* is_malware = (bool*)calloc(N, sizeof(bool));
    for (int i = 0; i < initialSize; ++i) {
        is_malware[initial[i]] = true;
    }

    // Initialize DSU
    parent_dsu = (int*)malloc(N * sizeof(int));
    component_size_dsu = (int*)malloc(N * sizeof(int));
    for (int i = 0; i < N; ++i) {
        parent_dsu[i] = i;
        component_size_dsu[i] = 1;
    }

    // Step 2: Build DSU for non-malware nodes.
    // Iterate through all possible edges
    for (int i = 0; i < N; ++i) {
        if (is_malware[i]) continue; // 'i' is an initial malware node, don't include in DSU for non-malware components
        for (int j = i + 1; j < N; ++j) { // Check only upper triangle to avoid duplicate edges and self-loops
            if (is_malware[j]) continue; // 'j' is an initial malware node
            if (graph[i][j] == 1) {
                union_sets(i, j);
            }
        }
    }

    // Step 3: Determine connections between malware nodes and non-malware components.
    // malware_connected_to_component[root_idx][malware_id] = true if malware_id connects to component root_idx
    bool** malware_connected_to_component = (bool**)calloc(N, sizeof(bool*));
    for (int i = 0; i < N; ++i) {
        malware_connected_to_component[i] = (bool*)calloc(N, sizeof(bool));
    }

    // Iterate through all nodes 'u' and their neighbors 'v'
    for (int u = 0; u < N; ++u) {
        if (is_malware[u]) continue; // 'u' must be a non-malware node to belong to a non-malware component
        int root_u = find_set(u);

        for (int v = 0; v < N; ++v) {
            if (graph[u][v] == 1 && is_malware[v]) {
                // Malware node 'v' is connected to non-malware node 'u'
                // Mark that malware node 'v' connects to the component of 'u' (identified by root_u)
                malware_connected_to_component[root_u][v] = true;
            }
        }
    }

    // Step 4: Calculate potential savings for each malware node.
    int* saved_nodes_by_malware = (int*)calloc(N, sizeof(int));

    for (int root = 0; root < N; ++root) {
        if (parent_dsu[root] == root) { // If 'root' is indeed a root of a component
            int connected_malware_count = 0;
            int single_malware_id = -1;

            for (int m_id = 0; m_id < N; ++m_id) {
                if (malware_connected_to_component[root][m_id]) {
                    connected_malware_count++;
                    single_malware_id = m_id; // This will store the ID if only one, or the last one if multiple
                }
            }

            // If exactly one malware node connects to this component, removing it saves the component.
            if (connected_malware_count == 1) {
                saved_nodes_by_malware[single_malware_id] += component_size_dsu[root];
            }
        }
    }

    // Step 5: Find the malware node to remove.
    int max_saved = -1; // Initialize with -1 to correctly handle cases where all savings are 0
    int result_malware_idx = -1;

    for (int i = 0; i < initialSize; ++i) {
        int current_malware_node = initial[i];
        int current_saved = saved_nodes_by_malware[current_malware_node];

        if (current_saved > max_saved) {
            max_saved = current_saved;
            result_malware_idx = current_malware_node;
        } else if (current_saved == max_saved) {
            // Tie-breaking: choose the smaller index
            if (current_malware_node < result_malware_idx) {
                result_malware_idx = current_malware_node;
            }
        }
    }

    // Free allocated memory
    free(is_malware);
    free(parent_dsu);
    free(component_size_dsu);
    for (int i = 0; i < N; ++i) {
        free(malware_connected_to_component[i]);
    }
    free(malware_connected_to_component);
    free(saved_nodes_by_malware);

    return result_malware_idx;
}