(define (maximum-number-of-k-divisible-components n edges k values)
  (define adj (make-vector n '()))
  (for-each (lambda (edge)
              (let ((u (car edge)) (v (cdr edge)))
                (vector-set! adj u (cons v (vector-ref adj u)))
                (vector-set! adj v (cons u (vector-ref adj v)))))
            edges)
  (define visited (make-vector n #f))
  (define count (box 0))
  (define (dfs u)
    (vector-set! visited u #t)
    (define sum (box (vector-ref values u)))
    (for-each (lambda (v)
                (when (not (vector-ref visited v))
                  (set-box! sum (+ (unbox sum) (dfs v)))))
              (vector-ref adj u))
    (if (zero? (modulo (unbox sum) k))
        (begin (set-box! count (+ (unbox count) 1)) 0)
        (unbox sum)))
  (for ([i (in-range n)])
    (when (not (vector-ref visited i))
      (dfs i)))
  (unbox count))