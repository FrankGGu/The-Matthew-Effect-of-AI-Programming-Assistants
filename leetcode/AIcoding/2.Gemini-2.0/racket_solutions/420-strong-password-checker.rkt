(define (strong-password-checker s)
  (define len (string-length s))
  (define missing (let ((lower (not (string-contains? s (regexp "[a-z]"))))
                        (upper (not (string-contains? s (regexp "[A-Z]"))))
                        (digit (not (string-contains? s (regexp "[0-9]")))))
                    (+ (if lower 1 0) (if upper 1 0) (if digit 1 0))))
  (define (repeating-chars s)
    (let loop ((i 0) (count 0) (repeats '()))
      (if (= i len)
          repeats
          (let ((j (let loop2 ((k (+ i 1)))
                      (if (and (< k len) (char=? (string-ref s i) (string-ref s k)))
                          (loop2 (+ k 1))
                          k))))
            (if (>= (- j i) 3)
                (loop j (+ count (- j i) 1) (cons (- j i) repeats))
                (loop j count repeats))))))
  (define repeats (repeating-chars s))
  (cond
    ((< len 6)
     (max missing (- 6 len)))
    ((> len 20)
     (let* ((diff (- len 20))
            (rem (sort (map (lambda (x) (modulo x 3)) repeats) <))
            (ops diff))
       (for ((r rem))
         (cond
           ((= r 0) (if (>= diff (quotient diff 3)) (set! ops (- ops (quotient diff 3))) (set! ops 0) (set! diff 0)))
           ((= r 1) (if (>= diff (quotient (+ diff 2) 3)) (set! ops (- ops (quotient (+ diff 2) 3))) (set! ops 0) (set! diff 0)))
           ((= r 2) (if (>= diff (quotient (+ diff 1) 3)) (set! ops (- ops (quotient (+ diff 1) 3))) (set! ops 0) (set! diff 0)))))
       (+ diff (max missing ops))))
    (else
     (length repeats) (max missing (length repeats)))))