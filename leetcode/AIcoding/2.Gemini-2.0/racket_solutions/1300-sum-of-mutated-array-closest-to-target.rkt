(define (find-best-value arr target)
  (let* ((n (length arr))
         (sorted-arr (sort arr <))
         (prefix-sums (make-vector (+ n 1) 0))
         (best-value (list 0 (abs (- (apply + arr) target)))))
    (for/fold ((i 1))
              ((a (in-list sorted-arr)))
      (vector-set! prefix-sums i (+ (vector-ref prefix-sums (- i 1)) a))
      (+ i 1))
    (define (check-value value)
      (let* ((idx (argmin (lambda (i) (abs (- (vector-ref sorted-arr i) value))) (range n)))
             (count (if (< (vector-ref sorted-arr idx) value) (+ idx 1) idx))
             (sum (+ (vector-ref prefix-sums count) (* (- n count) value)))
             (diff (abs (- sum target))))
        (when (< diff (cadr best-value))
          (set! best-value (list value diff)))))
    (let loop ((left 0) (right (vector-ref sorted-arr (- n 1))))
      (cond
        ((<= left right)
         (let ((mid (quotient (+ left right) 2)))
           (check-value mid)
           (loop (+ mid 1) right)
           (loop left (- mid 1))))
        (else (car best-value)))))