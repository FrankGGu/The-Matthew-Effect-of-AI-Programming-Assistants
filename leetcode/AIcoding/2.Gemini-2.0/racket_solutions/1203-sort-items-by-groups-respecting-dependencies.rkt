(define (sort-items-by-groups-respecting-dependencies n m group item-before)
  (define groups (make-vector n #f))
  (for/list ((i (in-range n)))
    (vector-set! groups i (list i)))
  (for/list ((i (in-range (length group))))
    (when (= (list-ref group i) -1)
      (list-set! group i i)))
  (define group-items (make-hash))
  (for/list ((i (in-range (length group))))
    (hash-update! group-items (list-ref group i) (lambda (x) (append x (list i))) (list)))
  (define (topological-sort items before)
    (define in-degree (make-hash))
    (define adj (make-hash))
    (for/list ((item (in-list items)))
      (hash-set! in-degree item 0)
      (hash-set! adj item (list)))
    (for/list ((i (in-range (length before))))
      (for/list ((j (in-list (list-ref before i))))
        (when (and (member i items) (member j items))
          (hash-update! in-degree i (lambda (x) (+ x 1)) 0)
          (hash-update! adj j (lambda (x) (append x (list i))) (list)))))
    (define queue (list))
    (for/list ((item (in-list items)))
      (when (= (hash-ref in-degree item) 0)
        (set! queue (append queue (list item)))))
    (define result (list))
    (while (not (empty? queue))
      (define u (car queue))
      (set! queue (cdr queue))
      (set! result (append result (list u)))
      (for/list ((v (in-list (hash-ref adj u))))
        (hash-update! in-degree v (lambda (x) (- x 1)) 0)
        (when (= (hash-ref in-degree v) 0)
          (set! queue (append queue (list v))))))
    (if (= (length result) (length items))
        result
        #f))
  (define group-ids (remove-duplicates group))
  (define group-before (make-hash))
  (for/list ((group-id (in-list group-ids)))
    (hash-set! group-before group-id (list)))
  (for/list ((i (in-range (length item-before))))
    (for/list ((j (in-list (list-ref item-before i))))
      (when (not (= (list-ref group i) (list-ref group j)))
        (hash-update! group-before (list-ref group j) (lambda (x) (append x (list (list-ref group i)))) (list))))
  (define group-before-unique (make-hash))
  (for/list ((group-id (in-list group-ids)))
    (hash-set! group-before-unique group-id (remove-duplicates (hash-ref group-before group-id))))
  (define sorted-groups (topological-sort group-ids (hash-values group-before-unique)))
  (if (not sorted-groups)
      (list)
      (let loop ((groups sorted-groups) (result (list)))
        (if (empty? groups)
            result
            (let* ((group-id (car groups))
                   (items (hash-ref group-items group-id))
                   (item-sorted (topological-sort items item-before)))
              (if (not item-sorted)
                  (list)
                  (loop (cdr groups) (append result item-sorted))))))))