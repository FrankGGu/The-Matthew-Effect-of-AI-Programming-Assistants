(define (mergeTriplets triplets target)
  (let ((good-triplets '()))
    (for ([triplet triplets])
      (when (and (<= (list-ref triplet 0) (list-ref target 0))
                 (<= (list-ref triplet 1) (list-ref target 1))
                 (<= (list-ref triplet 2) (list-ref target 2)))
        (set! good-triplets (cons triplet good-triplets))))
    (let ((found-target? #f))
      (for* ([i (length good-triplets)]
             [j (length good-triplets)])
        (let ((merged-triplet (list (max (list-ref (list-ref good-triplets i) 0) (list-ref (list-ref good-triplets j) 0))
                                     (max (list-ref (list-ref good-triplets i) 1) (list-ref (list-ref good-triplets j) 1))
                                     (max (list-ref (list-ref good-triplets i) 2) (list-ref (list-ref good-triplets j) 2)))))
          (when (equal? merged-triplet target)
            (set! found-target? #t)
            (break))))
      (if found-target?
          #t
          (let ((reachable (list 0 0 0)))
            (for ([triplet good-triplets])
              (set! reachable (list (max (list-ref reachable 0) (list-ref triplet 0))
                                     (max (list-ref reachable 1) (list-ref triplet 1))
                                     (max (list-ref reachable 2) (list-ref triplet 2)))))
            (equal? reachable target))))))