(define (minimize-max-edge-weight n edges p)
  (define (possible? max-weight)
    (define dsu (make-dsu n))
    (for-each (lambda (edge)
                (let ((u (car edge)) (v (cadr edge)) (w (caddr edge)))
                  (when (<= w max-weight)
                    (dsu-union! dsu u v))))
              edges)
    (= (dsu-count dsu) 1))

  (define (make-dsu n)
    (let ((parent (vector (range n)))
          (rank (vector-immutable (make-list n 0)))
          (count 0))
      (define (find x)
        (if (equal? x (vector-ref parent x))
            x
            (let ((root (find (vector-ref parent x))))
              (vector-set! parent x root)
              root)))
      (define (union! x y)
        (let ((root-x (find x))
              (root-y (find y)))
          (unless (equal? root-x root-y)
            (if (< (vector-ref rank root-x) (vector-ref rank root-y))
                (vector-set! parent root-x root-y)
                (begin
                  (vector-set! parent root-y root-x)
                  (when (equal? (vector-ref rank root-x) (vector-ref rank root-y))
                    (vector-set! rank root-x (+ 1 (vector-ref rank root-x))))))
            (set! count (+ count 1)))))
      (define (get-parent) parent)
      (define (get-rank) rank)
      (define (get-count) (length (remove-duplicates (map find (range n)))))
      (struct dsu-struct (parent rank count find union! get-parent get-rank get-count) #:transparent)
      (dsu-struct parent rank count find union! get-parent get-rank get-count)))

  (define (dsu-find dsu x) ((dsu-find dsu) x))
  (define (dsu-union! dsu x y) ((dsu-union! dsu) x y))
  (define (dsu-count dsu) ((dsu-get-count dsu)))

  (let loop ((left 1) (right 1000000000))
    (if (> left right)
        (if (possible? right) right -1)
        (let ((mid (floor (+ left right) 2)))
          (if (possible? mid)
              (loop left (- mid 1))
              (loop (+ mid 1) right))))))