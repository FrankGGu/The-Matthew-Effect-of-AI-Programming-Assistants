(define (watched-videos-by-friends watchedVideos friends id level)
  (define n (length watchedVideos))
  (define visited (make-vector n #f))
  (define q (list id))
  (vector-set! visited id #t)
  (define curr-level 0)
  (define videos '())

  (define (bfs)
    (if (empty? q)
        (sort (group-by videos identity)
              < #:key (lambda (x) (length x)))
        (let* ([curr-q q]
               [next-q '()])
          (set! q '())
          (for ([u curr-q])
            (for ([v (in-list (vector-ref friends u))])
              (unless (vector-ref visited v)
                (vector-set! visited v #t)
                (set! next-q (append next-q (list v))))))
          (if (= curr-level level)
              (for ([u curr-q])
                (set! videos (append videos (vector-ref watchedVideos u))))
              (begin
                (set! curr-level (+ curr-level 1))
                (set! q next-q)
                (bfs))))))

  (bfs)
  (map car (group-by videos identity)))