(define (maximum-groups n edges)
  (define adj (make-vector n '()))
  (for-each (lambda (edge)
              (let ((u (car edge)) (v (cadr edge)))
                (vector-set! adj (- u 1) (cons (- v 1) (vector-ref adj (- u 1)))))
              (let ((u (car edge)) (v (cadr edge)))
                (vector-set! adj (- v 1) (cons (- u 1) (vector-ref adj (- v 1))))))
            edges)

  (define (bfs start)
    (define dist (make-vector n -1))
    (vector-set! dist start 0)
    (define q (list start))
    (define max-dist 0)
    (define min-dist 10000000)

    (let loop ((q q))
      (if (null? q)
          (values max-dist min-dist)
          (let* ((u (car q))
                 (neighbors (vector-ref adj u))
                 (new-q (cdr q)))
            (for-each (lambda (v)
                        (if (= (vector-ref dist v) -1)
                            (begin
                              (vector-set! dist v (+ 1 (vector-ref dist u)))
                              (set! new-q (append new-q (list v))))
                            (if (= (modulo (+ (vector-ref dist u) (vector-ref dist v)) 2) 0)
                                (return -1)
                                (void))))
                      neighbors)
            (loop new-q))))

  (define components (make-vector n #f))
  (define component-count 0)
  (define max-dist 0)
  (define min-dist 10000000)

  (for/list ([i (in-range n)])
    (if (not (vector-ref components i))
        (let ((res (bfs i)))
          (if (= res -1)
              (return -1)
              (begin
               (set! component-count (+ component-count 1))
               (values (car res) (cadr res))
              ))))
    )

  (let loop ((k 0))
    (if (> (/ (* k (+ k 1)) 2) (length edges))
        (- k 1)
        (loop (+ k 1))))
  )