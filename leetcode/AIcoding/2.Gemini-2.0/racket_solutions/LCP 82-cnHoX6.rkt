(define (solve n edges)
  (let* ((graph (make-hash))
         (degrees (make-vector (add1 n) 0)))
    (for ([edge edges])
      (let ([u (first edge)] [v (second edge)])
        (hash-update! graph u (lambda (x) (cons v x)) '())
        (hash-update! graph v (lambda (x) (cons u x)) '())
        (vector-set! degrees u (add1 (vector-ref degrees u)))
        (vector-set! degrees v (add1 (vector-ref degrees v)))))
    (let loop ([leaves (filter (lambda (i) (= (vector-ref degrees i) 1)) (range 1 (add1 n)))]
               [remaining n])
      (if (<= remaining 2)
          leaves
          (let ([new-leaves '()])
            (for ([leaf leaves])
              (let ([neighbor (car (hash-ref graph leaf '()))])
                (vector-set! degrees leaf 0)
                (vector-set! degrees neighbor (sub1 (vector-ref degrees neighbor)))
                (when (= (vector-ref degrees neighbor) 1)
                  (set! new-leaves (cons neighbor new-leaves)))))
            (loop new-leaves (- remaining (length leaves))))))))