(define (k-highest-ranked-items prices starting ending row col k)
  (define m (length prices))
  (define n (length (first prices)))
  (define q (list (list row col 0)))
  (define visited (make-hash))
  (hash-set! visited (list row col) #t)
  (define result '())
  (define (valid-coordinate? r c)
    (and (>= r 0) (< r m) (>= c 0) (< c n)))
  (define (bfs)
    (if (null? q)
        (sort result (lambda (x y)
                       (cond ((< (first x) (first y)) #t)
                             ((> (first x) (first y)) #f)
                             ((< (second x) (second y)) #t)
                             ((> (second x) (second y)) #f)
                             ((< (third x) (third y)) #t)
                             (else #f)))))
        (let* ((curr (car q))
               (q (cdr q))
               (r (first curr))
               (c (second curr))
               (d (third curr))
               (price (list-ref (list-ref prices r) c)))
          (begin
            (if (and (>= price starting) (<= price ending) (not (= price 1)))
                (set! result (cons (list d price r c) result)))
            (let ((neighbors (list (list (- r 1) c) (list (+ r 1) c) (list r (- c 1)) (list r (+ c 1)))))
              (for-each
               (lambda (neighbor)
                 (let ((nr (first neighbor))
                       (nc (second neighbor)))
                   (if (and (valid-coordinate? nr nc) (not (hash-has-key? visited (list nr nc))) (not (= (list-ref (list-ref prices nr) nc) 0)))
                       (begin
                         (hash-set! visited (list nr nc) #t)
                         (set! q (append q (list (list nr nc (+ d 1)))))))))
               neighbors))
            (bfs)))))
  (let ((sorted-result (bfs)))
    (map (lambda (x) (list (third (cdr x)) (fourth (cdr x)))) (take (sort result (lambda (x y)
                       (cond ((< (first x) (first y)) #t)
                             ((> (first x) (first y)) #f)
                             ((< (second x) (second y)) #t)
                             ((> (second x) (second y)) #f)
                             ((< (third x) (third y)) #t)
                             (else #f))))) k))))