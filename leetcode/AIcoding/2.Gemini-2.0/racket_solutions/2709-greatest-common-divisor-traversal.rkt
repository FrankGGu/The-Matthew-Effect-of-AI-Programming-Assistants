(define (gcd-traversal nums)
  (define n (length nums))
  (define parent (make-vector n))
  (for ((i (in-range n)))
    (vector-set! parent i i))

  (define (find x)
    (if (= (vector-ref parent x) x)
        x
        (let ((root (find (vector-ref parent x))))
          (vector-set! parent x root)
          root)))

  (define (union x y)
    (let ((rootx (find x))
          (rooty (find y)))
      (if (!= rootx rooty)
          (vector-set! parent rootx rooty))))

  (define prime-factors (make-hash))
  (for ((i (in-range n)))
    (let ((num (vector-ref nums i)))
      (let loop ((d 2) (num num))
        (cond
          ((> d (sqrt num))
           (when (> num 1)
             (let ((p num))
               (unless (hash-has-key? prime-factors p)
                 (hash-set! prime-factors p '()))
               (for ((j (in-list (hash-ref prime-factors p))))
                 (union i j))
               (hash-set! prime-factors p (cons i (hash-ref prime-factors p))))))
          ((= (modulo num d) 0)
           (let ((p d))
             (unless (hash-has-key? prime-factors p)
               (hash-set! prime-factors p '()))
             (for ((j (in-list (hash-ref prime-factors p))))
               (union i j))
             (hash-set! prime-factors p (cons i (hash-ref prime-factors p))))
           (loop d (/ num d)))
          (else
           (loop (+ d 1) num))))))

  (define start-root (find 0))
  (for ((i (in-range n)))
    (when (!= (find i) start-root)
      (return #f)))
  #t)