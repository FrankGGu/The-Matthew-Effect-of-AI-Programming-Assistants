(define (number-of-ways n pairs)
  (let* ((adj (make-hash))
         (degree (make-hash))
         (nodes (make-set))
         (root #f))
    (for-each (lambda (p)
                (let ((u (car p)) (v (cdr p)))
                  (hash-update! adj u (lambda (x) (if x (cons v x) (list v))) '())
                  (hash-update! adj v (lambda (x) (if x (cons u x) (list u))) '())
                  (hash-update! degree u (lambda (x) (if x (+ x 1) 1)) 0)
                  (hash-update! degree v (lambda (x) (if x (+ x 1) 1)) 0)
                  (set-add! nodes u)
                  (set-add! nodes v))) pairs)
    (if (empty? nodes) (return 1))
    (set! root (set-first nodes))
    (let loop ((q (list root)) (visited (make-set)) (res 1))
      (if (empty? q)
          (if (= (set-count visited) (set-count nodes))
              res
              0)
          (let* ((u (car q))
                 (q (cdr q))
                 (neighbors (hash-ref adj u '()))
                 (valid #t)
                 (duplicates 0))
            (set-add! visited u)
            (for-each (lambda (v)
                        (if (not (set-member? visited v))
                            (begin
                              (let ((u-neighbors (hash-ref adj u '()))
                                    (v-neighbors (hash-ref adj v '())))
                                (if (not (subset? (set-build v-neighbors) (set-build u-neighbors)))
                                    (set! valid #f)
                                    (if (= (length v-neighbors) (length u-neighbors))
                                        (set! duplicates (+ duplicates 1)))))
                              (if valid
                                  (set! q (append q (list v))))))) neighbors)
            (if (not valid)
                0
                (loop q visited (if (> duplicates 0) 0 res)))))))