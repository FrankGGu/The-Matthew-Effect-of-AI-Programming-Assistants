(define (execute-instructions n s)
  (letrec ((valid? (lambda (x y) (and (>= x 0) (< x n) (>= y 0) (< y n))))
           (execute (lambda (x y instructions)
                      (cond
                        ((null? instructions) 0)
                        (else
                         (let* ((instruction (car instructions))
                                (next-x (cond ((equal? instruction #\R) (+ x 1))
                                                ((equal? instruction #\L) (- x 1))
                                                (else x)))
                                (next-y (cond ((equal? instruction #\D) (+ y 1))
                                                ((equal? instruction #\U) (- y 1))
                                                (else y))))
                           (if (valid? next-x next-y)
                               (+ 1 (execute next-x next-y (cdr instructions)))
                               0)))))))
    (let ((x (car s))
          (y (cadr s))
          (instructions (string->list (caddr s))))
      (for/list ((i (in-range (add1 (length instructions)))))
        (execute x y (drop instructions (- (length instructions) i)))))))