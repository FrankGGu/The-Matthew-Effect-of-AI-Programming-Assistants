(define (max-product-palindromic-subsequences s)
  (define n (string-length s))
  (define (is-palindrome? sub)
    (equal? sub (string-reverse sub)))
  (define (subsequences str)
    (if (string=? str "")
        '((""))
        (let ((first (substring str 0 1))
              (rest (substring str 1)))
          (let ((rest-subs (subsequences rest)))
            (append (map (lambda (sub) (string-append first sub)) rest-subs) rest-subs)))))
  (define subs (subsequences s))
  (define palindromes (filter is-palindrome? subs))
  (define (can-form-disjoint? s1 s2)
    (let loop ((i 0))
      (if (= i n)
          #t
          (let ((c (substring s i (+ i 1))))
            (if (and (string-contains? s1 c) (string-contains? s2 c))
                #f
                (loop (+ i 1)))))))
  (define (string-contains? str char)
    (not (equal? #f (string-index str char))))
  (let loop ((i 0) (max-prod 0))
    (if (= i (length palindromes))
        max-prod
        (let ((s1 (list-ref palindromes i)))
          (let loop2 ((j 0))
            (if (= j (length palindromes))
                (loop (+ i 1) max-prod)
                (let ((s2 (list-ref palindromes j)))
                  (if (can-form-disjoint? s1 s2)
                      (loop2 (+ j 1) (max max-prod (* (string-length s1) (string-length s2))))
                      (loop2 (+ j 1) max-prod)))))))))