(define (count-interesting-subarrays nums modulo k)
  (let* ((n (length nums))
         (prefix-sums (make-vector (+ n 1) 0))
         (count (make-hash))
         (res 0))
    (hash-set! count 0 1)
    (for/fold ((i 1))
              ((num (in-list nums)))
      (vector-set! prefix-sums i (+ (vector-ref prefix-sums (- i 1)) (if (= (modulo num k) 0) 0 1)))
      (+ i 1))
    (for ((i (in-range 1 (+ n 1))))
      (let* ((needed (modulo (- (vector-ref prefix-sums i) k) k)))
        (when (hash-has-key? count needed)
          (set! res (+ res (hash-ref count needed))))
        (let ((curr (vector-ref prefix-sums i)))
          (when (hash-has-key? count curr)
            (hash-update! count curr add1 0))
          (unless (hash-has-key? count curr)
            (hash-set! count curr 1)))))
    res))