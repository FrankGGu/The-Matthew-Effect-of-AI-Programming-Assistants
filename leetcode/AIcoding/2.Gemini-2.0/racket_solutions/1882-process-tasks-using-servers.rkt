(define (processTasks servers tasks)
  (let* ((n (length servers))
         (m (length tasks))
         (available (make-heap < (lambda (a b) (or (< (car a) (car b)) (and (= (car a) (car b)) (< (cdr a) (cdr b)))))))
         (busy (make-heap < (lambda (a b) (< (car a) (car b))))))
    (for/list ((i (in-range n)))
      (heap-add! available (cons 0 i)))
    (let loop ((time 0) (task-idx 0) (result '()))
      (cond
        ((and (= task-idx m) (heap-empty? busy)) (reverse result))
        (else
         (begin
           (when (not (heap-empty? busy))
             (let loop-busy ()
               (if (and (not (heap-empty? busy)) (<= (caar busy) time))
                   (let ((completed (heap-remove-min! busy)))
                     (heap-add! available (cons 0 (cdr completed)))
                     (loop-busy))
                   #t)))
           (when (and (< task-idx m) (not (heap-empty? available)))
             (let loop-tasks ()
               (if (and (< task-idx m) (<= (list-ref tasks task-idx) time) (not (heap-empty? available)))
                   (let ((server-idx (cdr (heap-remove-min! available)))))
                     (heap-add! busy (cons (+ time (list-ref servers server-idx)) server-idx))
                     (set! result (cons server-idx result))
                     (set! task-idx (+ task-idx 1))
                     (loop-tasks))
                   #t)))
           (let ((next-time (cond
                              ((heap-empty? busy) (+ time 1))
                              ((< task-idx m) (min (+ time 1) (caar busy) (if (<= (list-ref tasks task-idx) time) (+ time 1) (list-ref tasks task-idx))))
                              (else (caar busy)))))
             (loop next-time task-idx result))))))))