(define (minimum-cost-path source target special-roads)
  (let* ((graph (make-hash))
         (add-edge (lambda (u v cost)
                     (hash-update! graph u (lambda (old-v) (if old-v (append old-v (list (cons v cost))) (list (cons v cost)))) null)))
         (dist (make-hash))
         (pq (mutable-priority-queue <)))

    (add-edge (list (car source) (cadr source)) (list (car target) (cadr target)) (abs (- (car source) (car target))) (+ (abs (- (cadr source) (cadr target))) 0)))
    (add-edge (list (car target) (cadr target)) (list (car source) (cadr source)) (abs (- (car target) (car source))) (+ (abs (- (cadr target) (cadr source))) 0)))

    (for-each (lambda (road)
                (let ((x1 (list (car road) (cadr road)))
                      (y1 (list (car target) (cadr target)))
                      (x2 (list (car source) (cadr source)))
                      (x3 (list (car (cddr road)) (cadr (cddr road)))))
                  (add-edge x1 x3 (caddr (cddr road)))
                  (add-edge x3 x1 (caddr (cddr road)))
                  (add-edge x1 y1 (abs (- (car road) (car target))) (+ (abs (- (cadr road) (cadr target))) 0)))
                (let ((x1 (list (car (cddr road)) (cadr (cddr road))))
                      (y1 (list (car target) (cadr target))))
                  (add-edge x1 y1 (abs (- (car (cddr road)) (car target))) (+ (abs (- (cadr (cddr road)) (cadr target))) 0))))) special-roads)

    (hash-set! dist (list (car source) (cadr source)) 0)
    (mutable-priority-queue-add! pq (cons 0 (list (car source) (cadr source))))

    (let loop ()
      (if (mutable-priority-queue-empty? pq)
          (hash-ref dist (list (car target) (cadr target)))
          (let* ((curr (mutable-priority-queue-remove! pq))
                 (d (car curr))
                 (u (cdr curr)))
            (if (> d (hash-ref dist u #f))
                (loop)
                (let ((neighbors (hash-ref graph u '())))
                  (for-each (lambda (neighbor)
                              (let* ((v (car neighbor))
                                     (weight (cdr neighbor))
                                     (new-dist (+ d weight)))
                                (if (or (not (hash-has-key? dist v))
                                        (< new-dist (hash-ref dist v)))
                                    (begin
                                      (hash-set! dist v new-dist)
                                      (mutable-priority-queue-add! pq (cons new-dist v)))))) neighbors))
                  (loop)))))))