(define (maximum-path-quality values edges max-time)
  (let* ((n (length values))
         (adj (make-vector n '()))
         (visited (make-vector n #f))
         (max-quality (box 0)))
    (for-each (lambda (edge)
                (let ((u (car edge))
                      (v (cadr edge))
                      (time (caddr edge)))
                  (vector-set! adj u (cons (cons v time) (vector-ref adj u)))
                  (vector-set! adj v (cons (cons u time) (vector-ref adj v)))))
              edges)
    (letrec ((dfs (lambda (node current-time current-quality)
                     (cond
                       ((= node 0)
                        (box-set! max-quality (max (unbox max-quality) current-quality)))
                       (else #f))
                     (vector-set! visited node #t)
                     (for-each (lambda (neighbor)
                                 (let ((next-node (car neighbor))
                                       (time (cdr neighbor)))
                                   (when (>= current-time time)
                                     (dfs next-node (- current-time time)
                                          (if (not (vector-ref visited next-node))
                                              (+ current-quality (vector-ref values next-node))
                                              current-quality)))))
                               (vector-ref adj node))
                     (vector-set! visited node #f))))
      (dfs 0 max-time (vector-ref values 0))
      (unbox max-quality))))