(define (find-closest-people friends interests person1 person2)
  (let* ((n (vector-length friends))
         (adj-matrix (make-vector n #f)))
    (for ([i (in-range n)])
      (set! (vector-ref adj-matrix i) (make-vector n 0)))
    (for ([i (in-range n)])
      (for ([j (in-range (vector-length (vector-ref friends i)))])
        (let ([friend (vector-ref (vector-ref friends i) j)])
          (set! (vector-ref (vector-ref adj-matrix i) friend) 1))))
    (let ([interest-matrix (make-vector n #f)])
      (for ([i (in-range n)])
        (set! (vector-ref interest-matrix i) (make-vector n 0)))
      (for ([i (in-range n)])
        (for ([j (in-range n)])
          (if (equal? i j)
              (set! (vector-ref (vector-ref interest-matrix i) j) 0)
              (let ([common-interests 0])
                (for ([interest (in-vector (vector-ref interests i))])
                  (if (member interest (vector->list (vector-ref interests j)))
                      (set! common-interests (+ common-interests 1))))
                (set! (vector-ref (vector-ref interest-matrix i) j) common-interests)))))
      (let loop ([q (list (list person1 0))]; queue of (node, distance)
                 [visited (make-vector n #f)]
                 [closest '()])
        (if (null? q)
            (if (null? closest)
                '()
                (let* ([max-common (apply max (map car closest))]
                       (filtered-closest (filter (lambda (x) (= (car x) max-common)) closest))
                       (result (map cadr filtered-closest)))
                  (sort result <)))
            (let* ([curr (car q)]
                   [node (car curr)]
                   [dist (cadr curr)])
              (if (vector-ref visited node)
                  (loop (cdr q) visited closest)
                  (begin
                    (vector-set! visited node #t)
                    (let ([new-closest closest])
                      (if (= (vector-ref (vector-ref adj-matrix node) person2) 1)
                          (set! new-closest (cons (list (vector-ref (vector-ref interest-matrix node) person2) node) new-closest))))
                    (let ([neighbors '()])
                      (for ([i (in-range n)])
                        (if (and (= (vector-ref (vector-ref adj-matrix node) i) 1) (not (= i person1)))
                            (set! neighbors (cons i neighbors))))
                      (let ([new-q (append (cdr q) (map (lambda (neighbor) (list neighbor (+ dist 1))) neighbors))])
                        (loop new-q visited new-closest)))))))))))