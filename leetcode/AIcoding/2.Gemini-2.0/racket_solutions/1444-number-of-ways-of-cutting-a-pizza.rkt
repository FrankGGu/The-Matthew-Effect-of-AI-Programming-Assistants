(define (ways pizza k)
  (let* ((m (vector-length pizza))
         (n (vector-length (vector-ref pizza 0)))
         (apples (make-vector (add1 m) (make-vector (add1 n) 0))))

    (for* ((i (range (sub1 m) -1 -1))
           (j (range (sub1 n) -1 -1)))
      (let ((count 0))
        (for ((r (range i m)))
          (for ((c (range j n)))
            (when (char=? (vector-ref (vector-ref pizza r) c) #\A)
              (set! count (add1 count)))))
        (vector-set! (vector-ref apples i) j count)))

    (define (has-apple? r c i j)
      (> (- (vector-ref (vector-ref apples r) c)
            (vector-ref (vector-ref apples i) j))
         0))

    (define (solve r c cuts memo)
      (cond
        ((= cuts 0)
         (if (has-apple? r c m n) 1 0))
        ((>= (+ r 1) m) 0)
        ((>= (+ c 1) n) 0)
        (else
         (let ((key (list r c cuts)))
           (if (hash-has-key? memo key)
               (hash-ref memo key)
               (let ((result 0))
                 (for ((i (range (+ r 1) m)))
                   (when (and (has-apple? r c i n)
                              (has-apple? i n m n))
                     (set! result (modulo (+ result (solve i c (sub1 cuts) memo)) 1000000007))))
                 (for ((j (range (+ c 1) n)))
                   (when (and (has-apple? r c m j)
                              (has-apple? m j m n))
                     (set! result (modulo (+ result (solve r j (sub1 cuts) memo)) 1000000007))))
                 (hash-set! memo key result)
                 result))))))

    (solve 0 0 (sub1 k) (make-hash))))