(define (minimum-obstacle-removal grid)
  (define m (vector-length grid))
  (define n (vector-length (vector-ref grid 0)))
  (define dist (make-vector m (lambda (i) (make-vector n (lambda (j) +inf.0)))))
  (vector-set! dist 0 (make-vector n 0))
  (vector-set! (vector-ref dist 0) 0 0)

  (define q (make-queue))
  (enqueue! q (cons 0 0))

  (define (valid? r c)
    (and (>= r 0) (< r m) (>= c 0) (< c n)))

  (define (neighbors r c)
    (filter (lambda (p) (valid? (car p) (cdr p)))
            (list (cons (+ r 1) c) (cons (- r 1) c) (cons r (+ c 1)) (cons r (- c 1)))))

  (let loop ()
    (if (queue-empty? q)
        (vector-ref (vector-ref dist (- m 1)) (- n 1))
        (let* ((curr (dequeue! q))
               (r (car curr))
               (c (cdr curr)))
          (for-each
           (lambda (neighbor)
             (let* ((nr (car neighbor))
                    (nc (cdr neighbor))
                    (weight (vector-ref (vector-ref grid nr) nc))
                    (new-dist (+ (vector-ref (vector-ref dist r) c) weight)))
               (when (< new-dist (vector-ref (vector-ref dist nr) nc))
                 (vector-set! (vector-ref dist nr) nc new-dist)
                 (if (= weight 0)
                     (enqueue! q (cons nr nc))
                     (enqueue! q (cons nr nc))))))
           (neighbors r c))
          (loop))))
  )