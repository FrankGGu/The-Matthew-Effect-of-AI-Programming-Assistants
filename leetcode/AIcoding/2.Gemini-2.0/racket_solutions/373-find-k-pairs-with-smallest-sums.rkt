(define (kth-smallest-pairs nums1 nums2 k)
  (define n1 (length nums1))
  (define n2 (length nums2))
  (if (or (zero? n1) (zero? n2))
      '()
      (let* (
             (heap (make-heap (lambda (p1 p2) (< (car p1) (car p2))) #:key (lambda (p) (+ (list-ref nums1 (cdr p)) (list-ref nums2 (cddr p))))))
             (visited (make-hash))
             (result '()))
        (heap-add! heap (list (+ (car nums1) (car nums2)) 0 0))
        (hash-set! visited (cons 0 0) #t)
        (for ([i (in-range (min k (* n1 n2)))])
          (let* ((curr (heap-remove-min! heap))
                 (idx1 (cdr curr))
                 (idx2 (cddr curr)))
            (set! result (append result (list (list (list-ref nums1 idx1) (list-ref nums2 idx2)))))
            (when (< idx1 (- n1 1))
              (let ((next-pair (cons (+ 1 idx1) idx2)))
                (unless (hash-has-key? visited next-pair)
                  (heap-add! heap (list (+ (list-ref nums1 (+ 1 idx1)) (list-ref nums2 idx2)) (+ 1 idx1) idx2))
                  (hash-set! visited next-pair #t)))))
            (when (< idx2 (- n2 1))
              (let ((next-pair (cons idx1 (+ 1 idx2))))
                (unless (hash-has-key? visited next-pair)
                  (heap-add! heap (list (+ (list-ref nums1 idx1) (list-ref nums2 (+ 1 idx2))) idx1 (+ 1 idx2)) )
                  (hash-set! visited next-pair #t))))))
        result)))