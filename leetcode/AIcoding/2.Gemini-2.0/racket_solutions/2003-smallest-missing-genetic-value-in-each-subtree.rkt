(define (smallestMissingValueSubtree parents nums)
  (define n (vector-length nums))
  (define adj (make-vector n '()))
  (for/list ((i (in-range 1 n)))
    (vector-set! adj (vector-ref parents i) (cons i (vector-ref adj (vector-ref parents i)))))

  (define (find-node val)
    (for/first ((i (in-range n))
                #:when (= (vector-ref nums i) val))
      i))

  (define (subtree-nodes node)
    (define visited (make-vector n #f))
    (define nodes '())
    (define (dfs u)
      (vector-set! visited u #t)
      (set! nodes (cons u nodes))
      (for ((v (in-list (vector-ref adj u))))
        (unless (vector-ref visited v)
          (dfs v))))
    (dfs node)
    nodes)

  (define (smallest-missing subtree-nodes-list)
    (define subtree-values (make-hash))
    (for ((node (in-list subtree-nodes-list)))
      (hash-set! subtree-values (vector-ref nums node) #t))
    (let loop ((i 1))
      (if (hash-has-key? subtree-values i)
          (loop (+ i 1))
          i)))

  (define target-node (find-node 1))
  (if (not target-node)
      (make-vector n 1)
      (let loop ((node target-node) (res (make-vector n 1)) (missing 2))
        (let ((subtree-nodes-list (subtree-nodes node)))
          (let ((smv (smallest-missing subtree-nodes-list)))
            (vector-set! res node smv)
            (if (= (vector-ref parents node) -1)
                res
                (loop (vector-ref parents node) res (max missing (+ smv 1)))))))))