(define (maximum-profit edges cost)
  (let* ((n (length cost))
         (indegree (make-vector n 0))
         (graph (make-vector n '()))
         (result (make-vector n #f)))
    (for-each (lambda (edge)
                (let ((u (car edge))
                      (v (cdr edge)))
                  (vector-set! graph u (cons v (vector-ref graph u)))
                  (vector-set! indegree v (+ (vector-ref indegree v) 1))))
              edges)
    (let loop ((queue (list))
               (total-profit 0))
      (if (null? queue)
          (begin
            (for/or ((i (in-range n))
                     #:when (not (equal? (vector-ref result i) #f)))
              #f)
            (if (for/or ((i (in-range n))
                         #:when (not (equal? (vector-ref result i) #f)))
                total-profit
                -1))
          )
          (let ((u (car queue))
                (rest-queue (cdr queue)))
            (vector-set! result u (max (vector-ref result u #f) 0))
            (let loop2 ((neighbors (vector-ref graph u)))
              (if (null? neighbors)
                  (loop rest-queue (+ total-profit (vector-ref result u)))
                  (let ((v (car neighbors))
                        (rest-neighbors (cdr neighbors)))
                    (vector-set! indegree v (- (vector-ref indegree v) 1))
                    (vector-set! result v (max (vector-ref result v #f) (+ (vector-ref result u) (vector-ref cost v))))
                    (if (zero? (vector-ref indegree v))
                        (loop2 rest-neighbors)
                        (loop2 rest-neighbors)))))
            )))
    (let ((q (list)))
      (for ((i (in-range n)))
        (if (zero? (vector-ref indegree i))
            (set! q (cons i q))))
      (loop q 0))))