(define (kth-score-after-rotation nums k)
  (let* ((n (length nums))
         (rotated-nums (append (drop nums k) (take nums k))))
    (foldl + 0 (map (lambda (i num) (if (<= num i) 1 0)) (range n) rotated-nums))))

(define (smallest-rotation-with-highest-score nums)
  (let* ((n (length nums))
         (scores (make-vector n 0)))
    (for/list ((i (in-range n)))
      (let* ((diff (- (vector-ref nums i) i))
             (k (if (< diff 0) (+ n diff) diff)))
        (vector-set! scores k (+ (vector-ref scores k) 1))
        (vector-set! scores 0 (- (vector-ref scores 0) 1))
        (if (< k (sub1 n))
            (vector-set! scores (add1 k) (+ (vector-ref scores (add1 k)) -1))
            #t)))
    (let loop ((i 1) (max-score (vector-ref scores 0)) (result 0) (current-score (vector-ref scores 0)))
      (if (= i n)
          result
          (let ((new-score (+ current-score (vector-ref scores i))))
            (if (> new-score max-score)
                (loop (add1 i) new-score i new-score)
                (loop (add1 i) max-score result new-score)))))))