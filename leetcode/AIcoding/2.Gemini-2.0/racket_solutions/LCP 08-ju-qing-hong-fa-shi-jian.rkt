(define (get-trigger-time &key increase requirements)
  (let* ((n (length increase))
         (m (length requirements))
         (results (make-vector m -1)))
    (for ([i (in-range m)])
      (let* ((req (list-ref requirements i))
             (c (list-ref req 0))
             (r (list-ref req 1))
             (a (list-ref req 2))
             (cc 0)
             (rr 0)
             (aa 0))
        (for ([j (in-range n)])
          (let ((inc (list-ref increase j)))
            (set! cc (+ cc (list-ref inc 0)))
            (set! rr (+ rr (list-ref inc 1)))
            (set! aa (+ aa (list-ref inc 2)))
            (when (and (>= cc c) (>= rr r) (>= aa a) (= (vector-ref results i) -1))
              (vector-set! results i (+ j 1))))))
      (when (and (>= (list-ref (list-ref increase (- n 1)) 0) c)
                 (>= (list-ref (list-ref increase (- n 1)) 1) r)
                 (>= (list-ref (list-ref increase (- n 1)) 2) a)
                 (= (vector-ref results i) -1))
        (let* ((cc (apply + (map (Î» (x) (list-ref x 0)) increase)))
               (rr (apply + (map (Î» (x) (list-ref x 1)) increase)))
               (aa (apply + (map (Î» (x) (list-ref x 2)) increase))))
          (when (and (>= cc c) (>= rr r) (>= aa a) (= (vector-ref results i) -1))
            (vector-set! results i n)))))
    (vector->list results)))