(define (min-cost grid)
  (define m (vector-length grid))
  (define n (vector-length (vector-ref grid 0)))
  (define dist (make-vector m (lambda (i) (make-vector n (lambda (j) +inf.0)))))
  (define (valid? r c) (and (>= r 0) (< r m) (>= c 0) (< c n)))
  (define (neighbors r c)
    (define v (vector-ref (vector-ref grid r) c))
    (define dirs (list (cons 0 1) (cons 0 -1) (cons 1 0) (cons -1 0)))
    (define costs (list (if (= v 1) 0 1) (if (= v 2) 0 1) (if (= v 3) 0 1) (if (= v 4) 0 1)))
    (map (lambda (dir cost)
           (define nr (+ r (car dir)))
           (define nc (+ c (cdr dir)))
           (if (valid? nr nc)
               (list nr nc cost)
               #f))
         dirs
         costs))
  (define pq (make-heap (lambda (a b) (< (caddr a) (caddr b)))))
  (vector-set! (vector-ref dist 0) 0 0)
  (heap-add! pq (list 0 0 0))
  (let loop ()
    (if (heap-empty? pq)
        (vector-ref (vector-ref dist (- m 1)) (- n 1))
        (let ((curr (heap-remove-min! pq)))
          (define r (car curr))
          (define c (cadr curr))
          (define cost (caddr curr))
          (if (> cost (vector-ref (vector-ref dist r) c))
              (loop)
              (for-each
               (lambda (neighbor)
                 (if neighbor
                     (let ((nr (car neighbor))
                           (nc (cadr neighbor))
                           (new-cost (+ cost (caddr neighbor))))
                       (if (< new-cost (vector-ref (vector-ref dist nr) nc))
                           (begin
                             (vector-set! (vector-ref dist nr) nc new-cost)
                             (heap-add! pq (list nr nc new-cost)))))))
               (filter identity (neighbors r c)))
          (loop)))))