(define (smallest-lexicographical-string s a b)
  (define n (string-length s))
  (define visited (make-hash))
  (define (bfs start)
    (define q (queue))
    (queue-enqueue! q start)
    (hash-set! visited start #t)
    (define (add-to-queue str)
      (unless (hash-has-key? visited str)
        (queue-enqueue! q str)
        (hash-set! visited str #t)))
    (let loop ()
      (if (queue-empty? q)
          (void)
          (let* ((curr (queue-dequeue! q))
                 (add-op (list->string (map (lambda (i) (integer->char (+ (char->integer (string-ref curr i)) a) 48)) (range 1 n 2))))
                 (added-str (string-copy curr))
                 (shifted-str (string-append (substring curr (- n b)) (substring curr 0 (- n b))))
                 (add-result (string-copy curr))
                 )
            (for ([i (in-range 1 n 2)])
              (string-set! add-result i (integer->char (modulo (+ (- (char->integer (string-ref curr i)) 48) a) 10) 48)))
            (add-to-queue add-result)
            (add-to-queue shifted-str)
            (loop)))))
  (bfs s)
  (let loop ([min-str s]
             [keys (hash-keys visited)])
    (if (null? keys)
        min-str
        (let ([curr (car keys)])
          (loop (min min-str curr string<?) (cdr keys))))))