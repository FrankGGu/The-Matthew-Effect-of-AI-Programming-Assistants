(define (min-cost-to-equalize-paths costs)
  (define (dfs node)
    (if (not (hash-has-key? costs node))
        0
        (let ((left (dfs (* 2 node)))
              (right (dfs (+ 1 (* 2 node)))))
          (+ (hash-ref costs node) (max left right) ))))

  (define (solve)
    (let ((n (hash-count costs)))
      (let ((total-sum (dfs 1)))
        (let ((max-path-sum total-sum))
          (let ((ans 0))
            (for/list ((i (in-range n 1 -1)))
              (let ((left (* 2 i))
                    (right (+ 1 (* 2 i))))
                (if (and (hash-has-key? costs left) (hash-has-key? costs right))
                    (let ((left-val (if (hash-has-key? costs left) (hash-ref costs left) 0))
                          (right-val (if (hash-has-key? costs right) (hash-ref costs right) 0)))
                      (set! ans (+ ans (abs (- left-val right-val))))
                      (hash-set! costs i (+ (hash-ref costs i) (max left-val right-val))))
                    (if (hash-has-key? costs left)
                        (hash-set! costs i (+ (hash-ref costs i) (hash-ref costs left)))
                        (if (hash-has-key? costs right)
                            (hash-set! costs i (+ (hash-ref costs i) (hash-ref costs right)))
                            #t)))))
            ans))))))

  (solve))