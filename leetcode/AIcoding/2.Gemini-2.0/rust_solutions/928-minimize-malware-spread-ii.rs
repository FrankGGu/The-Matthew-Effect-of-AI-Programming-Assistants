use std::collections::HashSet;

impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        let n = graph.len();
        let initial_set: HashSet<i32> = initial.iter().cloned().collect();
        let mut best_node = -1;
        let mut max_saved = -1;

        for &node in &initial {
            let mut visited: HashSet<i32> = HashSet::new();
            let mut saved = 0;

            for i in 0..n {
                if initial_set.contains(&(i as i32)) || visited.contains(&(i as i32)) {
                    continue;
                }

                let mut queue = vec![i as i32];
                visited.insert(i as i32);
                let mut infected_by = vec![];
                let mut current_group = vec![i as i32];

                while let Some(curr) = queue.pop() {
                    for neighbor in 0..n {
                        if graph[curr as usize][neighbor] == 1 && !visited.contains(&(neighbor as i32)) {
                            if initial_set.contains(&(neighbor as i32)) {
                                infected_by.push(neighbor as i32);
                            } else {
                                queue.push(neighbor as i32);
                                visited.insert(neighbor as i32);
                                current_group.push(neighbor as i32);
                            }
                        }
                    }
                }

                if infected_by.len() == 1 && infected_by[0] == node {
                    saved += current_group.len();
                }
            }

            if saved > max_saved {
                max_saved = saved;
                best_node = node;
            } else if saved == max_saved && node < best_node {
                best_node = node;
            }
        }

        if best_node == -1 {
            let mut min_node = i32::MAX;
            for &node in &initial {
                min_node = min_node.min(node);
            }
            min_node
        } else {
            best_node
        }
    }
}