(define (outer-trees trees)
  (define (cross o a b)
    (let ((ax (- (car a) (car o)))
          (ay (- (cadr a) (cadr o)))
          (bx (- (car b) (car o)))
          (by (- (cadr b) (cadr o))))
      (- (* ax by) (* ay bx))))

  (if (< (length trees) 4)
      trees
      (let* ((sorted (sort trees (lambda (a b) (or (< (car a) (car b)) (and (= (car a) (car b)) (< (cadr a) (cadr b))))))
            (lower '())
            (upper '()))
        (for ([p sorted])
          (while (and (>= (length lower) 2) (> (cross (list-ref lower (- (length lower) 2)) (last lower) p) 0))
            (set! lower (drop-right lower 1)))
          (set! lower (append lower (list p))))
        (for ([p (reverse sorted)])
          (while (and (>= (length upper) 2) (> (cross (list-ref upper (- (length upper) 2)) (last upper) p) 0))
            (set! upper (drop-right upper 1)))
          (set! upper (append upper (list p))))
        (remove-duplicates (append (drop-right lower 1) (drop-right upper 1))))))