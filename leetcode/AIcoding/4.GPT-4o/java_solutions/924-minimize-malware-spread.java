import java.util.*;

public class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        boolean[] infected = new boolean[n];
        for (int node : initial) {
            infected[node] = true;
        }

        int[] component = new int[n];
        int[] size = new int[n];
        int compIndex = 0;

        for (int i = 0; i < n; i++) {
            if (component[i] == 0) {
                compIndex++;
                dfs(graph, i, component, compIndex);
                size[compIndex - 1] = countSize(graph, component, compIndex);
            }
        }

        int[] infectedCount = new int[compIndex];
        for (int node : initial) {
            infectedCount[component[node] - 1]++;
        }

        int result = Integer.MAX_VALUE;
        for (int node : initial) {
            int compId = component[node] - 1;
            if (infectedCount[compId] == 1) {
                if (result == Integer.MAX_VALUE || 
                    size[result] < size[compId] || 
                    (size[result] == size[compId] && result > node)) {
                    result = node;
                }
            }
        }

        return result == Integer.MAX_VALUE ? Collections.min(Arrays.asList(initial)) : result;
    }

    private void dfs(int[][] graph, int node, int[] component, int index) {
        component[node] = index;
        for (int neighbor = 0; neighbor < graph.length; neighbor++) {
            if (graph[node][neighbor] == 1 && component[neighbor] == 0) {
                dfs(graph, neighbor, component, index);
            }
        }
    }

    private int countSize(int[][] graph, int[] component, int compIndex) {
        int count = 0;
        for (int i = 0; i < component.length; i++) {
            if (component[i] == compIndex) {
                count++;
            }
        }
        return count;
    }
}