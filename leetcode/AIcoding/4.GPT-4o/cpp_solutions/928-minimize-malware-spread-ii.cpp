class Solution {
public:
    int minimizeMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        sort(initial.begin(), initial.end());

        vector<bool> isInfected(n, false);
        for (int node : initial) {
            isInfected[node] = true;
        }

        vector<int> parent(n, -1);
        vector<int> componentSize(n, 0);

        function<int(int)> find = [&](int x) {
            if (parent[x] == -1) return x;
            return parent[x] = find(parent[x]);
        };

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (graph[i][j] == 1) {
                    int rootI = find(i);
                    int rootJ = find(j);
                    if (rootI != rootJ) {
                        parent[rootJ] = rootI;
                    }
                }
            }
        }

        unordered_map<int, int> componentMalwareCount;
        unordered_map<int, int> componentSizeCount;

        for (int node : initial) {
            int root = find(node);
            componentMalwareCount[root]++;
        }

        for (int i = 0; i < n; ++i) {
            int root = find(i);
            componentSizeCount[root]++;
        }

        int minNode = INT_MAX;
        int maxSize = 0;

        for (int node : initial) {
            int root = find(node);
            if (componentMalwareCount[root] == 1) {
                if (componentSizeCount[root] > maxSize || 
                    (componentSizeCount[root] == maxSize && node < minNode)) {
                    maxSize = componentSizeCount[root];
                    minNode = node;
                }
            }
        }

        return minNode == INT_MAX ? *min_element(initial.begin(), initial.end()) : minNode;
    }
};