#lang racket

(define (updateMatrix mat)
  (define rows (length mat))
  (define cols (length (first mat)))
  (define (in-bounds? r c) (and (>= r 0) (< r rows) (>= c 0) (< c cols)))
  (define directions '((1 0) (-1 0) (0 1) (0 -1)))
  (define queue (make-queue))
  (define distance (for/list ([r (in-range rows)] [c (in-range cols)])
                     (if (= (list-ref (list-ref mat r) c) 0)
                         0
                         +inf.0)))
  (for* ([r (in-range rows)] [c (in-range cols)])
    (when (= (list-ref (list-ref mat r) c) 0)
      (enqueue queue (list r c))))
  (while (not (empty? queue))
    (define pos (dequeue queue))
    (define r (first pos))
    (define c (second pos))
    (for ([dir directions])
      (define new-r (+ r (first dir)))
      (define new-c (+ c (second dir)))
      (when (and (in-bounds? new-r new-c)
                 (= (list-ref (list-ref mat new-r) new-c) 1)
                 (> (+ 1 (list-ref distance r c)) (list-ref distance new-r new-c)))
        (set! (list-ref distance new-r new-c) (+ 1 (list-ref distance r c)))
        (enqueue queue (list new-r new-c)))))
  distance)

(define (make-queue)
  (let ([q '()])
    (define (enqueue item)
      (set! q (append q (list item))))
    (define (dequeue)
      (let ([item (first q)])
        (set! q (rest q))
        item))
    (define (empty?)
      (null? q))
    (values enqueue dequeue empty?)))

(define (main)
  (define mat '((0 0 0) (0 1 0) (1 1 1)))
  (updateMatrix mat))

(main)