(define (paths-with-max-score board)
  (define n (length board))
  (define m (length (car board)))
  (define dp (make-vector n (make-vector m 0)))
  (define count (make-vector n (make-vector m 0)))

  (for ([i (in-range n)])
    (for ([j (in-range m)])
      (vector-set! (vector-ref dp i) j (if (char=? (vector-ref (vector-ref board i) j) #\X) -1 0))
      (vector-set! (vector-ref count i) j (if (char=? (vector-ref (vector-ref board i) j) #\X) 0 0))))

  (for ([i (in-range (- n 1) -1 -1)])
    (for ([j (in-range (- m 1) -1 -1)])
      (when (not (char=? (vector-ref (vector-ref board i) j) #\X))
        (define max-score -1)
        (define paths 0)
        (for ([di (list 1 0)] [dj (list 0 1)])
          (define ni (+ i di))
          (define nj (+ j dj))
          (when (and (< ni n) (< nj m))
            (let ([current-score (vector-ref dp ni nj)]
                  [current-paths (vector-ref count ni nj)])
              (when (> current-score max-score)
                (set! max-score current-score)
                (set! paths current-paths)
                (set! paths (if (> current-paths 0) paths 0))
                (when (zero? current-paths)
                  (set! paths 1))))))
        (when (not (= max-score -1))
          (vector-set! (vector-ref dp i) j (+ (vector-ref (vector-ref dp i) j) max-score))
          (vector-set! (vector-ref count i) j paths))))

  (if (= (vector-ref (vector-ref dp 0) 0) -1)
      (list 0 0)
      (list (vector-ref (vector-ref dp 0) 0) (vector-ref (vector-ref count 0) 0))))

(paths-with-max-score (vector (vector #\E #\0 #\0 #\0) (vector #\0 #\X #\0 #\0) (vector #\0 #\0 #\0 #\0) (vector #\0 #\0 #\0 #\X)))