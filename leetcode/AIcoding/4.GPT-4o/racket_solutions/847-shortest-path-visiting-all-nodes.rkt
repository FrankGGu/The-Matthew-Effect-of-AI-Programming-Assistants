(define (shortest-path-visiting-all-nodes graph)
  (define (bfs)
    (define q (list (list 0 1))) ; (node, visited_mask)
    (define visited (make-vector (expt 2 (length graph)) #f))
    (vector-set! visited 1 0)
    (define steps 0)
    (define num-nodes (length graph))
    (let loop ()
      (if (null? q)
          -1
          (let* ((size (length q))
                 (next-q '()))
            (for-each (lambda (i)
                          (let* ((node (car (car i)))
                                 (mask (cadr (car i))))
                            (for-each (lambda (neighbor)
                                          (let* ((new-mask (bitwise-ior mask (expt 2 neighbor)))
                                                 (key (if (= new-mask (sub1 (expt 2 num-nodes))) 
                                                          -1 
                                                          new-mask)))
                                            (when (and (not (vector-ref visited new-mask))
                                                       (not (= key -1)))
                                              (vector-set! visited new-mask steps)
                                              (set! next-q (cons (list neighbor new-mask) next-q))))))
                                        (list-ref graph node))))
            (set! q (reverse next-q))
            (set! steps (+ steps 1))
            (loop)))))
  (bfs))