(define (flipChess board)
  (define directions '((1 0) (-1 0) (0 1) (0 -1) (1 1) (1 -1) (-1 1) (-1 -1)))
  (define (is-valid? x y)
    (and (>= x 0) (< x 3) (>= y 0) (< y 3)))
  (define (can-flip? x y dx dy)
    (define nx (+ x dx))
    (define ny (+ y dy))
    (and (is-valid? nx ny) (equal? (list-ref (list-ref board nx) ny) "W")))
    (let loop ((nx (+ x dx)) (ny (+ y dy)))
      (cond
        ((not (is-valid? nx ny)) #f)
        ((equal? (list-ref (list-ref board nx) ny) "E") #f)
        ((equal? (list-ref (list-ref board nx) ny) "B") #t)
        (else (loop (+ nx dx) (+ ny dy))))))
  (define (count-flips x y)
    (define count 0)
    (for ([dx (map car directions)]
          [dy (map cadr directions)])
      (when (can-flip? x y dx dy)
        (set! count (+ count 1))))
    count)
  (define max-flips 0)
  (for ([i (in-range 3)]
        [j (in-range 3)])
    (when (equal? (list-ref (list-ref board i) j) "E")
      (set! max-flips (max max-flips (count-flips i j)))))
  max-flips)

(flipChess '(("E" "E" "E") ("E" "B" "E") ("E" "E" "E")))