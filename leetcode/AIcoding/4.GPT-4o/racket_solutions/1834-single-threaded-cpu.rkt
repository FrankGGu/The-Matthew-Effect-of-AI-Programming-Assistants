(define (getOrder tasks)
  (define n (length tasks))
  (define indexed-tasks (map (lambda (i) (list (car (list-ref tasks i)) (cdr (list-ref tasks i)) i)) (range n)))
  (define sorted-tasks (sort indexed-tasks (lambda (a b) (if (= (car a) (car b)) (< (cadr a) (cadr b)) (< (car a) (car b))))))
  (define result '())
  (define current-time 0)
  (define task-index 0)
  (define waiting-tasks '())

  (let loop ()
    (when (< task-index n)
      (let* ((current-task (list-ref sorted-tasks task-index))
             (arrival-time (car current-task))
             (process-time (cadr current-task))
             (original-index (caddr current-task)))
        (when (<= current-time arrival-time)
          (set! current-time arrival-time))
        (set! current-time (+ current-time process-time))
        (set! result (append result (list original-index)))
        (set! task-index (+ task-index 1))
        (loop)))

    (for ((i task-index) (length sorted-tasks))
      (when (< i n)
        (let* ((current-task (list-ref sorted-tasks i))
               (arrival-time (car current-task))
               (process-time (cadr current-task))
               (original-index (caddr current-task)))
          (when (<= current-time arrival-time)
            (set! current-time arrival-time))
          (set! current-time (+ current-time process-time))
          (set! result (append result (list original-index))))))

    result))

(getOrder '((1 2) (2 4) (3 2) (4 1) (5 3)))