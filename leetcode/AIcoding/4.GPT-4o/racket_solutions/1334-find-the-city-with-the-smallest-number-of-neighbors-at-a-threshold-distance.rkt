(define (find-the-city n edges distance-threshold)
  (define graph (make-vector n '()))
  (for-each
   (lambda (edge)
     (let ((u (car edge))
           (v (cadr edge))
           (wt (caddr edge)))
       (vector-set! graph u (cons (list v wt) (vector-ref graph u)))
       (vector-set! graph v (cons (list u wt) (vector-ref graph v)))))
   edges)

  (define (dijkstra start)
    (define distances (make-vector n +inf.0))
    (define visited (make-vector n #f))
    (vector-set! distances start 0)
    (define pq (make-pq))
    (pq-insert! pq (list start 0))

    (let loop ()
      (if (pq-empty? pq)
          distances
          (let* ((current (pq-extract-min! pq))
                 (u (car current))
                 (d (cadr current)))
            (unless (vector-ref visited u)
              (vector-set! visited u #t)
              (for-each
               (lambda (neighbor)
                 (let* ((v (car neighbor))
                        (weight (cadr neighbor))
                        (alt (+ d weight)))
                   (when (< alt (vector-ref distances v))
                     (vector-set! distances v alt)
                     (pq-insert! pq (list v alt)))))
               (vector-ref graph u)))
            (loop)))))

  (define min-neighbors +inf.0)
  (define city-index -1)

  (for ([i (in-range n)])
    (define distances (dijkstra i))
    (define count (foldl (lambda (acc d)
                            (if (and (< d distance-threshold) (not (= d +inf.0)))
                                (+ acc 1)
                                acc))
                          0
                          distances))
    (when (< count min-neighbors)
      (set! min-neighbors count)
      (set! city-index i))
    (when (= count min-neighbors)
      (set! city-index (min city-index i))))

  city-index)