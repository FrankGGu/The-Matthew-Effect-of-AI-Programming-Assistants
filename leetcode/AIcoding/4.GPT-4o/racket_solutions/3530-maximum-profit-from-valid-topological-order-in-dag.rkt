(define (maximumProfit edges profit)
  (define n (length profit))
  (define adj (make-vector n '()))
  (for-each (lambda (e)
              (let ((u (car e))
                    (v (cadr e)))
                (vector-set! adj u (cons v (vector-ref adj u)))))
            edges)
  (define in-degrees (make-vector n 0))
  (for-each (lambda (e)
              (let ((v (cadr e)))
                (vector-set! in-degrees v (+ 1 (vector-ref in-degrees v)))))
            edges)
  (define queue (make-vector 0))
  (for ((i (in-range n)))
    (when (= (vector-ref in-degrees i) 0)
      (vector-set! queue (vector-length queue) i)))
  (define dp (make-vector n 0))
  (for ((i (in-range n)))
    (vector-set! dp i (vector-ref profit i)))
  (define (bfs)
    (while (> (vector-length queue) 0)
      (define u (vector-ref queue 0))
      (set! queue (vector-tail queue 1))
      (for-each (lambda (v)
                  (set! dp (vector-set! dp v (max (vector-ref dp v) (+ (vector-ref dp u) (vector-ref profit v)))))
                  (vector-set! in-degrees v (- (vector-ref in-degrees v) 1))
                  (when (= (vector-ref in-degrees v) 0)
                    (vector-set! queue (vector-length queue) v)))
                (vector-ref adj u))))
  (bfs)
  (apply max (vector->list dp)))

(maximumProfit '((0 1) (0 2) (1 3) (2 3)) '(10 5 8 20))