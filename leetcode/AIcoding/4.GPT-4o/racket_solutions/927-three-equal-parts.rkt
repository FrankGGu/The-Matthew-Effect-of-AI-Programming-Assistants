(define (three-equal-parts A)
  (define n (length A))
  (define ones (foldl (lambda (x acc) (+ (if (= x 1) 1 0) acc)) 0 A))
  (if (zero? ones)
      (list 0 (- n 1) n)
      (if (not (= (modulo ones 3) 0))
          '( -1 -1)
          (let* ((target (/ ones 3))
                 (first (find-start A target))
                 (second (find-start A (* 2 target)))
                 (third (find-start A (* 3 target))))
            (if (and first second third)
                (let-values (((a b) (find-end A first second))
                             ((c d) (find-end A second third)))
                  (if (equal? (sublist A a b) (sublist A c d))
                      (list first (- b 1) (- d 1))
                      '(-1 -1)))
                '(-1 -1))))))

(define (find-start A target)
  (let loop ((i 0) (count 0))
    (cond
      ((= count target) i)
      ((= i (length A)) #f)
      (else (loop (+ i 1) (+ count (if (= (list-ref A i) 1) 1 0)))))))

(define (find-end A start end)
  (let loop ((i start) (count 0))
    (if (>= count 2)
        (values start i)
        (if (>= i (length A))
            (values start i)
            (loop (+ i 1) (+ count (if (= (list-ref A i) 1) 1 0)))))))