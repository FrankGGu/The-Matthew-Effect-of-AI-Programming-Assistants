(define (findMaximumXOR nums)
  (define (insert trie num)
    (let loop ((node trie) (bit 31))
      (if (< bit 0)
          '()
          (let ((b (bitwise-arithmetic-shift-right num bit)))
            (if (zero? (bitwise-and b 1))
                (set! node (or (cdr node) (cons '() '())))
                (set! node (or (car node) (cons '() '()))))
            (loop node (sub1 bit))))))

  (define (search trie num)
    (let loop ((node trie) (bit 31) (max-xor 0))
      (if (< bit 0)
          max-xor
          (let ((b (bitwise-arithmetic-shift-right num bit)))
            (if (zero? (bitwise-and b 1))
                (if (car node)
                    (loop (car node) (sub1 bit) (bitwise-ior max-xor (bitwise-arithmetic-shift-left 1 bit)))
                    (loop (cdr node) (sub1 bit) max-xor))
                (if (cdr node)
                    (loop (cdr node) (sub1 bit) (bitwise-ior max-xor (bitwise-arithmetic-shift-left 1 bit)))
                    (loop (car node) (sub1 bit) max-xor)))))))

  (define trie '())
  (for-each (lambda (num) (set! trie (insert trie num))) nums)
  (for/fold ([max-xor 0]) ([num nums])
    (max max-xor (search trie num)))
  )

(findMaximumXOR (list 3 10 5 25 2 8))