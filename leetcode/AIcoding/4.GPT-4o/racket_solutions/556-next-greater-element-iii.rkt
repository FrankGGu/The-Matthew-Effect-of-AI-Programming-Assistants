(define (nextGreaterElement n)
  (define (to-digits x)
    (if (= x 0) '()
        (cons (modulo x 10) (to-digits (quotient x 10)))))
  (define (to-number digits)
    (foldl (lambda (d acc) (+ (* acc 10) d)) 0 digits))
  (define (find-next digits)
    (let loop ((i (- (length digits) 2)))
      (if (< i 0) '()
          (if (< (list-ref digits i) (list-ref digits (+ i 1)))
              (let* ((pivot (list-ref digits i))
                     (right (drop digits (+ i 1)))
                     (next (find-min-greater pivot right)))
                (let ((next-index (index-of right next)))
                  (set! right (swap! right 0 next-index))
                  (set! (list-ref digits i) next)
                  (set! (list-ref digits (+ i 1)) pivot)
                  (append (take digits i) (list next) (sort (cons pivot (remove next right)) <))))
              (loop (- i 1)))))
  (define (find-min-greater pivot lst)
    (foldl (lambda (x acc)
              (if (and (> x pivot) (or (null? acc) (< x acc)))
                  x acc))
            '() lst))
  (define (swap! lst i j)
    (let ((temp (list-ref lst i)))
      (set! (list-ref lst i) (list-ref lst j))
      (set! (list-ref lst j) temp)))
  (define (index-of lst item)
    (let loop ((lst lst) (index 0))
      (cond
        ((null? lst) -1)
        ((equal? (car lst) item) index)
        (else (loop (cdr lst) (+ index 1))))))
  (define digits (to-digits n))
  (let ((next (find-next digits)))
    (if (null? next) -1
        (if (> (to-number next) 2147483647) -1
            (to-number next)))))