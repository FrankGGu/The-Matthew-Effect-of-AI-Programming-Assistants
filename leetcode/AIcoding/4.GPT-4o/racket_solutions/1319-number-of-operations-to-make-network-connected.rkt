(define (make-connected n connections)
  (if (< (length connections) (- n 1))
      -1
      (let loop ((parent (build-parent n)) (count n))
        (for-each (lambda (edge)
                    (let ((u (car edge))
                          (v (cadr edge)))
                      (union! parent u v)))
                  connections)
        (let ((components (count-components parent n)))
          (- components 1)))))

(define (build-parent n)
  (let ((parent (make-vector n)))
    (for ([i (in-range n)])
      (vector-set! parent i i))
    parent))

(define (find parent x)
  (if (not (= (vector-ref parent x) x))
      (set! (vector-ref parent x) (find parent (vector-ref parent x))))
  (vector-ref parent x))

(define (union! parent x y)
  (define rootX (find parent x))
  (define rootY (find parent y))
  (if (not (= rootX rootY))
      (vector-set! parent rootX rootY)))

(define (count-components parent n)
  (define seen (make-hash))
  (for ([i (in-range n)])
    (hash-set! seen (find parent i) #t))
  (hash-count seen))