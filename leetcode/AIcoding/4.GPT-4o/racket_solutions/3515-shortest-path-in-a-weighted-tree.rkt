(define (shortest-path n edges start end)
  (define graph (make-hash))
  (for-each (lambda (edge)
              (define u (car edge))
              (define v (cadr edge))
              (define w (caddr edge))
              (hash-set! graph u (cons (cons v w) (hash-ref graph u '())))
              (hash-set! graph v (cons (cons u w) (hash-ref graph v '())))))
            edges)
  (define (dijkstra start end)
    (define distances (make-vector n (lambda () +inf.0)))
    (define previous (make-vector n #f))
    (vector-set! distances start 0)
    (define pq (make-priority-queue))
    (priority-queue-enqueue! pq start 0)
    (let loop ()
      (if (priority-queue-empty? pq)
          '()
          (define current (priority-queue-dequeue! pq))
          (define current-dist (vector-ref distances current))
          (for-each (lambda (neighbor)
                      (define next (car neighbor))
                      (define weight (cadr neighbor))
                      (define new-dist (+ current-dist weight))
                      (when (< new-dist (vector-ref distances next))
                        (vector-set! distances next new-dist)
                        (vector-set! previous next current)
                        (priority-queue-enqueue! pq next new-dist)))
                    (hash-ref graph current '()))
          (if (= current end)
              (let loop2 ((path '()) (node end))
                (if (eq? node start)
                    (reverse (cons start path))
                    (loop2 (cons node path) (vector-ref previous node))))
              (loop)))))
  (dijkstra start end))