(define (min-swaps arr)
  (define n (length arr))
  (define (digit-sum x)
    (if (= x 0)
        0
        (+ (modulo x 10) (digit-sum (quotient x 10)))))
  (define indexed-arr (map (lambda (x) (list x (digit-sum x))) arr))
  (define sorted-arr (sort indexed-arr (lambda (a b) (let ((sum-a (second a)) (sum-b (second b)))
                                                      (if (= sum-a sum-b)
                                                          (< (first a) (first b))
                                                          (< sum-a sum-b))))))
  (define index-map (make-hash))
  (for ([i (in-range n)])
    (hash-set! index-map (first (list-ref sorted-arr i)) i))
  (define visited (make-vector n #f))
  (define swaps 0)
  (for ([i (in-range n)])
    (if (vector-ref visited i)
        (void)
        (let loop ([cycle-size 0] [j i])
          (set! cycle-size (+ cycle-size 1))
          (set! j (hash-ref index-map (first (list-ref sorted-arr j))))
          (if (not (vector-ref visited j))
              (begin
                (vector-set! visited j #t)
                (loop cycle-size j)))
          (if (> cycle-size 0)
              (set! swaps (+ swaps (- cycle-size 1))))))
    )
  swaps)

(define (minimum-swaps arr)
  (min-swaps arr))