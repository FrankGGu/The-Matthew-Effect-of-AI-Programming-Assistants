(define (quick-bus n roads)
  (define graph (make-hash))
  (for ([road roads])
    (let ([a (car road)]
          [b (cadr road)])
      (hash-set! graph a (cons b (hash-ref graph a '())))
      (hash-set! graph b (cons a (hash-ref graph b '())))))
  (define (dijkstra start)
    (define distances (make-hash))
    (define previous (make-hash))
    (define queue (make-queue))
    (for ([i (in-range 1 (+ n 1))])
      (hash-set! distances i +inf.0)
      (hash-set! previous i #f)
      (queue-enqueue! queue (list i +inf.0)))
    (hash-set! distances start 0)
    (queue-enqueue! queue (list start 0))
    (define (update-distance node dist)
      (for ([neighbor (hash-ref graph node '())])
        (let ([new-dist (+ dist 1)]) ; Assuming each road has a cost of 1
          (when (< new-dist (hash-ref distances neighbor +inf.0))
            (hash-set! distances neighbor new-dist)
            (hash-set! previous neighbor node)
            (queue-enqueue! queue (list neighbor new-dist))))))
    (define (process-queue)
      (when (not (queue-empty? queue))
        (define [current dist] (queue-dequeue! queue))
        (update-distance current dist)
        (process-queue)))
    (process-queue)
    (values distances previous))
  (define (reconstruct-path previous start end)
    (define path '())
    (let loop ([current end])
      (when current
        (set! path (cons current path))
        (loop (hash-ref previous current #f))))
    (if (equal? (car path) start)
        path
        '()))
  (define start 1)
  (define end n)
  (define-values (distances previous) (dijkstra start))
  (define path (reconstruct-path previous start end))
  (if (null? path)
      '()
      path))