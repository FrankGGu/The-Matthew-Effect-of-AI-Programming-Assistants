(define (shortestBridge A)
  (define (dfs x y)
    (when (and (>= x 0) (< x (vector-length A)) 
               (>= y 0) (< y (vector-length (vector-ref A 0))) 
               (= (vector-ref (vector-ref A x) y) 1))
      (vector-set! (vector-ref A x) y -1)
      (set! islands (cons (cons x y) islands))
      (for-each (lambda (d) (dfs (+ x (car d)) (+ y (cdr d))))
                '((-1 0) (1 0) (0 -1) (0 1)))))

  (define (bfs)
    (let loop ((q (list)))
      (if (null? q)
          (length path)
          (let* ((len (length q))
                 (next (car q))
                 (x (car next))
                 (y (cadr next))
                 (rest (cdr q))
                 (new-path (append path (list (cons x y)))))
            (for-each (lambda (d)
                        (let ((nx (+ x (car d))) (ny (+ y (cdr d))))
                          (when (and (>= nx 0) (< nx (vector-length A))
                                     (>= ny 0) (< ny (vector-length (vector-ref A 0)))
                                     (not (= (vector-ref (vector-ref A nx) ny) -1)))
                            (if (= (vector-ref (vector-ref A nx) ny) 1)
                                (set! path (append new-path (list (cons nx ny))))
                                (set! rest (cons (cons nx ny) rest))
                                (vector-set! (vector-ref A nx) ny -1)))))
                      '((-1 0) (1 0) (0 -1) (0 1)))
            (loop (append rest (cdr q)))))))

  (define islands '())
  (for ((i (in-range (vector-length A)))
        (j (in-range (vector-length (vector-ref A 0)))))
    (when (= (vector-ref (vector-ref A i) j) 1)
      (dfs i j)
      (set! path '())
      (return)))
  (for-each (lambda (cell) (set! path (cons cell path))) islands)
  (bfs))

(define A (vector (vector 0 0 0 0 0 0) 
                  (vector 0 0 1 0 0 0) 
                  (vector 0 0 0 0 1 1) 
                  (vector 0 0 0 0 0 0) 
                  (vector 0 0 0 0 0 0)))
(shortestBridge A)