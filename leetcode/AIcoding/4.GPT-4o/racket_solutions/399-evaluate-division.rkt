#lang racket

(define (calcEquation equations values queries)
  (define graph (make-hash))
  (for ([i (in-range (length equations))])
    (define a (first (list-ref equations i)))
    (define b (second (list-ref equations i)))
    (define value (list-ref values i))
    (define a-list (hash-ref graph a (list)))
    (define b-list (hash-ref graph b (list)))
    (hash-set! graph a (cons (cons b value) a-list))
    (hash-set! graph b (cons (cons a (/ 1.0 value)) b-list)))
  (define (dfs start end visited)
    (if (equal? start end)
        1.0
        (for/or ([neighbor (in-list (hash-ref graph start '()))])
          (define n (car neighbor))
          (define weight (cdr neighbor))
          (if (not (hash-has-key? visited n))
              (begin
                (hash-set! visited n #t)
                (define result (dfs n end visited))
                (if (not (equal? result -1.0))
                    (* result weight)))))))
  (map (lambda (query)
         (define start (first query))
         (define end (second query))
         (if (and (hash-has-key? graph start)
                  (hash-has-key? graph end))
             (let ([visited (make-hash)])
               (or (dfs start end visited) -1.0))
             -1.0))
       queries))

(define (calcEquation equations values queries)
  (define graph (make-hash))
  (for ([i (in-range (length equations))])
    (define a (first (list-ref equations i)))
    (define b (second (list-ref equations i)))
    (define value (list-ref values i))
    (define a-list (hash-ref graph a '()))
    (define b-list (hash-ref graph b '()))
    (hash-set! graph a (cons (cons b value) a-list))
    (hash-set! graph b (cons (cons a (/ 1.0 value)) b-list)))
  (define (dfs start end visited)
    (if (equal? start end)
        1.0
        (for/or ([neighbor (in-list (hash-ref graph start '()))])
          (define n (car neighbor))
          (define weight (cdr neighbor))
          (if (not (hash-has-key? visited n))
              (begin
                (hash-set! visited n #t)
                (define result (dfs n end visited))
                (if (not (equal? result -1.0))
                    (* result weight)))))))
  (map (lambda (query)
         (define start (first query))
         (define end (second query))
         (if (and (hash-has-key? graph start)
                  (hash-has-key? graph end))
             (let ([visited (make-hash)])
               (or (dfs start end visited) -1.0))
             -1.0))
       queries))