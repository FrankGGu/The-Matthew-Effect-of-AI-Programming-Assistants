#lang racket

(define (recoverTree root)
  (define (inorder-traversal node)
    (if (null? node)
        '()
        (append (inorder-traversal (node-left node))
                (list (node-value node))
                (inorder-traversal (node-right node)))))

  (define (find-swap vals)
    (define n (length vals))
    (define first (list))
    (define second (list))
    (define prev #f)
    (for ([i (in-range n)])
      (when (and prev (> (list-ref vals i) prev))
        (set! second (list-ref vals i)))
      (when (and prev (< (list-ref vals i) prev))
        (when (null? first)
          (set! first (list-ref vals (- i 1)))
        )
        (set! second (list-ref vals i)))
      (set! prev (list-ref vals i)))
    (values (car first) (car second)))

  (define vals (inorder-traversal root))
  (define-values (a b) (find-swap vals))

  (define (recover node)
    (when (null? node)
      (return))
    (when (= (node-value node) a)
      (set! (node-value node) b))
    (when (= (node-value node) b)
      (set! (node-value node) a))
    (recover (node-left node))
    (recover (node-right node)))

  (recover root))