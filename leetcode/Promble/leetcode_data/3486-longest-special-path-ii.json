{
  "id": "3486",
  "title": "Longest Special Path II",
  "titleSlug": "longest-special-path-ii",
  "difficulty": "Hard",
  "category": "Algorithms",
  "topics": [
    "Tree",
    "Depth-First Search",
    "Array",
    "Hash Table",
    "Prefix Sum"
  ],
  "content": "<p>You are given an undirected tree rooted at node <code>0</code>, with <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>. This is represented by a 2D array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, length<sub>i</sub>]</code> indicates an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with length <code>length<sub>i</sub></code>. You are also given an integer array <code>nums</code>, where <code>nums[i]</code> represents the value at node <code>i</code>.</p>\n\n<p>A <strong>special path</strong> is defined as a <strong>downward</strong> path from an ancestor node to a descendant node in which all node values are <strong>distinct</strong>, except for <strong>at most</strong> one value that may appear twice.</p>\n\n<p>Return an array <code data-stringify-type=\"code\">result</code> of size 2, where <code>result[0]</code> is the <b data-stringify-type=\"bold\">length</b> of the <strong>longest</strong> special path, and <code>result[1]</code> is the <b data-stringify-type=\"bold\">minimum</b> number of nodes in all <i data-stringify-type=\"italic\">possible</i> <strong>longest</strong> special paths.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">edges = [[0,1,1],[1,2,3],[1,3,1],[2,4,6],[4,7,2],[3,5,2],[3,6,5],[6,8,3]], nums = [1,1,0,3,1,2,1,1,0]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[9,3]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>In the image below, nodes are colored by their corresponding values in <code>nums</code>.</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2025/02/18/e1.png\" style=\"width: 190px; height: 270px;\" /></p>\n\n<p>The longest special paths are <code>1 -&gt; 2 -&gt; 4</code> and <code>1 -&gt; 3 -&gt; 6 -&gt; 8</code>, both having a length of 9. The minimum number of nodes across all longest special paths is 3.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">edges = [[1,0,3],[0,2,4],[0,3,5]], nums = [1,1,0,2]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[5,2]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2025/02/18/e2.png\" style=\"width: 150px; height: 110px;\" /></p>\n\n<p>The longest path is <code>0 -&gt; 3</code> consisting of 2 nodes with a length of 5.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 5 * 10<sup><span style=\"font-size: 10.8333px;\">4</span></sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>\n\t<li><code>1 &lt;= length<sub>i</sub> &lt;= 10<sup>3</sup></code></li>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>The input is generated such that <code>edges</code> represents a valid tree.</li>\n</ul>\n",
  "codeSnippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> longestSpecialPath(vector<vector<int>>& edges, vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] longestSpecialPath(int[][] edges, int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def longestSpecialPath(self, edges, nums):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def longestSpecialPath(self, edges: List[List[int]], nums: List[int]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* longestSpecialPath(int** edges, int edgesSize, int* edgesColSize, int* nums, int numsSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] LongestSpecialPath(int[][] edges, int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} edges\n * @param {number[]} nums\n * @return {number[]}\n */\nvar longestSpecialPath = function(edges, nums) {\n    \n};",
    "typescript": "function longestSpecialPath(edges: number[][], nums: number[]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $edges\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function longestSpecialPath($edges, $nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func longestSpecialPath(_ edges: [[Int]], _ nums: [Int]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun longestSpecialPath(edges: Array<IntArray>, nums: IntArray): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> longestSpecialPath(List<List<int>> edges, List<int> nums) {\n    \n  }\n}",
    "golang": "func longestSpecialPath(edges [][]int, nums []int) []int {\n    \n}",
    "ruby": "# @param {Integer[][]} edges\n# @param {Integer[]} nums\n# @return {Integer[]}\ndef longest_special_path(edges, nums)\n    \nend",
    "scala": "object Solution {\n    def longestSpecialPath(edges: Array[Array[Int]], nums: Array[Int]): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn longest_special_path(edges: Vec<Vec<i32>>, nums: Vec<i32>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (longest-special-path edges nums)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?) (listof exact-integer?))\n  )",
    "erlang": "-spec longest_special_path(Edges :: [[integer()]], Nums :: [integer()]) -> [integer()].\nlongest_special_path(Edges, Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec longest_special_path(edges :: [[integer]], nums :: [integer]) :: [integer]\n  def longest_special_path(edges, nums) do\n    \n  end\nend",
    "cangjie": "class Solution {\n    func longestSpecialPath(edges: Array<Array<Int64>>, nums: Array<Int64>): Array<Int64> {\n\n    }\n}"
  },
  "exampleTestcases": "[[0,1,1],[1,2,3],[1,3,1],[2,4,6],[4,7,2],[3,5,2],[3,6,5],[6,8,3]]\n[1,1,0,3,1,2,1,1,0]\n[[1,0,3],[0,2,4],[0,3,5]]\n[1,1,0,2]",
  "hints": [
    "Maintain a special path (from root to current node) dynamically.",
    "Also, maintain the positions of each value on the path so we can adjust the start point of the path.",
    "Use prefix sum to calculate the path length."
  ]
}