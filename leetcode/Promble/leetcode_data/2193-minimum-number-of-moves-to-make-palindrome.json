{
  "id": "2193",
  "title": "Minimum Number of Moves to Make Palindrome",
  "titleSlug": "minimum-number-of-moves-to-make-palindrome",
  "difficulty": "Hard",
  "category": "Algorithms",
  "topics": [
    "Greedy",
    "Binary Indexed Tree",
    "Two Pointers",
    "String"
  ],
  "content": "<p>You are given a string <code>s</code> consisting only of lowercase English letters.</p>\n\n<p>In one <strong>move</strong>, you can select any two <strong>adjacent</strong> characters of <code>s</code> and swap them.</p>\n\n<p>Return <em>the <strong>minimum number of moves</strong> needed to make</em> <code>s</code> <em>a palindrome</em>.</p>\n\n<p><strong>Note</strong> that the input will be generated such that <code>s</code> can always be converted to a palindrome.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aabb&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nWe can obtain two palindromes from s, &quot;abba&quot; and &quot;baab&quot;. \n- We can obtain &quot;abba&quot; from s in 2 moves: &quot;a<u><strong>ab</strong></u>b&quot; -&gt; &quot;ab<u><strong>ab</strong></u>&quot; -&gt; &quot;abba&quot;.\n- We can obtain &quot;baab&quot; from s in 2 moves: &quot;a<u><strong>ab</strong></u>b&quot; -&gt; &quot;<u><strong>ab</strong></u>ab&quot; -&gt; &quot;baab&quot;.\nThus, the minimum number of moves needed to make s a palindrome is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;letelt&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nOne of the palindromes we can obtain from s in 2 moves is &quot;lettel&quot;.\nOne of the ways we can obtain it is &quot;lete<u><strong>lt</strong></u>&quot; -&gt; &quot;let<u><strong>et</strong></u>l&quot; -&gt; &quot;lettel&quot;.\nOther palindromes such as &quot;tleelt&quot; can also be obtained in 2 moves.\nIt can be shown that it is not possible to obtain a palindrome in less than 2 moves.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> consists only of lowercase English letters.</li>\n\t<li><code>s</code> can be converted to a palindrome using a finite number of moves.</li>\n</ul>\n",
  "codeSnippets": {
    "cpp": "class Solution {\npublic:\n    int minMovesToMakePalindrome(string s) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minMovesToMakePalindrome(String s) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minMovesToMakePalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minMovesToMakePalindrome(self, s: str) -> int:\n        ",
    "c": "int minMovesToMakePalindrome(char* s) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinMovesToMakePalindrome(string s) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar minMovesToMakePalindrome = function(s) {\n    \n};",
    "typescript": "function minMovesToMakePalindrome(s: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function minMovesToMakePalindrome($s) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minMovesToMakePalindrome(_ s: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minMovesToMakePalindrome(s: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minMovesToMakePalindrome(String s) {\n    \n  }\n}",
    "golang": "func minMovesToMakePalindrome(s string) int {\n    \n}",
    "ruby": "# @param {String} s\n# @return {Integer}\ndef min_moves_to_make_palindrome(s)\n    \nend",
    "scala": "object Solution {\n    def minMovesToMakePalindrome(s: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_moves_to_make_palindrome(s: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (min-moves-to-make-palindrome s)\n  (-> string? exact-integer?)\n  )",
    "erlang": "-spec min_moves_to_make_palindrome(S :: unicode:unicode_binary()) -> integer().\nmin_moves_to_make_palindrome(S) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_moves_to_make_palindrome(s :: String.t) :: integer\n  def min_moves_to_make_palindrome(s) do\n    \n  end\nend",
    "cangjie": "class Solution {\n    func minMovesToMakePalindrome(s: String): Int64 {\n\n    }\n}"
  },
  "exampleTestcases": "\"aabb\"\n\"letelt\"",
  "hints": [
    "Consider a greedy strategy.",
    "Letâ€™s start by making the leftmost and rightmost characters match with some number of swaps.",
    "If we figure out how to do that using the minimum number of swaps, then we can delete the leftmost and rightmost characters and solve the problem recursively."
  ]
}