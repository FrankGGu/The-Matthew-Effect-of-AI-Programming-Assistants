{
  "id": "3563",
  "title": "Lexicographically Smallest String After Adjacent Removals",
  "titleSlug": "lexicographically-smallest-string-after-adjacent-removals",
  "difficulty": "Hard",
  "category": "Algorithms",
  "topics": [
    "String",
    "Dynamic Programming"
  ],
  "content": "<p>You are given a string <code>s</code> consisting of lowercase English letters.</p>\n\n<p>You can perform the following operation any number of times (including zero):</p>\n\n<ul>\n\t<li>Remove <strong>any</strong> pair of <strong>adjacent</strong> characters in the string that are <strong>consecutive</strong> in the alphabet, in either order (e.g., <code>&#39;a&#39;</code> and <code>&#39;b&#39;</code>, or <code>&#39;b&#39;</code> and <code>&#39;a&#39;</code>).</li>\n\t<li>Shift the remaining characters to the left to fill the gap.</li>\n</ul>\n\n<p>Return the <strong><span data-keyword=\"lexicographically-smaller-string\">lexicographically smallest</span></strong> string that can be obtained after performing the operations optimally.</p>\n\n<p><strong>Note:</strong> Consider the alphabet as circular, thus <code>&#39;a&#39;</code> and <code>&#39;z&#39;</code> are consecutive.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;abc&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;a&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li>Remove <code>&quot;bc&quot;</code> from the string, leaving <code>&quot;a&quot;</code> as the remaining string.</li>\n\t<li>No further operations are possible. Thus, the lexicographically smallest string after all possible removals is <code>&quot;a&quot;</code>.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;bcda&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li><strong>​​​​​​​</strong>Remove <code>&quot;cd&quot;</code> from the string, leaving <code>&quot;ba&quot;</code> as the remaining string.</li>\n\t<li>Remove <code>&quot;ba&quot;</code> from the string, leaving <code>&quot;&quot;</code> as the remaining string.</li>\n\t<li>No further operations are possible. Thus, the lexicographically smallest string after all possible removals is <code>&quot;&quot;</code>.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;zdce&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;zdce&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li>Remove <code>&quot;dc&quot;</code> from the string, leaving <code>&quot;ze&quot;</code> as the remaining string.</li>\n\t<li>No further operations are possible on <code>&quot;ze&quot;</code>.</li>\n\t<li>However, since <code>&quot;zdce&quot;</code> is lexicographically smaller than <code>&quot;ze&quot;</code>, the smallest string after all possible removals is <code>&quot;zdce&quot;</code>.</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 250</code></li>\n\t<li><code>s</code> consists only of lowercase English letters.</li>\n</ul>\n",
  "codeSnippets": {
    "cpp": "class Solution {\npublic:\n    string lexicographicallySmallestString(string s) {\n        \n    }\n};",
    "java": "class Solution {\n    public String lexicographicallySmallestString(String s) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def lexicographicallySmallestString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def lexicographicallySmallestString(self, s: str) -> str:\n        ",
    "c": "char* lexicographicallySmallestString(char* s) {\n    \n}",
    "csharp": "public class Solution {\n    public string LexicographicallySmallestString(string s) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} s\n * @return {string}\n */\nvar lexicographicallySmallestString = function(s) {\n    \n};",
    "typescript": "function lexicographicallySmallestString(s: string): string {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function lexicographicallySmallestString($s) {\n        \n    }\n}",
    "swift": "class Solution {\n    func lexicographicallySmallestString(_ s: String) -> String {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun lexicographicallySmallestString(s: String): String {\n        \n    }\n}",
    "dart": "class Solution {\n  String lexicographicallySmallestString(String s) {\n    \n  }\n}",
    "golang": "func lexicographicallySmallestString(s string) string {\n    \n}",
    "ruby": "# @param {String} s\n# @return {String}\ndef lexicographically_smallest_string(s)\n    \nend",
    "scala": "object Solution {\n    def lexicographicallySmallestString(s: String): String = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn lexicographically_smallest_string(s: String) -> String {\n        \n    }\n}",
    "racket": "(define/contract (lexicographically-smallest-string s)\n  (-> string? string?)\n  )",
    "erlang": "-spec lexicographically_smallest_string(S :: unicode:unicode_binary()) -> unicode:unicode_binary().\nlexicographically_smallest_string(S) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec lexicographically_smallest_string(s :: String.t) :: String.t\n  def lexicographically_smallest_string(s) do\n    \n  end\nend",
    "cangjie": "class Solution {\n    func lexicographicallySmallestString(s: String): String {\n\n    }\n}"
  },
  "exampleTestcases": "\"abc\"\n\"bcda\"\n\"zdce\"",
  "hints": [
    "As a result of the operation, some of the substrings can be removed",
    "Find out using DP, which substrings can we remove",
    "Now, try to build the ans using this DP",
    "Define ans[i] = lex smallest string that can be made in [i, n - 1], then ans[i] = lex_smallest of { choose one char s[j] in [i, n - 1] + ans[j + 1] }"
  ]
}