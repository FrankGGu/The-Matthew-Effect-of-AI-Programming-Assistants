{
  "id": "3045",
  "title": "Count Prefix and Suffix Pairs II",
  "titleSlug": "count-prefix-and-suffix-pairs-ii",
  "difficulty": "Hard",
  "category": "Algorithms",
  "topics": [
    "Trie",
    "Array",
    "String",
    "String Matching",
    "Hash Function",
    "Rolling Hash"
  ],
  "content": "<p>You are given a <strong>0-indexed</strong> string array <code>words</code>.</p>\n\n<p>Let&#39;s define a <strong>boolean</strong> function <code>isPrefixAndSuffix</code> that takes two strings, <code>str1</code> and <code>str2</code>:</p>\n\n<ul>\n\t<li><code>isPrefixAndSuffix(str1, str2)</code> returns <code>true</code> if <code>str1</code> is <strong>both</strong> a <span data-keyword=\"string-prefix\">prefix</span> and a <span data-keyword=\"string-suffix\">suffix</span> of <code>str2</code>, and <code>false</code> otherwise.</li>\n</ul>\n\n<p>For example, <code>isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;)</code> is <code>true</code> because <code>&quot;aba&quot;</code> is a prefix of <code>&quot;ababa&quot;</code> and also a suffix, but <code>isPrefixAndSuffix(&quot;abc&quot;, &quot;abcd&quot;)</code> is <code>false</code>.</p>\n\n<p>Return <em>an integer denoting the <strong>number</strong> of index pairs </em><code>(i<em>, </em>j)</code><em> such that </em><code>i &lt; j</code><em>, and </em><code>isPrefixAndSuffix(words[i], words[j])</code><em> is </em><code>true</code><em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;aba&quot;,&quot;ababa&quot;,&quot;aa&quot;]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(&quot;a&quot;, &quot;aba&quot;) is true.\ni = 0 and j = 2 because isPrefixAndSuffix(&quot;a&quot;, &quot;ababa&quot;) is true.\ni = 0 and j = 3 because isPrefixAndSuffix(&quot;a&quot;, &quot;aa&quot;) is true.\ni = 1 and j = 2 because isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;) is true.\nTherefore, the answer is 4.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;pa&quot;,&quot;papa&quot;,&quot;ma&quot;,&quot;mama&quot;]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(&quot;pa&quot;, &quot;papa&quot;) is true.\ni = 2 and j = 3 because isPrefixAndSuffix(&quot;ma&quot;, &quot;mama&quot;) is true.\nTherefore, the answer is 2.  </pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abab&quot;,&quot;ab&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation: </strong>In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(&quot;abab&quot;, &quot;ab&quot;) is false.\nTherefore, the answer is 0.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>words[i]</code> consists only of lowercase English letters.</li>\n\t<li>The sum of the lengths of all <code>words[i]</code> does not exceed <code>5 * 10<sup>5</sup></code>.</li>\n</ul>\n",
  "codeSnippets": {
    "cpp": "class Solution {\npublic:\n    long long countPrefixSuffixPairs(vector<string>& words) {\n        \n    }\n};",
    "java": "class Solution {\n    public long countPrefixSuffixPairs(String[] words) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def countPrefixSuffixPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n        ",
    "c": "long long countPrefixSuffixPairs(char** words, int wordsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public long CountPrefixSuffixPairs(string[] words) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string[]} words\n * @return {number}\n */\nvar countPrefixSuffixPairs = function(words) {\n    \n};",
    "typescript": "function countPrefixSuffixPairs(words: string[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String[] $words\n     * @return Integer\n     */\n    function countPrefixSuffixPairs($words) {\n        \n    }\n}",
    "swift": "class Solution {\n    func countPrefixSuffixPairs(_ words: [String]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun countPrefixSuffixPairs(words: Array<String>): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int countPrefixSuffixPairs(List<String> words) {\n    \n  }\n}",
    "golang": "func countPrefixSuffixPairs(words []string) int64 {\n    \n}",
    "ruby": "# @param {String[]} words\n# @return {Integer}\ndef count_prefix_suffix_pairs(words)\n    \nend",
    "scala": "object Solution {\n    def countPrefixSuffixPairs(words: Array[String]): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn count_prefix_suffix_pairs(words: Vec<String>) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (count-prefix-suffix-pairs words)\n  (-> (listof string?) exact-integer?)\n  )",
    "erlang": "-spec count_prefix_suffix_pairs(Words :: [unicode:unicode_binary()]) -> integer().\ncount_prefix_suffix_pairs(Words) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec count_prefix_suffix_pairs(words :: [String.t]) :: integer\n  def count_prefix_suffix_pairs(words) do\n    \n  end\nend",
    "cangjie": "class Solution {\n    func countPrefixSuffixPairs(words: Array<String>): Int64 {\n\n    }\n}"
  },
  "exampleTestcases": "[\"a\",\"aba\",\"ababa\",\"aa\"]\n[\"pa\",\"papa\",\"ma\",\"mama\"]\n[\"abab\",\"ab\"]",
  "hints": [
    "We can use a trie to solve it.",
    "Process all <code>words[i]</code> from left to right. The trie stores the pair <code>(words[i][j], words[i][words[i].length - j - 1])</code> as a single character; we process all the words in this way.",
    "During insertion, keep a counter in each trie node, as in a normal trie. If the current node is the end of a word (namely, the pair on that node is <code>(words[i][words[i].length - 1], words[i][0])</code>), increase the node's counter by <code>1</code>.",
    "From left to right, insert each word into the trie, and increase our final result by each node's counter when going down the trie during insertion. This means there was at least one word that is both a prefix and a suffix of the current word before."
  ]
}