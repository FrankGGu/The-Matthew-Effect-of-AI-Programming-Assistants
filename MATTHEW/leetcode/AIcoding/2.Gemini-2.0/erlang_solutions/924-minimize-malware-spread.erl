-module(minimize_malware_spread).
-export([minMalwareSpread/2]).

minMalwareSpread(Graph, Initial) ->
    N = length(Graph),
    UF = uf_init(N),
    for(I, 0, N - 1,
        for(J, I + 1, N - 1,
            if
                lists:nth(I + 1, lists:nth(J + 1, Graph)) == 1 ->
                    uf_union(UF, I, J);
                true ->
                    ok
            end
        end
    ),
    ComponentSize = [uf_size(UF, I) || I <- lists:seq(0, N - 1)],
    ComponentCount = lists:foldl(
        fun(I, Acc) ->
            Root = uf_find(UF, I),
            maps:update_with(Root, fun(Count) -> Count + 1 end, 1, Acc)
        end,
        #{},
        Initial
    ),
    BestNode = lists:foldl(
        fun(Node, {Best, BestSize}) ->
            Root = uf_find(UF, Node),
            case maps:get(Root, ComponentCount, 0) of
                1 ->
                    Size = maps:get(Root, ComponentSize, 0),
                    if
                        Size > BestSize ->
                            {Node, Size};
                        Size =:= BestSize andalso Node < Best ->
                            {Node, Size};
                        true ->
                            {Best, BestSize}
                    end;
                _ ->
                    {Best, BestSize}
            end
        end,
        {min(Initial), -1},
        Initial
    ),
    element(1, BestNode).

-record(uf, {parent, size}).

uf_init(N) ->
    [#uf{parent = I, size = 1} || I <- lists:seq(0, N - 1)].

uf_find(UF, I) ->
    UF1 = lists:nth(I + 1, UF),
    case UF1#uf.parent == I of
        true ->
            I;
        false ->
            Root = uf_find(UF, UF1#uf.parent),
            lists:nth(I + 1, uf_set_parent(UF, I, Root))#uf.parent
    end.

uf_union(UF, I, J) ->
    RootI = uf_find(UF, I),
    RootJ = uf_find(UF, J),
    if
        RootI == RootJ ->
            UF;
        true ->
            SizeI = lists:nth(RootI + 1, UF)#uf.size,
            SizeJ = lists:nth(RootJ + 1, UF)#uf.size,
            if
                SizeI < SizeJ ->
                    UF2 = uf_set_parent(UF, RootI, RootJ),
                    uf_set_size(UF2, RootJ, SizeI + SizeJ);
                true ->
                    UF2 = uf_set_parent(UF, RootJ, RootI),
                    uf_set_size(UF2, RootI, SizeI + SizeJ)
            end
    end.

uf_size(UF, I) ->
    Root = uf_find(UF, I),
    lists:nth(Root + 1, UF)#uf.size.

uf_set_parent(UF, I, Parent) ->
    lists:update(I + 1, (lists:nth(I + 1, UF))#uf{parent = Parent}, UF).

uf_set_size(UF, I, Size) ->
    lists:update(I + 1, (lists:nth(I + 1, UF))#uf{size = Size}, UF).