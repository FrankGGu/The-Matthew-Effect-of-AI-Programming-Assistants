-module(minimize_malware_spread_ii).
-export([minMalwareSpread/2]).

minMalwareSpread(graph, initial) ->
  N = length(graph),
  Affected = lists:seq(0, N - 1),
  lists:foldl(
    fun(Removed, {BestNode, MinAffected}) ->
      NewInitial = lists:delete(Removed, initial),
      NewAffected = spread(graph, NewInitial, N),
      NumAffected = length(NewAffected),
      case NumAffected < MinAffected of
        true -> {Removed, NumAffected};
        false ->
          case NumAffected =:= MinAffected of
            true ->
              case Removed < BestNode of
                true -> {Removed, NumAffected};
                false -> {BestNode, MinAffected}
              end;
            false -> {BestNode, MinAffected}
          end
      end
    end,
    {lists:min(initial), length(spread(graph, initial, N))},
    initial
  ).

spread(graph, initial, N) ->
  Queue = queue:from_list(initial),
  Visited = sets:from_list(initial),
  spread_helper(graph, Queue, Visited, N).

spread_helper(graph, Queue, Visited, _N) ->
  case queue:is_empty(Queue) of
    true -> sets:to_list(Visited);
    false ->
      {value, NewQueue} = queue:out(Queue),
      Node = element(2, value),
      Neighbors = lists:seq(0, length(graph) - 1),
      NewNeighbors = lists:filter(fun(Neighbor) -> lists:nth(Node + 1, lists:nth(Neighbor + 1, graph)) == 1 end, Neighbors),
      NewVisited = lists:foldl(
        fun(Neighbor, AccVisited) ->
          case sets:is_element(Neighbor, AccVisited) of
            true -> AccVisited;
            false -> sets:add_element(Neighbor, AccVisited)
          end
        end,
        Visited,
        NewNeighbors
      ),
      FoldedQueue = lists:foldl(
        fun(Neighbor, AccQueue) ->
          case sets:is_element(Neighbor, Visited) of
            true -> AccQueue;
            false -> queue:in(Neighbor, AccQueue)
          end
        end,
        NewQueue,
        NewNeighbors
      ),
      spread_helper(graph, FoldedQueue, NewVisited, _N)
  end.