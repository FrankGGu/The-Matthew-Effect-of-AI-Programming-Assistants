(define (subtree-sizes n edges queries)
  (define adj (make-vector (add1 n) '()))
  (for-each (lambda (edge)
              (let ((u (car edge)) (v (cdr edge)))
                (vector-set! adj u (cons v (vector-ref adj u)))
                (vector-set! adj v (cons u (vector-ref adj v)))))
            edges)

  (define (subtree-size root parent blocked)
    (let loop ((node root) (size 1))
      (for-each (lambda (neighbor)
                  (if (and (not (equal? neighbor parent))
                           (not (equal? neighbor blocked)))
                      (set! size (+ size (loop neighbor node)))))
                (vector-ref adj node))
      size))

  (map (lambda (query)
         (let ((u (car query)) (v (cdr query)))
           (let ((subtree-v (subtree-size v u u))
                 (subtree-u (subtree-size u v v)))
             (list subtree-v (- n subtree-v)))))
       queries))