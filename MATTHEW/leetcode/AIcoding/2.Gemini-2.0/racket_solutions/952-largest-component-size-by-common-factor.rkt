(define (largestComponentSize A)
  (define n (vector-length A))
  (define parent (make-vector n))
  (for ([i (in-range n)])
    (vector-set! parent i i))

  (define (find i)
    (if (= i (vector-ref parent i))
        i
        (let ([root (find (vector-ref parent i))])
          (vector-set! parent i root)
          root)))

  (define (union i j)
    (let ([rootI (find i)]
          [rootJ (find j)])
      (if (!= rootI rootJ)
          (vector-set! parent rootI rootJ))))

  (define factors (make-hash))
  (for ([i (in-range n)])
    (let ([a (vector-ref A i)])
      (for ([f (in-range 2 (add1 (sqrt a)))])
        (when (= (remainder a f) 0)
          (when (hash-has-key? factors f)
            (union i (hash-ref factors f)))
          (hash-set! factors f i)
          (when (= f (/ a f))
              (continue))
          (let ([other (/ a f)])
              (when (hash-has-key? factors other)
                  (union i (hash-ref factors other)))
              (hash-set! factors other i)))))
      (when (!= a 1)
        (when (hash-has-key? factors a)
          (union i (hash-ref factors a)))
        (hash-set! factors a i))))

  (define counts (make-hash))
  (for ([i (in-range n)])
    (let ([root (find i)])
      (hash-update counts root (lambda (v) (add1 v)) 1)))

  (foldr max 0 (hash-values counts)))