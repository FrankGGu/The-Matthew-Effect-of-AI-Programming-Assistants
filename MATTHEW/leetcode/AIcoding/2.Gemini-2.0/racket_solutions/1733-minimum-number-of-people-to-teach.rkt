(define (minimum-teachings n languages preferences)
  (define (build-graph)
    (let ((graph (make-hash)))
      (for-each (lambda (p)
                  (let ((u (car p))
                        (v (cadr p)))
                    (hash-update! graph u (lambda (x) (cons v x)) '())
                    (hash-update! graph v (lambda (x) (cons u x)) '())))
                preferences)
      graph))

  (define (reachable start languages)
    (let ((visited (make-hash))
          (q (list start)))
      (hash-set! visited start #t)
      (let loop ((q q))
        (if (null? q)
            visited
            (let ((u (car q))
                  (rest (cdr q)))
              (let ((neighbors (hash-ref (build-graph) u '())))
                (let loop2 ((neighbors neighbors))
                  (if (null? neighbors)
                      (loop rest)
                      (let ((v (car neighbors)))
                        (if (not (hash-has-key? visited v))
                            (let ((common-languages (intersect (list->set (list-ref languages (- u 1))) (list->set (list-ref languages (- v 1))))))
                              (if (not (set-empty? common-languages))
                                  (begin
                                    (hash-set! visited v #t)
                                    (loop (append rest (list v))))
                                  (loop2 (cdr neighbors))))
                            (loop2 (cdr neighbors))))))))))))

  (define (people-who-need-teaching languages preferences)
    (let ((graph (build-graph))
          (unreachable-people '()))
      (for-each (lambda (p)
                  (let ((u (car p))
                        (v (cadr p)))
                    (let ((reachable-nodes (reachable u languages)))
                      (if (not (hash-has-key? reachable-nodes v))
                          (begin
                            (unless (member u unreachable-people) (set! unreachable-people (cons u unreachable-people)))
                            (unless (member v unreachable-people) (set! unreachable-people (cons v unreachable-people)))))
                      )))
                preferences)
      unreachable-people))

  (define (calculate-teaching-needed languages people-who-need-teaching)
    (let ((language-counts (make-vector n 0)))
      (for-each (lambda (p)
                  (let ((person-languages (list-ref languages (- p 1))))
                    (for-each (lambda (lang)
                                (vector-set! language-counts (- lang 1) (+ (vector-ref language-counts (- lang 1)) 1)))
                              person-languages)))
                people-who-need-teaching)
      (apply min (map (lambda (i) (vector-ref language-counts i)) (range 0 n)))))

  (length (people-who-need-teaching languages preferences)))