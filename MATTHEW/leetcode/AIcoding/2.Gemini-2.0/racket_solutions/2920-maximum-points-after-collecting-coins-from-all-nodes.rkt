(define (maximum-points coins edges k)
  (define n (length coins))
  (define adj (make-vector n null))
  (for-each (lambda (edge)
              (let ((u (car edge)) (v (cadr edge)))
                (set-vector! adj u (cons v (vector-ref adj u)))
                (set-vector! adj v (cons u (vector-ref adj v)))))
            edges)

  (define memo (make-hash))

  (define (dfs u parent shift)
    (hash-ref! memo (list u parent shift)
             (lambda ()
               (if (= shift 10)
                   (values 0 0)
                   (let* ((collect (+ (floor (/ (vector-ref coins u) (expt 2 shift))) k))
                          (no-collect (floor (/ (vector-ref coins u) (expt 2 shift)))))
                     (define collect-total 0)
                     (define no-collect-total 0)
                     (for-each (lambda (v)
                                 (if (not (= v parent))
                                     (let-values ([(collect-v no-collect-v) (dfs v u shift)])
                                       (set! collect-total (+ collect-total (max collect-v no-collect-v))))))
                               (vector-ref adj u))
                     (for-each (lambda (v)
                                 (if (not (= v parent))
                                     (let-values ([(collect-v no-collect-v) (dfs v u (+ shift 1))])
                                       (set! no-collect-total (+ no-collect-total (max collect-v no-collect-v))))))
                               (vector-ref adj u))
                     (values (+ collect collect-total) (+ no-collect no-collect-total)))))))

  (let-values ([(collect-0 no-collect-0) (dfs 0 -1 0)])
    (max collect-0 no-collect-0)))