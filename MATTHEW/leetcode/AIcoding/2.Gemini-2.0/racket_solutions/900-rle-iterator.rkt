(define (make-rle-iterator encoding)
  (let ((data (list->vector encoding))
        (index 0)
        (count 0))
    (define (next n)
      (let loop ((n n) (result '()))
        (cond
          ((= n 0) (values (reverse result) #t))
          ((>= index (vector-length data)) (values (append result (make-list n -1)) #f))
          ((= count 0)
           (set! count (vector-ref data index))
           (set! index (+ index 1))
           (loop n result))
          (else
           (let ((val (vector-ref data index)))
             (cond
               ((>= count n)
                (set! count (- count n))
                (values (append result (make-list n val)) #t))
               (else
                (set! n (- n count))
                (set! index (+ index 1))
                (let ((temp-result (append result (make-list count val))))
                  (set! count 0)
                  (loop n temp-result)))))))))
    (define (next-single)
      (let ((result (next 1)))
        (if (equal? (cdr result) #t)
            (car (car result))
            -1)))
    (define (has-next?)
      (or (> count 0) (< index (vector-length data))))
    (values next-single has-next?)))

(provide make-rle-iterator)