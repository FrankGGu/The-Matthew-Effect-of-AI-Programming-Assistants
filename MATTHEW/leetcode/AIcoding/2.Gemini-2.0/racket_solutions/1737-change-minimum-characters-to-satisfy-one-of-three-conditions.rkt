(define (min-characters s1 s2)
  (define (count-chars s)
    (let ((counts (make-vector 26 0)))
      (for ([c (string->list s)])
        (vector-set! counts (- (char->integer c) (char->integer #\a)) (+ 1 (vector-ref counts (- (char->integer c) (char->integer #\a))))))
      counts))

  (define (min-ops-same s char)
    (let ((count 0))
      (for ([c (string->list s)])
        (if (not (char=? c char))
            (set! count (+ count 1))))
      count))

  (define (min-ops-less s1 s2)
    (let ((min-count #f))
      (for ([i (in-range 0 25)])
        (let* ((char (integer->char (+ i (char->integer #\a))))
               (count (+ (min-ops-same s1 char)
                         (fold + 0 (vector->list (vector-subvector (count-chars s2) (+ i 1) 26))))))
          (if (or (not min-count) (< count min-count))
              (set! min-count count))))
      min-count))

  (let* ((n1 (string-length s1))
         (n2 (string-length s2))
         (counts1 (count-chars s1))
         (counts2 (count-chars s2))
         (min-same1 (apply min (vector->list counts1)))
         (min-same2 (apply min (vector->list counts2)))
         (same-ops (- (+ n1 n2) min-same1 min-same2))
         (less-ops1 (min-ops-less s1 s2))
         (less-ops2 (min-ops-less s2 s1)))
    (min same-ops less-ops1 less-ops2)))