(define (closest-equal-element-queries arr queries)
  (let* ((n (length arr))
         (m (length queries))
         (indices (make-hash))
         (result (make-vector m '())))
    (for/list ((i (in-range n)))
      (let ((val (list-ref arr i)))
        (hash-update! indices val (lambda (lst) (cons i lst)) '())))
    (for/list ((j (in-range m)))
      (let* ((query (list-ref queries j))
             (left (list-ref query 0))
             (right (list-ref query 1))
             (val (list-ref query 2))
             (positions (hash-ref indices val #f)))
        (if (not positions)
            -1
            (let loop ((pos positions) (min-diff +inf.0) (closest -1))
              (cond
                ((null? pos) closest)
                (else
                 (let ((curr (car pos)))
                   (if (and (>= curr left) (<= curr right))
                       (let ((diff (min (abs (- curr left)) (abs (- curr right)))))
                         (if (< diff min-diff)
                             (loop (cdr pos) diff curr)
                             (loop (cdr pos) min-diff closest)))
                       (loop (cdr pos) min-diff closest)))))))))