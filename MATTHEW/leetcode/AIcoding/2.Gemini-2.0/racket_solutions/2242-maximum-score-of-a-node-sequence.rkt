(define (maximum-score-of-a-node-sequence n edges)
  (define adj (make-vector n '()))
  (for-each (lambda (edge)
              (let ((u (car edge)) (v (cadr edge)) (w (caddr edge)))
                (vector-set! adj u (cons (cons v w) (vector-ref adj u)))
                (vector-set! adj v (cons (cons u w) (vector-ref adj v)))))
            edges)

  (define (find-max-score start)
    (let loop ((visited (set start)) (path (list start)) (current start) (score 0))
      (if (and (length path) (> (length path) 4))
          -1
          (let* ((neighbors (vector-ref adj current))
                 (valid-neighbors (filter (lambda (neighbor) (not (set-member? visited (car neighbor)))) neighbors)))
            (if (null? valid-neighbors)
                (if (and (length path) (> (length path) 3) (member (car path) (map car neighbors)))
                    (+ score (caddr (find (lambda (neighbor) (= (car neighbor) (car path))) neighbors)))
                    -1)
                (let ((max-score -1))
                  (for-each (lambda (neighbor)
                              (let ((new-score (loop (set-add visited (car neighbor))
                                                     (cons (car neighbor) path)
                                                     (car neighbor)
                                                     (+ score (cadr neighbor)))))
                                (set! max-score (max max-score new-score))))
                            valid-neighbors)
                  max-score))))))

  (define max-result -1)
  (for/or ((i (in-range n)))
    (let ((result (find-max-score i)))
      (if (> result max-result)
          (set! max-result result)))
    #f)
  max-result)

#;(let ((n 6)
        (edges '((0 1 1) (1 2 6) (2 0 2) (0 3 3) (3 4 4) (4 5 5) (5 0 5))))
  (displayln (maximum-score-of-a-node-sequence n edges)))