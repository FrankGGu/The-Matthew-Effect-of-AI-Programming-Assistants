(define (lexicographically-smallest-string-after-applying-operations s a b)
  (define n (string-length s))
  (define visited (make-hash))
  (define q (queue))
  (enqueue! q s)
  (hash-set! visited s #t)
  (define (add s i a)
    (string-set s i (integer->char (+ (modulo (+ (- (char->integer (string-ref s i)) (char->integer #\0)) a) 10) (char->integer #\0)))))

  (define (rotate s b)
    (string-append (substring s (- n b)) (substring s 0 (- n b))))

  (define (bfs)
    (define min-s s)
    (let loop ()
      (if (queue-empty? q)
          min-s
          (let* ((curr-s (dequeue! q)))
            (if (string<? curr-s min-s)
                (set! min-s curr-s))
            (let ((add-s (string-copy curr-s))
                  (rotate-s (rotate curr-s b)))
              (for ((i (in-range 1 n 2)))
                (add add-s i a))
              (unless (hash-has-key? visited add-s)
                (enqueue! q add-s)
                (hash-set! visited add-s #t))
              (unless (hash-has-key? visited rotate-s)
                (enqueue! q rotate-s)
                (hash-set! visited rotate-s #t))
              (loop))))))
  (bfs))