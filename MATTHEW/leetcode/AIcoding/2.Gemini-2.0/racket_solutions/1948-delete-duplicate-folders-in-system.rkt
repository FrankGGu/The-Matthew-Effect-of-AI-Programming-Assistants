(define (delete-duplicate-folder folders)
  (define (serialize folder)
    (string-append "("
                   (string-join (map serialize (sort (hash-ref folder 'children '()))) " ")
                   ")"))

  (define (build-trie folders)
    (let ((root (make-hash)))
      (for-each (lambda (path)
                  (let loop ((node root) (path path))
                    (if (null? path)
                        #t
                        (let ((dir (car path))
                              (rest (cdr path)))
                          (define next-node (hash-ref node 'children #f))
                          (if (not next-node)
                              (hash-set! node 'children (make-hash)))
                          (let ((child-node (hash-ref node 'children)))
                            (define dir-node (hash-ref child-node dir #f))
                            (if (not dir-node)
                                (hash-set! child-node dir (make-hash)))
                            (loop (hash-ref child-node dir) rest))))))
                folders)
      root))

  (define (mark-duplicates root)
    (let ((signatures (make-hash))
          (to-delete (make-hash)))
      (letrec ((traverse (lambda (node path)
                           (let ((signature (serialize node)))
                             (cond
                               ((hash-has-key? signatures signature)
                                (hash-set! to-delete node #t)
                                (for-each (lambda (dir)
                                            (let ((child-node (hash-ref (hash-ref node 'children) dir #f)))
                                              (if child-node
                                                  (hash-set! to-delete child-node #t))))
                                          (hash-keys (hash-ref node 'children '()))))
                               (else
                                (hash-set! signatures signature (cons path node))
                                (for-each (lambda (dir)
                                            (let ((child-node (hash-ref (hash-ref node 'children) dir #f)))
                                              (if child-node
                                                  (traverse child-node (append path (list dir))))))
                                          (hash-keys (hash-ref node 'children '())))))))))
        (traverse root '()))
      to-delete))

  (define (filter-folders folders to-delete)
    (filter (lambda (folder)
              (letrec ((check-duplicate (lambda (path)
                                           (let loop ((node root) (path path))
                                             (cond
                                               ((null? path)
                                                (not (hash-has-key? to-delete node)))
                                               (else
                                                (let ((dir (car path))
                                                      (rest (cdr path)))
                                                  (define next-node (hash-ref node 'children #f))
                                                  (if (not next-node)
                                                      (begin (displayln "Error: Missing node in trie") #f))
                                                  (let ((child-node (hash-ref node 'children)))
                                                    (define dir-node (hash-ref child-node dir #f))
                                                    (if (not dir-node)
                                                        (begin (displayln "Error: Missing dir node in trie") #f))
                                                    (loop (hash-ref child-node dir) rest))))))))))
                (let ((root (build-trie folders)))
                  (check-duplicate folder))))
            folders))

  (let ((trie-root (build-trie folders)))
    (let ((to-delete (mark-duplicates trie-root)))
      (sort (filter-folders folders to-delete)
            (lambda (a b)
              (letrec ((compare (lambda (list1 list2)
                                  (cond
                                    ((and (null? list1) (null? list2)) #f)
                                    ((null? list1) #t)
                                    ((null? list2) #f)
                                    (else
                                     (let ((comparison (string<? (car list1) (car list2))))
                                       (if (or comparison (string>? (car list1) (car list2)))
                                           comparison
                                           (compare (cdr list1) (cdr list2)))))))))
                (compare a b)))))))