(define (maximum-amount (n edges cost))
  (let* ((adj (make-vector n '()))
         (dp (make-vector n '(0 0)))
         (ans (make-box 0)))
    (for-each (lambda (edge)
                (let ((u (vector-ref edge 0))
                      (v (vector-ref edge 1)))
                  (set! (vector-ref adj u) (cons v (vector-ref adj u)))
                  (set! (vector-ref adj v) (cons u (vector-ref adj v)))))
              edges)

    (define (dfs u p)
      (let ((pos-prod 1)
            (neg-prod 1)
            (pos-count 0)
            (neg-count 0))
        (for-each (lambda (v)
                    (when (not (= v p))
                      (dfs v u)
                      (let ((pos (vector-ref dp v 0))
                            (neg (vector-ref dp v 1)))
                        (cond
                          ((> pos 0)
                           (set! pos-prod (* pos-prod pos))
                           (set! pos-count (+ pos-count 1)))
                          ((< neg 0)
                           (set! neg-prod (* neg-prod neg))
                           (set! neg-count (+ neg-count 1)))))))
                  (vector-ref adj u))
        (let ((c (vector-ref cost u)))
          (cond
            ((> c 0)
             (set! (vector-ref dp u 0) (* c pos-prod))
             (set! (vector-ref dp u 1) (if (> neg-count 0) (* c neg-prod) -inf.0)))
            ((< c 0)
             (set! (vector-ref dp u 0) (if (> neg-count 0) (* c neg-prod) -inf.0))
             (set! (vector-ref dp u 1) (* c pos-prod)))
            (else
             (set! (vector-ref dp u 0) 0)
             (set! (vector-ref dp u 1) 0)))
          (set-box! ans (max (unbox ans) (vector-ref dp u 0))))))

    (dfs 0 -1)
    (unbox ans)))