(define (minimum-operations target start nums)
  (define q (list start))
  (define visited (make-hash))
  (hash-set! visited start #t)
  (define steps 0)
  (define (is-valid? n)
    (and (>= n 0) (<= n 1000)))

  (let loop ()
    (if (null? q)
        -1
        (let* ((level-size (length q))
               (next-q '()))
          (for ((i (in-range level-size)))
            (let ((curr (car q)))
              (set! q (cdr q))
              (if (= curr target)
                  (return steps)
                  (for ((num (in-list nums)))
                    (let ((add (+ curr num))
                          (subtract (- curr num))
                          (xor (bitwise-xor curr num)))
                      (when (and (is-valid? add) (not (hash-ref visited add #f)))
                        (hash-set! visited add #t)
                        (set! next-q (append next-q (list add))))
                      (when (and (is-valid? subtract) (not (hash-ref visited subtract #f)))
                        (hash-set! visited subtract #t)
                        (set! next-q (append next-q (list subtract))))
                      (when (and (is-valid? xor) (not (hash-ref visited xor #f)))
                        (hash-set! visited xor #t)
                        (set! next-q (append next-q (list xor)))))))))
          (set! q next-q)
          (set! steps (+ steps 1))
          (loop)))))