(define (is-escape-possible blocked source target)
  (define blocked-set (set blocked))
  (define n 100000)
  (define (bfs start end)
    (define visited (set))
    (set-add! visited start)
    (define q (list start))
    (let loop ((q q))
      (cond
        [(null? q) #f]
        [else
         (define curr (car q))
         (define q (cdr q))
         (when (equal? curr end)
           (return #t))
         (define neighbors (list (list (+ (car curr) 1) (cadr curr))
                                (list (- (car curr) 1) (cadr curr))
                                (list (car curr) (+ (cadr curr) 1))
                                (list (car curr) (- (cadr curr) 1))))
         (define valid-neighbors
           (filter (lambda (neighbor)
                     (and (>= (car neighbor) 0)
                          (< (car neighbor) n)
                          (>= (cadr neighbor) 0)
                          (< (cadr neighbor) n)
                          (not (set-member? blocked-set neighbor))
                          (not (set-member? visited neighbor))))
                   neighbors))
         (for-each (lambda (neighbor)
                     (set-add! visited neighbor))
                   valid-neighbors)
         (loop (append q valid-neighbors))])))
  (and (bfs source target) (bfs target source)))