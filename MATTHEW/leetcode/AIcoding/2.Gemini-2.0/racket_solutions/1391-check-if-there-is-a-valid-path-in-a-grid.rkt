(define (has-valid-path grid)
  (define m (vector-length grid))
  (define n (vector-length (vector-ref grid 0)))
  (define visited (make-vector m (lambda (i) (make-vector n #f))))

  (define (valid-move? r c dir)
    (and (>= r 0) (< r m) (>= c 0) (< c n) (not (vector-ref (vector-ref visited r) c))
         (let ((cell (vector-ref (vector-ref grid r) c)))
           (match (list cell dir)
             ((list 1 'right) (or (= cell 1) (= cell 4) (= cell 6)))
             ((list 1 'left) (or (= cell 1) (= cell 3) (= cell 5)))
             ((list 1 'down) #f)
             ((list 1 'up) #f)
             ((list 2 'right) #f)
             ((list 2 'left) #f)
             ((list 2 'down) (or (= cell 2) (= cell 3) (= cell 4)))
             ((list 2 'up) (or (= cell 2) (= cell 5) (= cell 6)))
             ((list 3 'right) (or (= cell 1) (= cell 4) (= cell 6)))
             ((list 3 'left) #f)
             ((list 3 'down) #f)
             ((list 3 'up) (or (= cell 2) (= cell 5) (= cell 6)))
             ((list 4 'right) #f)
             ((list 4 'left) (or (= cell 1) (= cell 3) (= cell 5)))
             ((list 4 'down) (or (= cell 2) (= cell 3) (= cell 4)))
             ((list 4 'up) #f)
             ((list 5 'right) (or (= cell 1) (= cell 4) (= cell 6)))
             ((list 5 'left) #f)
             ((list 5 'down) (or (= cell 2) (= cell 3) (= cell 4)))
             ((list 5 'up) #f)
             ((list 6 'right) #f)
             ((list 6 'left) (or (= cell 1) (= cell 3) (= cell 5)))
             ((list 6 'down) #f)
             ((list 6 'up) (or (= cell 2) (= cell 5) (= cell 6)))
             (_ #f)))))

  (define (dfs r c)
    (cond
      ((and (= r (- m 1)) (= c (- n 1))) #t)
      (else
       (begin
         (vector-set! (vector-ref visited r) c #t)
         (or (and (valid-move? r c 'right) (dfs r (+ c 1)))
             (and (valid-move? r c 'left) (dfs r (- c 1)))
             (and (valid-move? r c 'down) (dfs (+ r 1) c))
             (and (valid-move? r c 'up) (dfs (- r 1) c)))))))

  (dfs 0 0))