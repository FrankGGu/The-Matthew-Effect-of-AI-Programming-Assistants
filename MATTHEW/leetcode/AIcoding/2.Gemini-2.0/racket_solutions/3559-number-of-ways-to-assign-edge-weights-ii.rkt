(define (number-of-ways-ii n edges)
  (let* ((adj (make-vector (add1 n) '()))
         (m (length edges))
         (mod 1000000007))
    (for-each (lambda (e)
                (let ((u (car e))
                      (v (cadr e))
                      (w (caddr e)))
                  (vector-set! adj u (cons (cons v w) (vector-ref adj u)))
                  (vector-set! adj v (cons (cons u w) (vector-ref adj v))))) edges)

    (define (dfs u parent color)
      (if (vector-ref colors u)
          (if (= (vector-ref colors u) color)
              #t
              #f)
          (begin
            (vector-set! colors u color)
            (let loop ((neighbors (vector-ref adj u)))
              (if (null? neighbors)
                  #t
                  (let ((neighbor (caar neighbors))
                        (weight (cdar neighbors)))
                    (if (= neighbor parent)
                        (loop (cdr neighbors))
                        (if (= weight 0)
                            (if (dfs neighbor u (if (= color 1) 2 1))
                                (loop (cdr neighbors))
                                #f)
                            (if (dfs neighbor u color)
                                (loop (cdr neighbors))
                                #f)))))))))

    (let ((colors (make-vector (add1 n) #f)))
      (define (count-components)
        (let loop ((i 1)
                   (count 0))
          (cond
            ((> i n) count)
            ((not (vector-ref colors i))
             (if (dfs i 0 1)
                 (loop (add1 i) (add1 count))
                 (error "Not Bipartite")))
            (else (loop (add1 i) count)))))

      (let ((num-components (count-components))
            (num-zeroes (length (filter (lambda (e) (= (caddr e) 0)) edges))))
        (if (> num-components 1)
            (let loop ((i 0)
                       (result 1))
              (if (= i num-zeroes)
                  result
                  (loop (add1 i) (modulo (* result 3) mod))))
            (let ((num-one (length (filter (lambda (e) (= (caddr e) 1)) edges)))
                  (num-two (length (filter (lambda (e) (= (caddr e) 2)) edges))))
              (if (and (> num-one 0) (> num-two 0) (= num-zeroes 0))
                  1
                  0)))))))