(define (can-catch? n edges startA startB)
  (let ((graph (make-vector (add1 n) '())))
    (for-each (lambda (edge)
                (let ((u (car edge)) (v (cdr edge)))
                  (vector-set! graph u (cons v (vector-ref graph u)))
                  (vector-set! graph v (cons u (vector-ref graph v)))))
              edges)
    (letrec ((bfs (lambda (start)
                    (let ((dist (make-vector (add1 n) #f))
                          (queue (list start)))
                      (vector-set! dist start 0)
                      (let loop ()
                        (if (null? queue)
                            dist
                            (let ((u (car queue))
                                  (new-queue (cdr queue)))
                              (for-each (lambda (v)
                                          (unless (vector-ref dist v)
                                            (vector-set! dist v (add1 (vector-ref dist u)))
                                            (set! new-queue (append new-queue (list v)))))
                                        (vector-ref graph u))
                              (set! queue new-queue)
                              (loop)))))))
           (bob-dist (bfs startB))
           (alice-dist (bfs 1)))
      (let loop ((i 1))
        (cond ((> i n) #f)
              ((and (vector-ref bob-dist i)
                    (>= (vector-ref bob-dist i) (vector-ref alice-dist i))
                    (not (= i startA))) #t)
              (else (loop (add1 i))))))))