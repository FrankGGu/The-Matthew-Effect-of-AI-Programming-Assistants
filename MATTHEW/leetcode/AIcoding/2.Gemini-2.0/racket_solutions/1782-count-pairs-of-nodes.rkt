(define (count-pairs n edges queries)
  (define degrees (make-vector (add1 n) 0))
  (define shared (make-hash))
  (for-each (lambda (edge)
              (let ((u (min (car edge) (cdr edge)))
                    (v (max (car edge) (cdr edge))))
                (vector-set! degrees u (add1 (vector-ref degrees u)))
                (vector-set! degrees v (add1 (vector-ref degrees v)))
                (hash-update! shared (cons u v) (lambda (x) (add1 x)) 1)))
            edges)
  (define sorted-degrees (sort (vector->list degrees) < #:start 1))
  (map (lambda (query)
         (let loop ((i 1) (j n) (count 0))
           (cond
             ((>= i j) count)
             ((>= (+ (list-ref sorted-degrees (sub1 i)) (list-ref sorted-degrees (sub1 j))) query)
              (loop i (sub1 j) count))
             (else
              (loop (add1 i) j (add1 count)))))
         (let ((total (let loop ((i 1) (j n) (count 0))
                        (cond
                          ((>= i j) count)
                          ((>= (+ (list-ref sorted-degrees (sub1 i)) (list-ref sorted-degrees (sub1 j))) query)
                           (loop i (sub1 j) count))
                          (else
                           (loop (add1 i) j (add1 count)))))))
           (for/fold ((result total)) ((pair (hash-keys shared)))
             (let ((u (car pair))
                   (v (cdr pair))
                   (common (hash-ref shared pair)))
               (if (and (>= (+ (vector-ref degrees u) (vector-ref degrees v)) query)
                        (< (+ (vector-ref degrees u) (vector-ref degrees v) common) query))
                   (sub1 result)
                   result)))))
       queries))