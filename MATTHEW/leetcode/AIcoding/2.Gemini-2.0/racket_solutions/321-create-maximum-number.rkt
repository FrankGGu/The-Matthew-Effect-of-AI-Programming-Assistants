(define (max-number nums1 nums2 k)
  (letrec ((merge (lambda (a b)
                    (cond ((null? a) b)
                          ((null? b) a)
                          (else (if (greater-equal a b)
                                    (cons (car a) (merge (cdr a) b))
                                    (cons (car b) (merge a (cdr b))))))))
           (greater-equal (lambda (a b)
                             (cond ((null? a) #f)
                                   ((null? b) #t)
                                   ((> (car a) (car b)) #t)
                                   ((< (car a) (car b)) #f)
                                   (else (greater-equal (cdr a) (cdr b))))))
           (max-array (lambda (nums len)
                        (let loop ((i 0) (stack '()))
                          (if (= i (length nums))
                              stack
                              (let ((num (list-ref nums i)))
                                (if (and (not (null? stack))
                                         (> (- (length nums) i) (- len (length stack)))
                                         (< (car (last stack)) num))
                                    (loop i (drop-right stack 1))
                                    (if (< (length stack) len)
                                        (loop (+ i 1) (append stack (list num)))
                                        (loop (+ i 1) stack))))))))

    (let loop ((i 0) (max-so-far '()))
      (if (> i k)
          max-so-far
          (let ((len1 i)
                (len2 (- k i)))
            (if (and (>= len1 0) (<= len1 (length nums1))
                     (>= len2 0) (<= len2 (length nums2)))
                (let ((arr1 (max-array nums1 len1))
                      (arr2 (max-array nums2 len2))
                      (merged (merge arr1 arr2)))
                  (if (greater-equal merged max-so-far)
                      (loop (+ i 1) merged)
                      (loop (+ i 1) max-so-far)))
                (loop (+ i 1) max-so-far)))))))