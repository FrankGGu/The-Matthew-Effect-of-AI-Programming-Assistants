(define (constrained-subset-sum nums k)
  (let* ((n (length nums))
         (dp (make-vector n -inf.0))
         (queue (make-queue)))
    (vector-set! dp 0 (vector-ref nums 0))
    (enqueue! queue 0)
    (for/fold (max-sum (vector-ref nums 0))
              ((i (in-range 1 n)))
      (when (and (not (queue-empty? queue))
                 (> (- i (queue-peek queue)) k))
        (dequeue! queue))
      (let ((curr-sum (vector-ref nums i)))
        (when (not (queue-empty? queue))
          (let ((top-index (queue-peek queue)))
            (set! curr-sum (max curr-sum (+ (vector-ref nums i) (vector-ref dp top-index))))))
        (vector-set! dp i curr-sum)

        (while (and (not (queue-empty? queue))
                    (<= (vector-ref dp (queue-peek-last queue)) curr-sum))
          (dequeue-last! queue))

        (enqueue-last! queue i)
        (max max-sum curr-sum)))))