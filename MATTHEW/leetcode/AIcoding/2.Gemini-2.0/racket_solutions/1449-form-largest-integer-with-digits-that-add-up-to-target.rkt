(define (largest-integer digits target)
  (letrec ((dp (make-vector (+ 1 target) "")))
    (vector-set! dp 0 "")
    (for ((i (in-range 1 (+ 1 target))))
      (for ((d digits))
        (let ((cost (car d))
              (digit (cdr d)))
          (when (>= i cost)
            (let ((prev (vector-ref! dp (- i cost))))
              (when (not (string=? prev ""))
                (let ((new-str (string-append prev (number->string digit))))
                  (let ((curr (vector-ref! dp i)))
                    (when (or (string=? curr "")
                              (> (string-length new-str) (string-length curr))
                              (and (= (string-length new-str) (string-length curr))
                                   (string>? new-str curr)))
                      (vector-set! dp i new-str))))))))))
    (vector-ref! dp target)))
(define (form-largest-integer cost)
  (let ((digits (list (cons (car cost) 9) (cons (cadr cost) 8) (cons (caddr cost) 7)
                      (cons (cadddr cost) 6) (cons (list-ref cost 4) 5) (cons (list-ref cost 5) 4)
                      (cons (list-ref cost 6) 3) (cons (list-ref cost 7) 2) (cons (list-ref cost 8) 1))))
    (let ((result (largest-integer digits (vector-length cost))))
      (if (string=? result "")
          "0"
          result))))