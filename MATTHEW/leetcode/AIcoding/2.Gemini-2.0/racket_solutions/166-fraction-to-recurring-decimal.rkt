(define (fraction-to-recurring-decimal numerator denominator)
  (if (= numerator 0)
      "0"
      (let* ((sign (if (or (< numerator 0) (< denominator 0))
                       (if (and (< numerator 0) (< denominator 0)) "" "-")
                       "-")
                       ""))
        (let* ((numerator (abs numerator))
               (denominator (abs denominator))
               (integer-part (quotient numerator denominator))
               (remainder (remainder numerator denominator))
               (decimal-part "")
               (remainders '())
               (indices '()))
          (if (= remainder 0)
              (string-append sign (number->string integer-part))
              (let loop ((remainder remainder) (index 0))
                (cond
                  ((= remainder 0)
                   (string-append sign (number->string integer-part) "." decimal-part))
                  ((member remainder remainders)
                   (let* ((recurring-index (list-ref indices (index-of remainder remainders))))
                     (string-append sign (number->string integer-part) "." (substring decimal-part 0 recurring-index) "(" (substring decimal-part recurring-index) ")")))
                  (else
                   (let* ((new-remainder (* remainder 10))
                          (digit (quotient new-remainder denominator))
                          (new-remainder (remainder new-remainder denominator)))
                     (set! decimal-part (string-append decimal-part (number->string digit)))
                     (set! remainders (append remainders (list remainder)))
                     (set! indices (append indices (list index)))
                     (loop new-remainder (+ index 1)))))))))))

(define (index-of item lst)
  (let loop ((lst lst) (index 0))
    (cond
      ((null? lst) #f)
      ((equal? (car lst) item) index)
      (else (loop (cdr lst) (+ index 1))))))