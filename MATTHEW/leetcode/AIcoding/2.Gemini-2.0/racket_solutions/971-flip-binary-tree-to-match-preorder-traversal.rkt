(define (flipMatchVoyage root voyage)
  (let ((flipped '()))
    (define (dfs node i)
      (cond
        [(null? node) i]
        [(= (car voyage) (node->val node))
         (let ((next-i (+ i 1)))
           (if (and (not (null? (node->left node)))
                    (not (null? (node->right node)))
                    (not (= (node->left node) #f))
                    (not (= (node->right node) #f))
                    (not (= (node->val (node->left node)) (list-ref voyage next-i))))
               (begin
                 (set! flipped (cons (node->val node) flipped))
                 (let ((temp (node->left node)))
                   (set-node->left! node (node->right node))
                   (set-node->right! node temp))
                 (dfs (node->left node) next-i))
               (dfs (node->left node) next-i)))
         (dfs (node->right node) (dfs (node->left node) (+ i 1))))
        [else (list -1)]))
    (let ((result (dfs root 0)))
      (if (equal? result (list -1))
          (list -1)
          (reverse flipped)))))