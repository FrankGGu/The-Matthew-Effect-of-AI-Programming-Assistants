(define (find-edges-in-shortest-paths n edges)
  (define adj (make-vector n '()))
  (for ([edge edges])
    (let ([u (car edge)] [v (cadr edge)])
      (vector-set! adj u (cons v (vector-ref adj u)))
      (vector-set! adj v (cons u (vector-ref adj v)))))

  (define dist (make-vector n #f))
  (define count (make-vector n #f))

  (define (bfs start)
    (vector-set! dist start 0)
    (vector-set! count start 1)
    (define q (list start))
    (define visited (make-vector n #f))
    (vector-set! visited start #t)

    (while (not (null? q))
      (let ([u (car q)])
        (set! q (cdr q))
        (for ([v (vector-ref adj u)])
          (if (not (vector-ref visited v))
              (begin
                (vector-set! visited v #t)
                (vector-set! dist v (+ 1 (vector-ref dist u)))
                (vector-set! count v (vector-ref count u))
                (set! q (append q (list v))))
              (if (= (vector-ref dist v) (+ 1 (vector-ref dist u)))
                  (vector-set! count v (+ (vector-ref count v) (vector-ref count u))))))))
    (values dist count))

  (define (is-shortest-path-edge? u v)
    (let-values ([(dist-u count-u) (bfs u)])
      (if (and (vector-ref dist-u v)
               (= (vector-ref dist-u v) 1))
          (= (vector-ref count-u v) 1)
          (let-values ([(dist-v count-v) (bfs v)])
             (and (vector-ref dist-v u)
               (= (vector-ref dist-v u) 1)
               (= (vector-ref count-v u) 1))))))

  (filter (lambda (edge)
            (is-shortest-path-edge? (car edge) (cadr edge)))
          edges))