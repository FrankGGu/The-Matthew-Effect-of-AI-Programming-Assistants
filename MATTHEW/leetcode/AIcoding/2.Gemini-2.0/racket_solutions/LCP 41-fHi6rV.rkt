(define (flip-game board)
  (define n (vector-length board))
  (define (is-valid? row col)
    (and (>= row 0) (< row n) (>= col 0) (< col n)))
  (define (get-neighbors row col)
    (filter (lambda (pos) (is-valid? (car pos) (cdr pos)))
            (list (cons (+ row 1) col)
                  (cons (- row 1) col)
                  (cons row (+ col 1))
                  (cons row (- col 1)))))
  (define (flip-board board row col)
    (define new-board (vector-copy board))
    (vector-set! new-board row (vector-copy (vector-ref board row)))
    (vector-set! (vector-ref new-board row) col (if (equal? (vector-ref (vector-ref board row) col) "X") "O" "X"))
    (for-each (lambda (neighbor)
                (let ((r (car neighbor)) (c (cdr neighbor)))
                  (when (equal? (vector-ref (vector-ref board r) c) (vector-ref (vector-ref board row) col))
                    (vector-set! (vector-ref new-board r) c (if (equal? (vector-ref (vector-ref board r) c) "X") "O" "X")))))
              (get-neighbors row col))
    new-board)

  (define (count-x board)
    (let loop ((row 0) (count 0))
      (if (= row n)
          count
          (loop (+ row 1) (+ count (foldl (lambda (x acc) (if (equal? x "X") (+ acc 1) acc)) 0 (vector->list (vector-ref board row))))))))

  (define (min-x board)
    (let loop ((row 0) (col 0) (min-val +inf.0))
      (cond
        ((= row n) min-val)
        ((= col n) (loop (+ row 1) 0 min-val))
        ((equal? (vector-ref (vector-ref board row) col) "O") (loop row (+ col 1) min-val))
        (else (loop row (+ col 1) (min min-val (count-x (flip-board board row col))))))))

  (min-x board))