(define (minimum-score-after-removals edges values)
  (define n (length values))
  (define adj (make-vector n null))
  (for-each (lambda (edge)
              (let ((u (car edge)) (v (cadr edge)))
                (vector-set! adj u (cons v (vector-ref adj u)))
                (vector-set! adj v (cons u (vector-ref adj v)))))
            edges)

  (define subtree-xor (make-vector n 0))
  (define parent (make-vector n -1))
  (define depth (make-vector n 0))

  (define (dfs u p d)
    (vector-set! parent u p)
    (vector-set! depth u d)
    (vector-set! subtree-xor u (vector-ref values u))
    (for-each (lambda (v)
                (when (not (= v p))
                  (dfs v u (+ d 1))
                  (vector-set! subtree-xor u (bitwise-xor (vector-ref subtree-xor u) (vector-ref subtree-xor v)))))
              (vector-ref adj u)))

  (dfs 0 -1 0)

  (define (is-ancestor? u v)
    (and (> (vector-ref depth v) (vector-ref depth u))
         (let loop ((curr v))
           (cond ((= curr u) #t)
                 ((= curr 0) #f)
                 (else (loop (vector-ref parent curr)))))))

  (define (get-xor u v)
    (if (is-ancestor? u v)
        (bitwise-xor (vector-ref subtree-xor v)
                     (vector-ref subtree-xor u))
        (bitwise-xor (vector-ref subtree-xor 0)
                     (bitwise-xor (vector-ref subtree-xor u)
                                  (vector-ref subtree-xor v)))))

  (define (calculate-score a b c)
    (define x (list a b c))
    (- (apply max x) (apply min x)))

  (define min-score +inf.0)
  (for* ([i (range 1 n)]
         [j (range (+ i 1) n)])
    (let ((u i) (v j))
      (when (not (= (vector-ref parent u) -1))
        (when (not (= (vector-ref parent v) -1))
          (let ((xor1 (vector-ref subtree-xor u))
                (xor2 (vector-ref subtree-xor v)))
            (if (is-ancestor? u v)
                (let ((xor1 (vector-ref subtree-xor u))
                      (xor2 (get-xor u v))
                      (xor3 (vector-ref subtree-xor v)))
                  (set! min-score (min min-score (calculate-score xor1 xor2 xor3))))
                (if (is-ancestor? v u)
                    (let ((xor1 (get-xor v u))
                          (xor2 (vector-ref subtree-xor u))
                          (xor3 (vector-ref subtree-xor v)))
                      (set! min-score (min min-score (calculate-score xor1 xor2 xor3))))
                    (let ((xor1 (vector-ref subtree-xor u))
                          (xor2 (vector-ref subtree-xor v))
                          (xor3 (get-xor u v)))
                      (set! min-score (min min-score (calculate-score xor1 xor2 xor3)))))))))))
  (exact->inexact min-score))