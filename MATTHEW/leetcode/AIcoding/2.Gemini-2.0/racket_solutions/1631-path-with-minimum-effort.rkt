(define (minimum-effort-path heights)
  (define rows (length heights))
  (define cols (length (first heights)))
  (define dist (make-vector (* rows cols) +inf.0))
  (vector-set! dist 0 0)
  (define pq (make-heap (λ (a b) (< (vector-ref dist a) (vector-ref dist b)))))
  (heap-add! pq 0)

  (define (index r c) (+ (* r cols) c))

  (define (valid-neighbor? r c)
    (and (>= r 0) (< r rows) (>= c 0) (< c cols)))

  (define (neighbors r c)
    (filter (λ (neighbor) (valid-neighbor? (first neighbor) (second neighbor)))
            (list (list (- r 1) c) (list (+ r 1) c) (list r (- c 1)) (list r (+ c 1)))))

  (define (effort r c nr nc)
    (abs (- (list-ref (list-ref heights r) c) (list-ref (list-ref heights nr) nc))))

  (let loop ()
    (if (heap-empty? pq)
        (vector-ref dist (- (* rows cols) 1))
        (let ((u (heap-remove-min! pq)))
          (let ((ur (quotient u cols))
                (uc (remainder u cols)))
            (for-each (λ (neighbor)
                        (let ((vr (first neighbor))
                              (vc (second neighbor))
                              (v (index vr vc)))
                          (let ((new-effort (max (vector-ref dist u) (effort ur uc vr vc))))
                            (when (< new-effort (vector-ref dist v))
                              (vector-set! dist v new-effort)
                              (heap-add! pq v)))))
                      (neighbors ur uc))
            (loop))))))