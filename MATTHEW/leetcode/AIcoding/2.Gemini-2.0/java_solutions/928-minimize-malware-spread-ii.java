class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        int[] clean = new int[n];
        for (int i = 0; i < n; i++) {
            clean[i] = 1;
        }
        for (int node : initial) {
            clean[node] = 0;
        }

        int[] component = new int[n];
        int compId = 0;
        Map<Integer, Integer> compSize = new HashMap<>();
        Arrays.fill(component, -1);

        for (int i = 0; i < n; i++) {
            if (clean[i] == 1 && component[i] == -1) {
                Queue<Integer> q = new LinkedList<>();
                q.offer(i);
                component[i] = compId;
                int size = 0;
                while (!q.isEmpty()) {
                    int u = q.poll();
                    size++;
                    for (int v = 0; v < n; v++) {
                        if (clean[v] == 1 && graph[u][v] == 1 && component[v] == -1) {
                            component[v] = compId;
                            q.offer(v);
                        }
                    }
                }
                compSize.put(compId, size);
                compId++;
            }
        }

        int[] contribution = new int[n];
        for (int node : initial) {
            Set<Integer> seen = new HashSet<>();
            for (int neighbor = 0; neighbor < n; neighbor++) {
                if (clean[neighbor] == 1 && graph[node][neighbor] == 1 && !seen.contains(component[neighbor])) {
                    contribution[component[neighbor]]++;
                    seen.add(component[neighbor]);
                }
            }
        }

        int best = -1;
        int bestSize = -1;
        Arrays.sort(initial);
        for (int node : initial) {
            int size = 0;
            Set<Integer> seen = new HashSet<>();
            for (int neighbor = 0; neighbor < n; neighbor++) {
                if (clean[neighbor] == 1 && graph[node][neighbor] == 1 && !seen.contains(component[neighbor]) && contribution[component[neighbor]] == 1) {
                    size += compSize.get(component[neighbor]);
                    seen.add(component[neighbor]);
                }
            }
            if (size > bestSize) {
                bestSize = size;
                best = node;
            }
        }

        if (bestSize == -1) {
            return initial[0];
        }
        return best;
    }
}