#include <vector>
#include <algorithm>

using namespace std;

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<bool> infected(n, false);
        for (int node : initial) {
            infected[node] = true;
        }

        int minNode = -1;
        int maxSaved = -1;

        for (int nodeToRemove : initial) {
            vector<bool> tempInfected = infected;
            tempInfected[nodeToRemove] = false;

            vector<int> currentInfected;
            for (int i = 0; i < n; ++i) {
                if (tempInfected[i]) {
                    currentInfected.push_back(i);
                }
            }

            vector<bool> visited(n, false);
            vector<int> q;
            for (int infectedNode : currentInfected) {
                if (!visited[infectedNode]) {
                    q.push_back(infectedNode);
                    visited[infectedNode] = true;
                }
            }

            int head = 0;
            while (head < q.size()) {
                int u = q[head++];
                for (int v = 0; v < n; ++v) {
                    if (graph[u][v] == 1 && !visited[v]) {
                        q.push_back(v);
                        visited[v] = true;
                    }
                }
            }

            int numInfected = 0;
            for (int i = 0; i < n; ++i) {
                if (visited[i]) {
                    numInfected++;
                }
            }

            int saved = 0;
            int initialInfectedSize = 0;
            for(int i=0; i<n; ++i){
                if(infected[i]) initialInfectedSize++;
            }

            vector<bool> initialVisit(n,false);
            q.clear();

            for (int infectedNode : initial) {
                if (!initialVisit[infectedNode]) {
                    q.push_back(infectedNode);
                    initialVisit[infectedNode] = true;
                }
            }

            head = 0;
            while (head < q.size()) {
                int u = q[head++];
                for (int v = 0; v < n; ++v) {
                    if (graph[u][v] == 1 && !initialVisit[v]) {
                        q.push_back(v);
                        initialVisit[v] = true;
                    }
                }
            }

            int initialNumInfected = 0;
            for (int i = 0; i < n; ++i) {
                if (initialVisit[i]) {
                    initialNumInfected++;
                }
            }

            saved = initialNumInfected - numInfected;

            if (saved > maxSaved) {
                maxSaved = saved;
                minNode = nodeToRemove;
            } else if (saved == maxSaved) {
                if (minNode == -1 || nodeToRemove < minNode) {
                    minNode = nodeToRemove;
                }
            }
        }

        if (minNode == -1) {
            minNode = *min_element(initial.begin(), initial.end());
        }

        return minNode;
    }
};