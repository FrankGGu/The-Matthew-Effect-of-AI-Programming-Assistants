(define (canFinish numCourses prerequisites queries)
  (define graph (make-vector numCourses '()))
  (define indegree (make-vector numCourses 0))
  (for-each (lambda (p)
              (vector-set! graph (car p) (cons (cadr p) (vector-ref graph (car p))))
              (vector-set! indegree (cadr p) (+ 1 (vector-ref indegree (cadr p)))))
            prerequisites)

  (define (topological-sort)
    (define queue (make-queue))
    (define visited (make-vector numCourses #f))
    (for ([i (in-range numCourses)])
      (when (= (vector-ref indegree i) 0)
        (enqueue queue i)))
    (define result '())
    (while (not (queue-empty? queue))
      (define node (dequeue queue))
      (set! visited node #t)
      (set! result (cons node result))
      (for-each (lambda (neighbor)
                  (vector-set! indegree neighbor (- (vector-ref indegree neighbor) 1))
                  (when (= (vector-ref indegree neighbor) 0)
                    (enqueue queue neighbor)))
                (vector-ref graph node)))
    (reverse result))

  (define topo (topological-sort))
  (define reachable (make-vector numCourses (make-vector numCourses #f)))
  (for-each (lambda (course)
              (for-each (lambda (n)
                          (vector-set! (vector-ref reachable course) n #t))
                        (take-while (lambda (x) (not (null? x))) topo)))
            topo)
  (map (lambda (q)
         (vector-ref (vector-ref reachable (car q)) (cadr q)))
       queries))

(define (make-queue)
  (list '()))

(define (enqueue queue item)
  (set-cdr! queue (cons item (cdr queue)))

(define (dequeue queue)
  (if (null? (cdr queue))
      (error "Queue is empty")
      (let ((item (car (cdr queue))))
        (set-cdr! queue (cdr (cdr queue)))
        item)))

(define (queue-empty? queue)
  (null? (cdr queue)))