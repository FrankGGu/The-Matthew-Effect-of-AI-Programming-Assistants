(define (min-cost-path special-roads start end)
  (define (dijkstra graph start end)
    (define distances (make-vector (length graph) +inf.0))
    (define visited (make-vector (length graph) #f))
    (vector-set! distances start 0)
    (define queue (list (cons 0 start)))

    (let loop ()
      (if (null? queue)
          (vector-ref distances end)
          (let* ((current (car queue))
                 (current-cost (car current))
                 (current-node (cdr current)))
            (if (vector-ref visited current-node)
                (loop)
                (begin
                  (vector-set! visited current-node #t)
                  (for-each (lambda (neighbor)
                              (let ((cost (cdr neighbor))
                                    (next-node (car neighbor)))
                                (when (< (+ current-cost cost)
                                          (vector-ref distances next-node))
                                  (vector-set! distances next-node
                                                (+ current-cost cost))
                                  (set! queue (cons (cons (+ current-cost cost) next-node) (cdr queue)))))
                            (vector-ref graph current-node))
                  (loop))))))

  (define graph (make-vector (add1 (length special-roads))))
  (for-each (lambda (road)
              (let ((u (car road))
                    (v (cadr road))
                    (cost (caddr road)))
                (vector-set! graph u (cons (cons v cost) (vector-ref graph u)))
                (vector-set! graph v (cons (cons u cost) (vector-ref graph v)))))
            special-roads)

  (dijkstra graph start end))