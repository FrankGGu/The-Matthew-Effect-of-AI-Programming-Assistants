(define (findWords board words)
  (define trie (make-trie words))
  (define (search i j node path result)
    (define char (list-ref (list-ref board i) j))
    (when (and (not (null? char)) (hash-has? node char))
      (define next-node (hash-ref node char))
      (define word (hash-ref next-node 'word))
      (when word
        (set! result (cons word result))
        (hash-set! next-node 'word #f))
      (hash-set! board i (list-set (list-ref board i) j #f))
      (for-each (lambda (d)
                  (let ((ni (+ i (car d))) (nj (+ j (cadr d))))
                    (when (and (>= ni 0) (< ni (length board))
                               (>= nj 0) (< nj (length (list-ref board ni))))
                      (search ni nj next-node path result))))
                '((1 0) (-1 0) (0 1) (0 -1)))
      (hash-set! board i (list-set (list-ref board i) j char)))

  (define (make-trie words)
    (define trie (make-hash))
    (for-each (lambda (word)
                (define curr trie)
                (for-each (lambda (ch)
                            (if (not (hash-has? curr ch))
                                (hash-set! curr ch (make-hash)))
                            (set! curr (hash-ref curr ch)))
                          (string->list word))
                (hash-set! curr 'word word))
              words)
    trie)

  (define result '())
  (for-each (lambda (i)
              (for-each (lambda (j)
                          (let ((start-node (hash-ref trie (list-ref (list-ref board i) j) #f)))
                                (when start-node
                                  (search i j start-node '() result))))
                        (range (length (list-ref board i)))))
            (range (length board)))
  (reverse result))