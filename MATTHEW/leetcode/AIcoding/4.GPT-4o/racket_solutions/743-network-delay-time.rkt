(define (networkDelayTime times n k)
  (define graph (make-vector (add1 n) '()))
  (for-each (lambda (time)
              (let ((u (vector-ref time 0))
                    (v (vector-ref time 1))
                    (w (vector-ref time 2)))
                (vector-set! graph u (cons (list v w) (vector-ref graph u)))))
            times)

  (define distances (make-vector (add1 n) +inf.0))
  (vector-set! distances k 0)

  (define queue (vector (list k 0)))

  (define (dijkstra)
    (while (not (null? queue))
      (define (extract-min)
        (let loop ((min (car queue)) (rest (cdr queue)))
          (if (null? rest)
              min
              (let ((current (car rest)))
                (if (< (cadr current) (cadr min))
                    (loop current (cdr rest))
                    (loop min (cdr rest))))))
      (define min (extract-min))
      (set! queue (filter (lambda (x) (not (= (car x) (car min)))) queue))
      (for-each (lambda (neighbor)
                  (let ((v (car neighbor))
                        (weight (cadr neighbor)))
                    (let ((new-dist (+ (cadr min) weight)))
                      (when (< new-dist (vector-ref distances v))
                        (vector-set! distances v new-dist)
                        (set! queue (cons (list v new-dist) queue))))))
                (vector-ref graph (car min))))

  (dijkstra)
  (define max-distance (apply max (map (lambda (x) (if (= x +inf.0) 0 x)) (vector->list (vector-slice distances 1 (add1 n))))))
  (if (= max-distance 0) -1 max-distance))