(define (calcEquation equations values queries)
  (define graph (make-hash))
  (for-each (lambda (eq)
              (let* ((a (first eq))
                     (b (second eq))
                     (val (car (filter (lambda (v) (equal? (second v) b)) values))))
                     (value (if val (first val) 1)))
                (hash-set! graph a (cons (cons b value) (hash-ref graph a '())))
                (hash-set! graph b (cons (cons a (/ 1 value)) (hash-ref graph b '())))))
            equations)
  (define (dfs start end visited)
    (if (or (not (hash-has-key? graph start))
            (not (hash-has-key? graph end)))
        -1.0
        (let loop ((neighbors (hash-ref graph start))
                   (visited (cons start visited)))
          (if (null? neighbors)
              -1.0
              (let ((next (car neighbors))
                    (rest (cdr neighbors)))
                (if (equal? (car next) end)
                    (cdr next)
                    (if (member (car next) visited)
                        (loop rest visited)
                        (let ((result (dfs (car next) end visited)))
                          (if (not (= result -1.0))
                              (* (cdr next) result)
                              (loop rest visited))))))))))
  (map (lambda (query)
         (dfs (first query) (second query) '()))
       queries))