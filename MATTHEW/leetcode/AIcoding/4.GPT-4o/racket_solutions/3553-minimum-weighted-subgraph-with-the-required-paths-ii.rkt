#lang racket

(define (minimumWeightedSubgraph n edges requiredEdges)
  (define graph (make-vector n (lambda () (vector))))
  (for ([edge edges])
    (define u (first edge))
    (define v (second edge))
    (define w (third edge))
    (vector-set! (vector-ref graph u) v w)
    (vector-set! (vector-ref graph v) u w))

  (define (dijkstra start)
    (define distances (make-vector n +inf.0))
    (define visited (make-vector n #f))
    (vector-set! distances start 0)
    (define queue (make-priority-queue))
    (pq-insert! queue (list 0 start))

    (define (visit)
      (when (not (pq-empty? queue))
        (define (values (pq-extract-min! queue)))
        (define dist (first values))
        (define node (second values))
        (when (not (vector-ref visited node))
          (vector-set! visited node #t)
          (for ([v (vector->list (vector-ref graph node))])
            (when (and (not (vector-ref visited v))
                       (< (+ dist (vector-ref (vector-ref graph node) v)) (vector-ref distances v)))
              (vector-set! distances v (+ dist (vector-ref (vector-ref graph node) v)))
              (pq-insert! queue (list (vector-ref distances v) v))))
          (visit)))
    (visit)
    distances)

  (define requiredPaths (map (λ (edge) (list (first edge) (second edge))) requiredEdges))
  (define totalWeight (apply + (map (λ (edge) (third edge)) requiredEdges)))

  (define minWeight +inf.0)
  (for ([edge requiredPaths])
    (define u (first edge))
    (define v (second edge))
    (define distances (dijkstra u))
    (when (< (vector-ref distances v) +inf.0)
      (define weight (+ (vector-ref distances v) (third edge)))
      (set! minWeight (min minWeight weight))))

  (if (= minWeight +inf.0) -1 minWeight))

(define (minimumWeightedSubgraph-main)
  (define n 5)
  (define edges '((0 1 1) (0 2 2) (1 2 1) (1 3 3) (2 4 1) (3 4 1)))
  (define requiredEdges '((0 1) (0 2) (1 3)))
  (minimumWeightedSubgraph n edges requiredEdges))

(minimumWeightedSubgraph-main)