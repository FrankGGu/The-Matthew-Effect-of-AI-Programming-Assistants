(define (slidingPuzzle board)
  (define (to-string b)
    (apply string-append (map number->string (apply append b))))

  (define (neighbors state)
    (define empty (string-index state #\0))
    (define moves '((1 0) (-1 0) (0 1) (0 -1)))
    (define width 3)
    (define height 2)
    (define result '())
    (for ([move moves])
      (define new-empty (let-values ([(dx dy) move])
                           (+ empty (if (= (modulo empty width) 0)
                                        (if (= dx -1) -1 (if (= dx 1) 1 0))
                                        (if (= dx -1) -1 (if (= dx 1) 1 0) (+ (* dx width) dy))))))
      (when (and (>= new-empty 0) (< new-empty (* width height)))
        (define new-state (string->list state))
        (define temp (list-ref new-state empty))
        (set! (list-ref new-state empty) (list-ref new-state new-empty))
        (set! (list-ref new-state new-empty) temp)
        (set! result (cons (list->string new-state) result))))
    result)

  (define (bfs start goal)
    (define visited (make-hash))
    (define queue (list start))
    (define steps 0)
    (hash-set! visited start #t)
    (while (not (null? queue))
      (define next-queue '())
      (for ([state queue])
        (when (equal? state goal)
          (return steps))
        (for ([n (neighbors state)])
          (unless (hash-has-key? visited n)
            (hash-set! visited n #t)
            (set! next-queue (cons n next-queue)))))
      (set! queue next-queue)
      (set! steps (+ steps 1)))
    -1)

  (bfs (to-string (apply append board)) "123450"))