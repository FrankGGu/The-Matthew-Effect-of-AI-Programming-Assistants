(define (min-cost-timing n edges time)
  (define graph (make-vector n '()))
  (for-each (lambda (edge)
              (let ((u (car edge))
                    (v (cadr edge))
                    (cost (caddr edge))
                    (duration (cadddr edge)))
                (vector-set! graph u (cons (list v cost duration) (vector-ref graph u)))))
            edges)

  (define (dijkstra)
    (define costs (make-vector n +inf.0))
    (define pq (make-queue))
    (vector-set! costs 0 0)
    (enqueue pq (list 0 0)) ; (cost, node)

    (define (process-queue)
      (when (not (empty? pq))
        (define current (dequeue pq))
        (define current-cost (car current))
        (define current-node (cadr current))

        (for-each (lambda (neighbor)
                    (define next-node (car neighbor))
                    (define cost (cadr neighbor))
                    (define duration (caddr neighbor))
                    (define new-cost (+ current-cost cost))
                    (define new-time (+ (vector-ref costs current-node) duration))

                    (when (and (< new-cost (vector-ref costs next-node))
                               (<= new-time time))
                      (vector-set! costs next-node new-cost)
                      (enqueue pq (list new-cost next-node))))
                  (vector-ref graph current-node))
        (process-queue)))

    (process-queue)
    (define final-cost (vector-ref costs (- n 1)))
    (if (= final-cost +inf.0) -1 final-cost))

  (dijkstra))