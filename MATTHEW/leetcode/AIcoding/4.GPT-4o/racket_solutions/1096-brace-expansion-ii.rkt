(define (braceExpansionII expression)
  (define (expand parts)
    (if (null? parts)
        (list "")
        (let loop ((results '()))
          (for-each (lambda (part)
                      (for-each (lambda (prefix)
                                  (for-each (lambda (suffix)
                                              (set! results (cons (string-append prefix suffix) results)))
                                            (if (string? part)
                                                (list part)
                                                (expand part))))
                                (if (string? (car parts))
                                    (list (car parts))
                                    (expand (car parts)))))
                    parts)
          (remove-duplicates results)))

  (define (parse expression)
    (define (helper expr stack current)
      (cond
        ((null? expr) (list (apply string-append (reverse current))))
        ((char=? (car expr) #\{)
         (let loop ((rest (cdr expr)) (nested 1) (temp '()))
           (cond
             ((null? rest) '())
             ((char=? (car rest) #\{) (loop (cdr rest) (+ nested 1) temp))
             ((char=? (car rest) #\}) (if (= nested 1)
                                          (cons (list (apply string-append (reverse current)) 
                                                       (string->list (apply string-append (reverse temp))))
                                                (helper (cdr rest) stack '()))
                                          (loop (cdr rest) (- nested 1) temp)))
             (else (loop (cdr rest) nested (cons (char->string (car rest)) temp))))))
        (else (helper (cdr expr) (cons (car expr) stack) current))))

    (let ((parsed (helper (string->list expression) '() '())))
      (sort (remove-duplicates (expand parsed)) string<?)))

  (string-join (braceExpansionII expression) ","))