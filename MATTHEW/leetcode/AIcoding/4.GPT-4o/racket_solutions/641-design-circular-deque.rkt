(define CircularDeque
  (lambda (k)
    (let ([deque (make-vector k 0)]
          [head 0]
          [tail 0]
          [size 0])
      (define (insertFront(value)
        (if (< size k)
            (begin
              (set! head (modulo (- head 1) k))
              (vector-set! deque head value)
              (set! size (+ size 1))
              #t)
            #f))
      (define (insertLast(value)
        (if (< size k)
            (begin
              (vector-set! deque tail value)
              (set! tail (modulo (+ tail 1) k))
              (set! size (+ size 1))
              #t)
            #f))
      (define (deleteFront)
        (if (> size 0)
            (begin
              (set! head (modulo (+ head 1) k))
              (set! size (- size 1))
              #t)
            #f))
      (define (deleteLast)
        (if (> size 0)
            (begin
              (set! tail (modulo (- tail 1) k))
              (set! size (- size 1))
              #t)
            #f))
      (define (getFront)
        (if (> size 0)
            (vector-ref deque head)
            -1))
      (define (getRear)
        (if (> size 0)
            (vector-ref deque (modulo (- tail 1) k))
            -1))
      (define (isEmpty)
        (= size 0))
      (define (isFull)
        (= size k))
      (define (methods)
        (list insertFront insertLast deleteFront deleteLast getFront getRear isEmpty isFull))
      (methods))))

(define myCircularDeque (CircularDeque 3))
(define insertFront (car (myCircularDeque)))
(define insertLast (cadr (myCircularDeque)))
(define deleteFront (caddr (myCircularDeque)))
(define deleteLast (cadddr (myCircularDeque)))
(define getFront (cadddr (myCircularDeque)))
(define getRear (cadr (myCircularDeque)))
(define isEmpty (caddr (myCircularDeque)))
(define isFull (cadddr (myCircularDeque)))