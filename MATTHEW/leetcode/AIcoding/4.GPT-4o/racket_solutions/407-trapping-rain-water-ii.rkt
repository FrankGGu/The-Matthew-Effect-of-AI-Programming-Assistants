(define (trapRainWater heightMap)
  (define n (length heightMap))
  (define m (if (zero? n) 0 (length (vector-ref heightMap 0))))
  (define (index->pair idx)
    (values (quotient idx m) (modulo idx m)))
  (define (pair->index x y)
    (+ (* x m) y))

  (define (in-bounds x y)
    (and (>= x 0) (< x n) (>= y 0) (< y m)))

  (define directions '((-1 0) (1 0) (0 -1) (0 1)))

  (define (bfs)
    (let loop ((pq (make-queue)))
      (if (queue-empty? pq)
          0
          (let* ((cell (queue-dequeue! pq))
                 (h (car cell))
                 (x (cadr cell))
                 (y (caddr cell)))
            (for-each (lambda (d)
                        (let* ((nx (+ x (car d)))
                               (ny (+ y (cadr d)))
                               (new-height (if (in-bounds nx ny)
                                               (vector-ref (vector-ref heightMap nx) ny)
                                               +inf.0)))
                          (when (and (in-bounds nx ny)
                                     (<= new-height h))
                            (set! heightMap (vector-set! (vector-ref heightMap nx) ny h))
                            (queue-enqueue! pq (list h nx ny)))))
                      directions)
            (+ 1 (loop pq))))))

  (define (initialize)
    (let ((pq (make-queue))
          (visited (make-vector (* n m) #f)))
      (for ((i (in-range n))
            (j (in-range m)))
        (when (or (= (vector-ref (vector-ref heightMap i) j) 0)
                  (= i 0) (= i (sub1 n)) (= j 0) (= j (sub1 m)))
          (vector-set! visited (pair->index i j) #t)
          (queue-enqueue! pq (list (vector-ref (vector-ref heightMap i) j) i j))))
      (values pq visited)))

  (define (calculate-water pq visited)
    (let loop ((total-water 0))
      (if (queue-empty? pq)
          total-water
          (let* ((cell (queue-dequeue! pq))
                 (h (car cell))
                 (x (cadr cell))
                 (y (caddr cell)))
            (for-each (lambda (d)
                        (let* ((nx (+ x (car d)))
                               (ny (+ y (cadr d)))
                               (new-height (if (in-bounds nx ny)
                                               (vector-ref (vector-ref heightMap nx) ny)
                                               +inf.0)))
                          (when (and (in-bounds nx ny)
                                     (not (vector-ref visited (pair->index nx ny)))
                                     (> h new-height))
                            (set! total-water (+ total-water (- h new-height)))
                            (set! visited (vector-set! visited (pair->index nx ny) #t))
                            (queue-enqueue! pq (list h nx ny)))))
                      directions)
            (loop total-water)))))

  (let-values (initialize)
    (lambda (pq visited)
      (calculate-water pq visited))))

(trapRainWater heightMap)