(define (next-permutation nums)
  (define n (length nums))
  (define (reverse lst)
    (if (null? lst)
        '()
        (append (reverse (cdr lst)) (list (car lst)))))
  (define (find-pivot)
    (for/fold ((i -1)) ((j (- n 2)) (i (in-range (- n 1) -1 -1)))
      (if (and (>= (list-ref nums j) (list-ref nums (+ j 1))) (>= j i))
          i
          j)))
  (define pivot (find-pivot))
  (if (= pivot -1)
      (set! nums (reverse nums))
      (let ((successor (for/fold ((s -1)) ((j (- n 1)) (i (in-range n)))
                                    (if (and (> (list-ref nums j) (list-ref nums pivot)) (or (= s -1) (< j s)))
                                        j
                                        s))))
        (let ((temp (list-ref nums pivot)))
          (set! (list-ref nums pivot) (list-ref nums successor))
          (set! (list-ref nums successor) temp))
        (set! nums (reverse (take nums (+ pivot 1)))))
    nums))