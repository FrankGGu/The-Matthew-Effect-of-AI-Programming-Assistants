(define (shortestPath grid k)
  (define rows (length grid))
  (define cols (length (first grid)))
  (define directions '((1 0) (0 1) (-1 0) (0 -1)))

  (define (in-bounds? x y)
    (and (>= x 0) (< x rows) (>= y 0) (< y cols)))

  (define (bfs)
    (define visited (make-vector rows (make-vector cols #f)))
    (define queue (list (list 0 0 0 k))) ; (x, y, steps, remaining_k)
    (vector-set! visited 0 (vector-set (vector-ref visited 0) 0 #t))

    (let loop ()
      (if (null? queue)
          -1
          (let* ((current (car queue))
                 (x (car current))
                 (y (cadr current))
                 (steps (caddr current))
                 (remaining_k (cadddr current)))
            (set! queue (cdr queue))
            (if (and (= x (- rows 1)) (= y (- cols 1)))
                steps
                (for-each (lambda (dir)
                            (let* ((new-x (+ x (car dir)))
                                   (new-y (+ y (cadr dir)))
                                   (new-remaining-k (if (= (grid new-x new-y) 1)
                                                        (- remaining_k 1)
                                                        remaining_k)))
                              (when (and (in-bounds? new-x new-y)
                                         (>= new-remaining-k 0)
                                         (not (vector-ref (vector-ref visited new-x) new-y)))
                                (vector-set! (vector-ref visited new-x) new-y #t)
                                (set! queue (append queue (list (list new-x new-y (+ steps 1) new-remaining-k)))))))
                          directions))
            (loop)))))

  (bfs))