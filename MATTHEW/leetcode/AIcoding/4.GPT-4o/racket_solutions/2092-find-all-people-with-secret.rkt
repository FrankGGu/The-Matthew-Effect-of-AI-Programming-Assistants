(define (find-all-people n meetings firstPerson)
  (define (union-find)
    (define parent (vector))
    (define (find x)
      (if (not (= (vector-ref parent x) x))
          (let ([p (find (vector-ref parent x))])
            (vector-set! parent x p)
            p)
          x))
    (define (union x y)
      (define rootX (find x))
      (define rootY (find y))
      (when (not (= rootX rootY))
        (vector-set! parent rootX rootY)))
    (define (make-set x)
      (vector-set! parent x x))
    (define (init)
      (for ([i (in-range n)])
        (make-set i)))
    (define (get-parent)
      parent)
    (init)
    (values union find get-parent))

  (define (process-meetings meetings)
    (define uf (union-find))
    (define (->meeting-list meeting)
      (list (vector-ref meeting 0) (vector-ref meeting 1) (vector-ref meeting 2)))
    (define sorted-meetings (sort meetings (lambda (a b) (< (vector-ref a 2) (vector-ref b 2)))))
    (for ([meeting (in-list sorted-meetings)])
      (match (->meeting-list meeting)
        [(list person1 person2 time)
         (let-values ([(union find get-parent) uf])
           (union person1 person2))]))
    (get-parent))

  (define (final-people uf firstPerson)
    (define parent (uf))
    (define secret-people (list firstPerson))
    (define first-parent (find firstPerson))
    (for ([i (in-range n)])
      (when (= (find i) first-parent)
        (set! secret-people (cons i secret-people))))
    (set! secret-people (remove-duplicates secret-people))
    secret-people)

  (define people-with-secret (process-meetings meetings))
  (final-people people-with-secret firstPerson))