(define (findEdges n edges)
  (define adj (make-vector n '()))
  (for-each (lambda (e)
              (let ((u (car e))
                    (v (cadr e)))
                (vector-set! adj (sub1 u) (cons v (vector-ref adj (sub1 u))))
                (vector-set! adj (sub1 v) (cons u (vector-ref adj (sub1 v))))))
            edges)
  (define (dijkstra start)
    (define dist (make-vector n +inf.0))
    (define prev (make-vector n #f))
    (define pq (make-priority-queue))
    (vector-set! dist (sub1 start) 0)
    (priority-queue-enqueue pq (list 0 (sub1 start)))
    (let loop ()
      (if (priority-queue-empty? pq) 
          (values dist prev)
          (let* ((current (priority-queue-dequeue pq))
                 (d (car current))
                 (u (cadr current)))
            (for-each (lambda (v)
                        (let ((alt (+ d 1)))
                          (when (< alt (vector-ref dist (sub1 v)))
                            (vector-set! dist (sub1 v) alt)
                            (vector-set! prev (sub1 v) u)
                            (priority-queue-enqueue pq (list alt (sub1 v))))))
                      (vector-ref adj (sub1 u)))
            (loop)))))
  (define (get-edges prev)
    (let loop ((u 0) (edges '()))
      (if (equal? u #f)
          edges
          (loop (vector-ref prev u) (cons (list (add1 (vector-ref edges u)) (add1 u)) edges)))))
  (define (main)
    (let-values ([(dist prev) (dijkstra 1)])
      (get-edges prev)))
  (main))