(define (minMovesToTarget(target)
  (define (bfs)
    (define queue (list (list 0 0 0))) ; position, direction, steps
    (define visited (make-hash))
    (hash-set! visited (list 0 0) #t)
    (define (in-bound? x)
      (and (>= x 0) (<= x 10000)))
    (define (process [pos dir steps])
      (for-each
        (lambda (next)
          (when (in-bound? (car next))
            (unless (hash-ref visited (list (car next) (cadr next)) #f)
              (hash-set! visited (list (car next) (cadr next)) #t)
              (set! queue (append queue (list (list (car next) (cadr next) (+ steps 1))))))
          ))
        (list (list (+ pos dir) dir) (list pos (if (= dir 1) -1 1))))
    (let loop ()
      (when (not (null? queue))
        (define current (car queue))
        (set! queue (cdr queue))
        (when (= (car current) target)
          (return (cadr current)))
        (process current)
        (loop))))
  (bfs))

(minMovesToTarget 5)