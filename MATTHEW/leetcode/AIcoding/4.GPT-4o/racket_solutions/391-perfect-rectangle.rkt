(define (isRectangleCover rectangles)
  (define (add-bounds bounds rect)
    (let ((x1 (first rect))
          (y1 (second rect))
          (x2 (+ (first rect) (third rect)))
          (y2 (+ (second rect) (fourth rect))))
      (list (min (first bounds) x1)
            (min (second bounds) y1)
            (max (third bounds) x2)
            (max (fourth bounds) y2))))

  (define (count-corners corners rect)
    (let ((corner1 (list (first rect) (second rect)))
          (corner2 (list (first rect) (+ (second rect) (fourth rect))))
          (corner3 (list (+ (first rect) (third rect)) (second rect)))
          (corner4 (list (+ (first rect) (third rect)) (+ (second rect) (fourth rect)))))
      (for-each (lambda (corner)
                  (set! (hash-ref corners corner 0) (1+ (hash-ref corners corner 0))))
                (list corner1 corner2 corner3 corner4)))
    corners)

  (define bounds (list +inf.0 +inf.0 -inf.0 -inf.0))
  (define corners (make-hash))

  (for-each (lambda (rect)
              (set! bounds (add-bounds bounds rect))
              (set! corners (count-corners corners rect)))
            rectangles)

  (define corner-count (hash-ref corners (list (first bounds) (second bounds)) 0))
  (define corner-count2 (hash-ref corners (list (first bounds) (fourth bounds)) 0))
  (define corner-count3 (hash-ref corners (list (third bounds) (second bounds)) 0))
  (define corner-count4 (hash-ref corners (list (third bounds) (fourth bounds)) 0))

  (and (= corner-count 1)
       (= corner-count2 1)
       (= corner-count3 1)
       (= corner-count4 1)
       (= (apply + (map (lambda (v) (if (= (hash-ref corners v 0) 1) 1 0)) 
                                        (hash-map corners (lambda (k v) k)))) 
             4)
       (= (apply + (map (lambda (v) (hash-ref corners v 0)) 
                        (hash-map corners (lambda (k v) k)))) 
             (* 2 (length rectangles)))))