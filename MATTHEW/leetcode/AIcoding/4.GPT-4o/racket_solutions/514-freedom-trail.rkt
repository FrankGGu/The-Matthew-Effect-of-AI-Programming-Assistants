(define (findRotateSteps ring key)
  (define (min-steps from to)
    (min (abs (- from to)) (+ (length ring) (abs (- from to)))))
  (define (dp i j)
    (if (= j (string-length key)) 0
        (define next (dp (modulo i 10) (+ j 1)))
        (define steps (min-steps i (string-ref ring j)))
        (+ steps next)))
  (define (search j)
    (if (>= j (string-length key)) 0
        (define cur (string-ref key j))
        (define idx (for/fold ([min-idx -1] [i 0]) ([c ring])
                      (if (equal? c cur)
                          (if (= min-idx -1) i min-idx)
                          min-idx)))
        (if (= idx -1) (search (+ j 1)) (+ (min-steps i idx) (search (+ j 1))))))
  (search 0))

(define (findRotateSteps ring key)
  (let ((n (string-length key)))
    (define dp (make-vector (+ n 1) 0))
    (for ([j (in-range n)])
      (define cur (string-ref key j))
      (for ([i (in-range (string-length ring))])
        (if (equal? (string-ref ring i) cur)
            (vector-set! dp (+ j 1) (min (+ (vector-ref dp j) 1) (if (= j 0) 0 (+ (vector-ref dp j) 1)))))))
      (for ([i (in-range (string-length ring))])
        (if (equal? (string-ref ring i) cur)
            (vector-set! dp (+ j 1) (min (+ (vector-ref dp j) 1) (if (= j 0) 0 (+ (vector-ref dp j) 1)))))))
      (if (equal? (string-ref ring i) cur)
          (set! dp (+ j 1) (min (+ (vector-ref dp j) 1) (if (= j 0) 0 (+ (vector-ref dp j) 1))))))
    (vector-ref dp n)))

(define (findRotateSteps ring key)
  (let* ((m (string-length ring))
         (n (string-length key))
         (dp (make-vector (add1 n) (make-vector (add1 m) +inf.0))))
    (vector-set! dp 0 0)
    (for ([j (in-range 1 (add1 n))])
      (for ([i (in-range m)])
        (define char (string-ref key (- j 1)))
        (if (equal? char (string-ref ring i))
            (let loop ([k 0] [steps 0])
              (if (< k m)
                  (begin
                    (define next-steps (min (+ (vector-ref dp (- j 1)) steps) (vector-ref dp j)))
                    (vector-set! dp j next-steps)
                    (loop (+ k 1) (+ steps 1))))))))
    (for ([j (in-range 1 (add1 n))])
      (define steps (for/fold ([s +inf.0]) ([i (in-range m)])
                     (min s (let loop ([k 0] [steps 0])
                               (if (< k m)
                                   (begin
                                     (define next-steps (min (+ (vector-ref dp (- j 1)) (min-steps i j)) (vector-ref dp j)))
                                     (loop (+ k 1) (+ steps 1))))))))
      (vector-set! dp j steps))
    (vector-ref dp n)))

(findRotateSteps "godding" "gd"))