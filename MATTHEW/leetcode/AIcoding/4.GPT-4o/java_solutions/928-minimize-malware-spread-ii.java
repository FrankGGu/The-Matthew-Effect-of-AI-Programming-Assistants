import java.util.*;

public class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        boolean[] isMalware = new boolean[n];
        for (int node : initial) {
            isMalware[node] = true;
        }

        List<Integer> initialList = Arrays.stream(initial).boxed().collect(Collectors.toList());
        Collections.sort(initialList);

        int[] component = new int[n];
        int[] size = new int[n];
        int componentId = 0;

        for (int i = 0; i < n; i++) {
            if (component[i] == 0) {
                dfs(graph, component, size, i, ++componentId);
            }
        }

        int[] infectedCount = new int[componentId + 1];
        for (int node : initial) {
            infectedCount[component[node]]++;
        }

        int minNode = Integer.MAX_VALUE;
        int minComponent = Integer.MAX_VALUE;

        for (int node : initial) {
            int compId = component[node];
            if (infectedCount[compId] == 1) {
                if (size[compId] > minComponent || (size[compId] == minComponent && node < minNode)) {
                    minNode = node;
                    minComponent = size[compId];
                }
            }
        }

        return minNode == Integer.MAX_VALUE ? Collections.min(initialList) : minNode;
    }

    private void dfs(int[][] graph, int[] component, int[] size, int node, int compId) {
        component[node] = compId;
        size[compId]++;
        for (int neighbor = 0; neighbor < graph.length; neighbor++) {
            if (graph[node][neighbor] == 1 && component[neighbor] == 0) {
                dfs(graph, component, size, neighbor, compId);
            }
        }
    }
}