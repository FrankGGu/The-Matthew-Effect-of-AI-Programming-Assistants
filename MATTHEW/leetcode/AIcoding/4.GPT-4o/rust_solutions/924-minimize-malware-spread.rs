use std::collections::{HashSet, HashMap};

pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
    let n = graph.len();
    let mut initial_set: HashSet<i32> = initial.iter().cloned().collect();
    let mut visited = vec![false; n];
    let mut component_id = vec![0; n];
    let mut component_size = vec![0; n];
    let mut component_malware = vec![0; n];
    let mut component_count = 0;

    for i in 0..n {
        if !visited[i] {
            let mut stack = vec![i];
            let mut size = 0;
            let mut malware_count = 0;

            while let Some(node) = stack.pop() {
                if visited[node] {
                    continue;
                }
                visited[node] = true;
                size += 1;
                if initial_set.contains(&(node as i32)) {
                    malware_count += 1;
                }
                for j in 0..n {
                    if graph[node][j] == 1 && !visited[j] {
                        stack.push(j);
                    }
                }
            }

            component_size[component_count] = size;
            component_malware[component_count] = malware_count;
            for j in 0..n {
                if visited[j] && component_id[j] == 0 {
                    component_id[j] = component_count + 1;
                }
            }
            component_count += 1;
        }
    }

    let mut result = -1;
    let mut max_size = -1;

    for &node in &initial {
        let id = component_id[node as usize];
        if id > 0 && component_malware[(id - 1) as usize] == 1 {
            let size = component_size[(id - 1) as usize];
            if size > max_size || (size == max_size && (result == -1 || node < result)) {
                max_size = size;
                result = node;
            }
        }
    }

    if result == -1 {
        *initial.iter().min().unwrap()
    } else {
        result
    }
}