use std::collections::{HashSet, HashMap};

pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
    let n = graph.len();
    let mut initial_set: HashSet<i32> = initial.iter().cloned().collect();
    let mut component: Vec<Vec<i32>> = vec![];
    let mut visited = vec![false; n];

    fn dfs(node: usize, graph: &Vec<Vec<i32>>, visited: &mut Vec<bool>, component: &mut Vec<i32>) {
        visited[node] = true;
        component.push(node as i32);
        for (neighbour, &connected) in graph[node].iter().enumerate() {
            if connected == 1 && !visited[neighbour] {
                dfs(neighbour, graph, visited, component);
            }
        }
    }

    for i in 0..n {
        if !visited[i] {
            let mut comp = vec![];
            dfs(i, &graph, &mut visited, &mut comp);
            component.push(comp);
        }
    }

    let mut malware_count: HashMap<i32, i32> = HashMap::new();

    for &malware in &initial {
        for comp in &component {
            if comp.contains(&malware) {
                for &node in comp {
                    if !initial_set.contains(&node) {
                        *malware_count.entry(node).or_insert(0) += 1;
                    }
                }
            }
        }
    }

    let mut result = i32::MAX;
    let mut max_count = -1;

    for &malware in &initial {
        let count = malware_count.get(&malware).unwrap_or(&0);
        if *count > max_count || (*count == max_count && malware < result) {
            max_count = *count;
            result = malware;
        }
    }

    result
}