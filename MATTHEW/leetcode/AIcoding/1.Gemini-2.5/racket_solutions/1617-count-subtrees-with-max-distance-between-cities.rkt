#lang racket

(define (count-subtrees-with-max-distance n edges d)
  (define (make-adj-list n edges)
    (define adj (make-vector n null))
    (for-each (lambda (edge)
                (define u (car edge))
                (define v (cadr edge))
                (vector-set! adj (- u 1) (cons (- v 1) (vector-ref adj (- u 1))))
                (vector-set! adj (- v 1) (cons (- u 1) (vector-ref adj (- v 1)))))
              edges)
    adj)

  (define adj-list (make-adj-list n edges))
  (define total-count 0)

  (for ([mask (in-range 1 (expt 2 n))])
    (define current-cities '())
    (define num-cities-in-mask 0)
    (for ([i (in-range n)])
      (when (positive? (bitwise-and mask (expt 2 i)))
        (set! current-cities (cons i current-cities))
        (set! num-cities-in-mask (add1 num-cities-in-mask))))

    (set! current-cities (reverse current-cities))

    (when (= num-cities-in-mask 1)
      (when (= d 0)
        (set! total-count (add1 total-count))))

    (when (> num-cities-in-mask 1)
      (define first-city (car current-cities))
      (define q-connectivity (make-queue))
      (define visited-bfs-connectivity 0)
      (queue-push! q-connectivity first-city)
      (set! visited-bfs-connectivity (bitwise-ior visited-bfs-connectivity (expt 2 first-city)))
      (define num-visited-in-bfs 1)

      (let loop-bfs-connectivity ()
        (when (not (queue-empty? q-connectivity))
          (define u (queue-pop! q-connectivity))
          (for-each (lambda (v)
                      (when (and (positive? (bitwise-and mask (expt 2 v)))
                                 (zero? (bitwise-and visited-bfs-connectivity (expt 2 v))))
                        (set! visited-bfs-connectivity (bitwise-ior visited-bfs-connectivity (expt 2 v)))
                        (set! num-visited-in-bfs (add1 num-visited-in-bfs))
                        (queue-push! q-connectivity v)))
                    (vector-ref adj-list u))
          (loop-bfs-connectivity)))

      (when (= num-visited-in-bfs num-cities-in-mask)
        (define max-dist-in-subset 0)

        (for-each (lambda (start-node)
                    (define q-diameter (make-queue))
                    (define visited-bfs-diameter 0)
                    (queue-push! q-diameter (list start-node 0))
                    (set! visited-bfs-diameter (bitwise-ior visited-bfs-diameter (expt 2 start-node)))
                    (define current-farthest-dist 0)

                    (let loop-bfs-diameter ()
                      (when (not (queue-empty? q-diameter))
                        (define-values (u dist-u) (apply values (queue-pop! q-diameter)))
                        (set! current-farthest-dist (max current-farthest-dist dist-u))

                        (for-each (lambda (v)
                                    (when (and (positive? (bitwise-and mask (expt 2 v)))
                                               (zero? (bitwise-and visited-bfs-diameter (expt 2 v))))
                                      (set! visited-bfs-diameter (bitwise-ior visited-bfs-diameter (expt 2 v)))
                                      (queue-push! q-diameter (list v (add1 dist-u)))))
                                  (vector-ref adj-list u))
                        (loop-bfs-diameter)))
                    (set! max-dist-in-subset (max max-dist-in-subset current-farthest-dist)))
                  current-cities)

        (when (= max-dist-in-subset d)
          (set! total-count (add1 total-count)))))
  total-count)