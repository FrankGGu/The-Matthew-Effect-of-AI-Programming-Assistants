(define (max-product words)
  (define (word->mask-length word)
    (let ((len (string-length word)))
      (cons (for/fold ((mask 0))
                      ([char (string->list word)])
              (bitwise-ior mask (arithmetic-shift 1 (- (char->integer char) (char->integer #\a)))))
            len)))

  (define masks-lengths-vec (list->vector (map word->mask-length words)))
  (define N (vector-length masks-lengths-vec))

  (for/fold ((max-prod 0))
            ([i (in-range N)])
    (for/fold ((current-max max-prod))
              ([j (in-range (+ i 1) N)])
      (let* ((pair1 (vector-ref masks-lengths-vec i))
             (mask1 (car pair1))
             (len1 (cdr pair1))
             (pair2 (vector-ref masks-lengths-vec j))
             (mask2 (car pair2))
             (len2 (cdr pair2)))
        (if (= (bitwise-and mask1 mask2) 0)
            (max current-max (* len1 len2))
            current-max)))))