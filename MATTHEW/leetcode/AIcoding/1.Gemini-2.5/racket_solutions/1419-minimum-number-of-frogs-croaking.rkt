(define (min-number-of-frogs croakOfFrogs)
  (let ((c 0) (r 0) (o 0) (a 0) (k 0)
        (active-frogs 0)
        (max-frogs 0))

    (call-with-current-continuation
     (lambda (return-early)
       (let loop ((chars (string->list croakOfFrogs)))
         (if (null? chars)
             (if (and (= c r) (= r o) (= o a) (= a k))
                 max-frogs
                 -1)
             (let ((char (car chars)))
               (case char
                 ((#\c)
                  (set! c (+ c 1))
                  (set! active-frogs (+ active-frogs 1))
                  (set! max-frogs (max max-frogs active-frogs)))
                 ((#\r)
                  (set! r (+ r 1))
                  (when (> r c) (return-early -1)))
                 ((#\o)
                  (set! o (+ o 1))
                  (when (> o r) (return-early -1)))
                 ((#\a)
                  (set! a (+ a 1))
                  (when (> a o) (return-early -1)))
                 ((#\k)
                  (set! k (+ k 1))
                  (when (> k a) (return-early -1))
                  (set! active-frogs (- active-frogs 1))))
               (loop (cdr chars)))))))))