#lang racket

(define (make-dsu n)
  (define parent (make-vector n))
  (define sz (make-vector n)) ; Stores size of component if index is a root

  (for ([i (in-range n)])
    (vector-set! parent i i)
    (vector-set! sz i 1))

  (define (find i)
    (if (= (vector-ref parent i) i)
        i
        (let ([root (find (vector-ref parent i))])
          (vector-set! parent i root)
          root)))

  (define (union i j)
    (let ([root-i (find i)]
          [root-j (find j)])
      (unless (= root-i root-j)
        (let ([size-i (vector-ref sz root-i)]
              [size-j (vector-ref sz root-j)])
          (if (> size-i size-j)
              (begin
                (vector-set! parent root-j root-i)
                (vector-set! sz root-i (+ size-i size-j)))
              (begin
                (vector-set! parent root-i root-j)
                (vector-set! sz root-j (+ size-i size-j))))))))
  (list find union sz))

(define (minimize-malware-spread graph initial)
  (define n (vector-length graph))
  (define-values (find union component-sizes-vec) (make-dsu n))

  (for ([i (in-range n)])
    (for ([j (in-range n)])
      (when (= (vector-ref (vector-ref graph i) j) 1)
        (union i j))))

  (define sorted-initial (sort initial <))

  (define component-infected-counts (make-hash))

  (for ([node sorted-initial])
    (let ([root (find node)])
      (hash-set! component-infected-counts root (+ (hash-ref component-infected-counts root 0) 1))))

  (define max-saved-nodes 0)
  (define result-node (car sorted-initial))

  (for ([u sorted-initial])
    (let ([root (find u)])
      (let ([infected-count (hash-ref component-infected-counts root 0)])
        (when (= infected-count 1)
          (let ([current-saved-nodes (vector-ref component-sizes-vec root)])
            (when (> current-saved-nodes max-saved-nodes)
              (set! max-saved-nodes current-saved-nodes)
              (set! result-node u)))))))

  result-node)