#lang racket

(struct heap (data size comparator) #:mutable)

(define (heap-parent i) (floor (/ (- i 1) 2)))
(define (heap-left i) (+ (* 2 i) 1))
(define (heap-right i) (+ (* 2 i) 2))

(define (heap-swap! h i j)
  (let ((data (heap-data h)))
    (let ((temp (vector-ref data i)))
      (vector-set! data i (vector-ref data j))
      (vector-set! data j temp))))

(define (min-heapify! h idx)
  (let* ((data (heap-data h))
         (size (heap-size h))
         (comparator (heap-comparator h))
         (l (heap-left idx))
         (r (heap-right idx))
         (smallest idx))
    (when (and (< l size) (comparator (vector-ref data l) (vector-ref data smallest)))
      (set! smallest l))
    (when (and (< r size) (comparator (vector-ref data r) (vector-ref data smallest)))
      (set! smallest r))
    (when (!= smallest idx)
      (heap-swap! h idx smallest)
      (min-heapify! h smallest))))

(define (heap-insert! h val)
  (let* ((data (heap-data h))
         (old-size (heap-size h))
         (comparator (heap-comparator h)))
    (when (>= (+ old-size 1) (vector-length data))
      (let* ((new-capacity (max 10 (* 2 (+ old-size 1))))
             (new-data (make-vector new-capacity #f)))
        (for ((i (range old-size)))
          (vector-set! new-data i (vector-ref data i)))
        (set-heap-data! h new-data)))

    (set-heap-size! h (+ old-size 1))
    (let ((new-size (heap-size h)))
      (vector-set! (heap-data h) (- new-size 1) val)
      (let loop ((i (- new-size 1)))
        (let ((parent (heap-parent i)))
          (when (and (> i 0) (comparator (vector-ref (heap-data h) i) (vector-ref (heap-data h) parent)))
            (heap-swap! h i parent)
            (loop parent)))))))

(define (heap-extract-min! h)
  (let* ((data (heap-data h))
         (size (heap-size h)))
    (when (zero? size)
      (error "Heap is empty"))
    (let ((min-val (vector-ref data 0)))
      (set-heap-size! h (- size 1))
      (let ((new-size (heap-size h)))
        (when (> new-size 0)
          (vector-set! data 0 (vector-ref data new-size))
          (min-heapify! h 0)))
      min-val)))

(define (heap-min-val h)
  (when (zero? (heap-size h))
    (error "Heap is empty"))
  (vector-ref (heap-data h) 0))

(define (heap-empty? h)
  (zero? (heap-size h)))

(define (make-heap elements comparator)
  (let* ((n (length elements))
         (initial-capacity (max 10 (* 2 n)))
         (data (make-vector initial-capacity #f)))
    (for ((i (range n)))
      (vector-set! data i (list-ref elements i)))
    (let ((h (heap data n comparator)))
      (for ((i (range (floor (/ n 2)) -1 -1)))
        (min-heapify! h i))
      h)))

(define (room-id-comparator a b) (< a b))
(define (occupied-room-comparator a b)
  (or (< (car a) (car b))
      (and (= (car a) (car b)) (< (cdr a) (cdr b)))))

(define (most-booked n meetings)
  (define sorted-meetings (sort meetings (lambda (m1 m2) (< (car m1) (car m2)))))

  (define meeting-counts (make-vector n 0))

  (define initial-free-rooms-list (build-list n identity))
  (define free-rooms (make-heap initial-free-rooms-list room-id-comparator))

  (define occupied-rooms (make-heap '() occupied-room-comparator))

  (for-each (lambda (meeting)
              (let* ((start (car meeting))
                     (end (cadr meeting))
                     (duration (- end start)))

                (let loop-release ()
                  (when (and (not (heap-empty? occupied-rooms))
                             (<= (car (heap-min-val occupied-rooms)) start))
                    (let ((room-info (heap-extract-min! occupied-rooms)))
                      (heap-insert! free-rooms (cdr room-info)))
                    (loop-release)))

                (let ((assigned-room-id -1)
                      (new-meeting-end-time -1))

                  (if (not (heap-empty? free-rooms))
                      (begin
                        (set! assigned-room-id (heap-extract-min! free-rooms))
                        (set! new-meeting-end-time (+ start duration))
                        (heap-insert! occupied-rooms (cons new-meeting-end-time assigned-room-id)))
                      (begin
                        (let* ((room-info (heap-extract-min! occupied-rooms))
                               (earliest-free-time (car room-info))
                               (room-id (cdr room-info)))
                          (set! assigned-room-id room-id)
                          (set! new-meeting-end-time (+ earliest-free-time duration))
                          (heap-insert! occupied-rooms (cons new-meeting-end-time assigned-room-id))))))

                  (vector-set! meeting-counts assigned-room-id
                               (+ (vector-ref meeting-counts assigned-room-id) 1)))))
            sorted-meetings)

  (let ((max-meetings -1)
        (result-room -1))
    (for ((i (range n)))
      (let ((count (vector-ref meeting-counts i)))
        (when (> count max-meetings)
          (set! max-meetings count)
          (set! result-room i))))
    result-room))