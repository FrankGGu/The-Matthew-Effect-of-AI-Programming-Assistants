(define (mod-expt base exp mod)
  (if (= mod 1)
      0
      (let loop ((b (remainder base mod))
                 (e exp)
                 (res 1))
        (if (= e 0)
            res
            (loop (remainder (* b b) mod)
                  (quotient e 2)
                  (if (odd? e)
                      (remainder (* res b) mod)
                      res))))))

(define (get-double-modular-exponentiation-results queries)
  (map (lambda (query)
         (let ((a (list-ref query 0))
               (b (list-ref query 1))
               (m (list-ref query 2))
               (c (list-ref query 3))
               (n (list-ref query 4)))
           (let ((first-mod-exp (mod-expt a b m)))
             (mod-expt first-mod-exp c n))))
       queries))