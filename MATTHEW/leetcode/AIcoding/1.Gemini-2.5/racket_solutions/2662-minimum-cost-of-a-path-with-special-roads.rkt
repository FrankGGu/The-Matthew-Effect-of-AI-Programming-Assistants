(define (my-remove-duplicates lst [eq? equal?])
  (define seen (make-hash eq?))
  (define result '())
  (for-each (lambda (item)
              (when (not (hash-has-key? seen item))
                (set! result (cons item result))
                (hash-set! seen item #t)))
            lst)
  (reverse result))

(define (minimum-cost-path-with-special-roads start target special-roads)
  (define (manhattan p1 p2)
    (+ (abs (- (car p1) (car p2)))
       (abs (- (cadr p1) (cadr p2)))))

  (define all-points (list start target))
  (for-each (lambda (road)
              (set! all-points (cons (list (car road) (cadr road)) all-points))
              (set! all-points (cons (list (caddr road) (cadddr road)) all-points)))
            special-roads)
  (set! all-points (my-remove-duplicates all-points))

  (define point-to-idx (make-hash equal?))
  (define idx-to-point (make-vector (length all-points)))
  (let loop ((points all-points) (idx 0))
    (when (not (empty? points))
      (hash-set! point-to-idx (car points) idx)
      (vector-set! idx-to-point idx (car points))
      (loop (cdr points) (add1 idx))))

  (define num-nodes (length all-points))
  (define start-idx (hash-ref point-to-idx start))
  (define target-idx (hash-ref point-to-idx target))

  (define adj (make-vector num-nodes (list)))

  (for* ((i (range num-nodes))
         (j (range num-nodes)))
    (when (< i j)
      (define p1 (vector-ref idx-to-point i))
      (define p2 (vector-ref idx-to-point j))
      (define cost (manhattan p1 p2))
      (vector-set! adj i (cons (list j cost) (vector-ref adj i)))
      (vector-set! adj j (cons (list i cost) (vector-ref adj j)))))

  (for-each (lambda (road)
              (define p1 (list (car road) (cadr road)))
              (define p2 (list (caddr road) (cadddr road)))
              (define cost (cadddr (cdr road)))
              (define idx1 (hash-ref point-to-idx p1))
              (define idx2 (hash-ref point-to-idx p2))
              (vector-set! adj idx1 (cons (list idx2 cost) (vector-ref adj idx1))))
            special-roads)

  (define dist (make-vector num-nodes +inf.0))
  (define visited (make-vector num-nodes #f))

  (vector-set! dist start-idx 0)

  (let loop ((count 0))
    (when (< count num-nodes)
      (define u -1)
      (define min-dist +inf.0)
      (for ((i (range num-nodes)))
        (when (and (not (vector-ref visited i))
                   (< (vector-ref dist i) min-dist))
          (set! min-dist (vector-ref dist i))
          (set! u i)))

      (when (= u -1)
        (break))

      (vector-set! visited u #t)

      (define current-dist-u (vector-ref dist u))
      (for-each (lambda (edge)
                  (define v (car edge))
                  (define weight (cadr edge))
                  (when (< (+ current-dist-u weight) (vector-ref dist v))
                    (vector-set! dist v (+ current-dist-u weight))))
                (vector-ref adj u))
      (loop (add1 count))))

  (vector-ref dist target-idx))