#lang racket

(struct TopVotedCandidate (times leaders))

(define (TopVotedCandidate-constructor persons-list times-list)
  (let* ((persons (list->vector persons-list))
         (times (list->vector times-list))
         (n (vector-length persons))
         (vote-counts (make-hash))
         (leaders (make-vector n)))
    (let loop ((i 0)
               (current-leader -1)
               (max-votes -1))
      (if (= i n)
          (TopVotedCandidate times leaders)
          (let* ((person (vector-ref persons i))
                 (current-person-votes (hash-ref vote-counts person 0))
                 (new-person-votes (+ current-person-votes 1)))
            (hash-set! vote-counts person new-person-votes)
            (let ((next-leader current-leader)
                  (next-max-votes max-votes))
              (when (>= new-person-votes next-max-votes)
                (set! next-max-votes new-person-votes)
                (set! next-leader person))
              (vector-set! leaders i next-leader)
              (loop (+ i 1) next-leader next-max-votes)))))))

(define (TopVotedCandidate-query this t)
  (let* ((times (TopVotedCandidate-times this))
         (leaders (TopVotedCandidate-leaders this))
         (n (vector-length times)))
    (let loop ((low 0) (high (- n 1)) (ans-idx -1))
      (if (> low high)
          (vector-ref leaders ans-idx)
          (let* ((mid (quotient (+ low high) 2))
                 (mid-time (vector-ref times mid)))
            (if (<= mid-time t)
                (loop (+ mid 1) high mid)
                (loop low (- mid 1) ans-idx)))))))