package main

import (
	"sort"
)

type DSU struct {
	parent []int
}

func newDSU(n int) *DSU {
	parent := make([]int, n)
	for i := 0; i < n; i++ {
		parent[i] = i // Each element is initially its own parent
	}
	return &DSU{parent: parent}
}

func (d *DSU) find(i int) int {
	if d.parent[i] == i {
		return i
	}
	d.parent[i] = d.find(d.parent[i]) // Path compression
	return d.parent[i]
}

func (d *DSU) union(i, j int) {
	rootI := d.find(i)
	rootJ := d.find(j)
	if rootI != rootJ {
		d.parent[rootJ] = rootI // Merge by setting one root's parent to the other
	}
}

func minMalwareSpreadII(graph [][]int, initial []int) int {
	n := len(graph)
	dsu := newDSU(n)

	// Build connected components using DSU based on the given graph.
	// All nodes, including initial malware nodes, are part of the graph.
	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ { // Iterate j from i+1 to avoid redundant checks and self-loops
			if graph[i][j] == 1 {
				dsu.union(i, j)
			}
		}
	}

	// Sort initial malware nodes. This is crucial for tie-breaking:
	// if multiple nodes can save the same maximum number of nodes,
	// we must choose the one with the smallest index.
	sort.Ints(initial)

	// componentSize stores the number of nodes in each connected component.
	// Key: root node of the component, Value: size of the component.
	componentSize := make(map[int]int)

	// malwareCount stores the number of initial malware nodes present in each component.
	// Key: root node of the component, Value: count of malware nodes.
	malwareCount := make(map[int]int)

	// Populate componentSize map.
	// Iterate through all nodes to find their root and increment component size.
	for i := 0; i < n; i++ {
		root := dsu.find(i)
		componentSize[root]++
	}

	// Populate malwareCount map.
	// Iterate through initial malware nodes to count how many are in each component.
	for _, node := range initial {
		root := dsu.find(node)
		malwareCount[root]++
	}

	maxSavedNodes := -1 // Stores the maximum number of nodes that can be saved by removing a single malware node.

	// Initialize resultNode to the smallest index in 'initial'.
	// This handles the case where no single removal can save any clean nodes,
	// in which case we must remove the malware node with the smallest index.
	resultNode := initial[0]

	// Iterate through each initial malware node to evaluate the impact of its removal.
	for _, node := range initial {
		root := dsu.find(node)

		// A malware node 'node' can save its component only if it is the *only*
		// initial malware node present in that component.
		if malwareCount[root] == 1 {
			savedNodes := componentSize[root] // Number of nodes saved if 'node' is removed.

			// If current 'savedNodes' is greater than the best found so far, update.
			if savedNodes > maxSavedNodes {
				maxSavedNodes = savedNodes
				resultNode = node
			} 
			// If 'savedNodes' is equal to 'maxSavedNodes', we do nothing.
			// This is because 'initial' is sorted, so the current 'node' would have
			// an index greater than or equal to the 'resultNode' that previously
			// achieved 'maxSavedNodes'. We want the smallest index in case of a tie.
		}
	}

	return resultNode
}