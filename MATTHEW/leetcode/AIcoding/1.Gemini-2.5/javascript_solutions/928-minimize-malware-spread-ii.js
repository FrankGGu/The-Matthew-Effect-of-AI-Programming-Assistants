var minMalwareSpread = function(graph, initial) {
    const n = graph.length;
    const visited = new Array(n).fill(false);
    const nodeToComponent = new Array(n).fill(-1);
    let componentIdCounter = 0;
    const componentData = new Map(); // Map<componentId, { size: number, initialCount: number, uniqueInitialNodeIdx: number | null }>

    const initialSet = new Set(initial);

    for (let i = 0; i < n; i++) {
        if (!visited[i]) {
            const currentComponentId = componentIdCounter++;
            const q = [i];
            visited[i] = true;
            nodeToComponent[i] = currentComponentId;

            let currentComponentSize = 0;
            const initialNodesInThisComponent = new Set();

            let head = 0; // Optimization for BFS queue in JavaScript
            while (head < q.length) {
                const u = q[head++];
                currentComponentSize++;

                if (initialSet.has(u)) {
                    initialNodesInThisComponent.add(u);
                }

                for (let v = 0; v < n; v++) {
                    if (graph[u][v] === 1 && !visited[v]) {
                        visited[v] = true;
                        nodeToComponent[v] = currentComponentId;
                        q.push(v);
                    }
                }
            }

            componentData.set(currentComponentId, {
                size: currentComponentSize,
                initialCount: initialNodesInThisComponent.size,
                uniqueInitialNodeIdx: initialNodesInThisComponent.size === 1 ? Array.from(initialNodesInThisComponent)[0] : null
            });
        }
    }

    // Sort initial nodes to ensure smallest index is chosen in case of a tie
    initial.sort((a, b) => a - b);

    // Calculate the total spread without any removal as a baseline
    let totalSpreadWithoutRemoval = 0;
    for (const info of componentData.values()) {
        if (info.initialCount > 0) {
            totalSpreadWithoutRemoval += info.size;
        }
    }

    let minMalwareSpread = totalSpreadWithoutRemoval;
    // Default to the smallest indexed node from the initial array.
    // This handles cases where no removal can reduce the spread, or if all removals result in the same spread.
    let resultNode = initial[0]; 

    for (const nodeToRemove of initial) {
        let currentSpread = 0;
        for (const info of componentData.values()) {
            if (info.initialCount === 0) {
                // This component has no initial infected nodes, it remains uninfected.
                continue;
            } else if (info.initialCount === 1) {
                // This component has exactly one initial infected node.
                if (info.uniqueInitialNodeIdx === nodeToRemove) {
                    // If we remove this unique initial node, the component becomes uninfected.
                    continue;
                } else {
                    // The unique initial node is not the one we are removing, so this component remains infected.
                    currentSpread += info.size;
                }
            } else { // info.initialCount > 1
                // This component has multiple initial infected nodes.
                // Even if nodeToRemove is one of them, others will still infect the component.
                currentSpread += info.size;
            }
        }

        if (currentSpread < minMalwareSpread) {
            minMalwareSpread = currentSpread;
            resultNode = nodeToRemove;
        }
        // If currentSpread === minMalwareSpread, we do nothing.
        // Because `initial` is sorted, the `resultNode` already holds the smallest index
        // that achieved this `minMalwareSpread`.
    }

    return resultNode;
};