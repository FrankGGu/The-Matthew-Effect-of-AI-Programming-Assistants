#include <stdlib.h> // For malloc, free, qsort
#include <string.h> // For memset (optional, calloc is better for 0 initialization)

int* parent;
int* component_size;

int compareInts(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

int find(int i) {
    if (parent[i] == i) {
        return i;
    }
    return parent[i] = find(parent[i]);
}

void unite(int i, int j) {
    int root_i = find(i);
    int root_j = find(j);
    if (root_i != root_j) {
        // Attach smaller tree under root of larger tree
        if (component_size[root_i] < component_size[root_j]) {
            int temp = root_i;
            root_i = root_j;
            root_j = temp;
        }
        parent[root_j] = root_i;
        component_size[root_i] += component_size[root_j];
    }
}

int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize) {
    int N = graphSize;

    // Allocate and initialize DSU arrays
    parent = (int*)malloc(N * sizeof(int));
    component_size = (int*)malloc(N * sizeof(int));
    for (int i = 0; i < N; ++i) {
        parent[i] = i;
        component_size[i] = 1;
    }

    // Build Disjoint Set Union from the graph
    for (int i = 0; i < N; ++i) {
        for (int j = i + 1; j < N; ++j) { // Iterate j from i+1 to avoid duplicate edges and self-loops
            if (graph[i][j] == 1) {
                unite(i, j);
            }
        }
    }

    // Count how many initial malware nodes are in each connected component
    // initial_nodes_in_component[root] stores this count
    int* initial_nodes_in_component = (int*)calloc(N, sizeof(int)); // calloc initializes memory to zero
    for (int i = 0; i < initialSize; ++i) {
        int root_u = find(initial[i]);
        initial_nodes_in_component[root_u]++;
    }

    // Sort the initial array to handle tie-breaking (smallest index)
    qsort(initial, initialSize, sizeof(int), compareInts);

    int best_node_to_remove = initial[0]; // Default: if no node removal saves anything, pick the smallest index
    int max_nodes_prevented = 0;          // Max number of nodes whose infection is prevented

    // Iterate through each initial malware node to consider removing it
    for (int i = 0; i < initialSize; ++i) {
        int u = initial[i];
        int root_u = find(u);
        int saved_by_removing_u = 0;

        // If 'u' is the only initial malware node in its component,
        // removing 'u' will prevent the entire component from being infected.
        if (initial_nodes_in_component[root_u] == 1) {
            saved_by_removing_u = component_size[root_u];
        }

        // Update if we found a better node to remove
        if (saved_by_removing_u > max_nodes_prevented) {
            max_nodes_prevented = saved_by_removing_u;
            best_node_to_remove = u;
        } 
        // If saved_by_removing_u == max_nodes_prevented, we want the smallest index.
        // Since 'initial' is sorted, 'u' is always >= the current 'best_node_to_remove'
        // if 'best_node_to_remove' was set by an earlier element in 'initial'.
        // Thus, no update is needed in the equality case.
    }

    // Free allocated memory
    free(parent);
    free(component_size);
    free(initial_nodes_in_component);

    return best_node_to_remove;
}