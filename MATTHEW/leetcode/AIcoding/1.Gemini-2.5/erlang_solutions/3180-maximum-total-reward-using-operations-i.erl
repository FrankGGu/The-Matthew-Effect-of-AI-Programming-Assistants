-module(solution).
-export([max_total_reward/1]).

max_total_reward(RewardValues) ->
    % Sort reward values in ascending order.
    % This is crucial for the dynamic programming approach to work correctly
    % by processing smaller rewards first.
    SortedRewards = lists:sort(RewardValues),

    % The state is represented as a tuple: {AchievableRewardsSet, CurrentMaxReward}.
    % AchievableRewardsSet is a gb_set (generalized balanced tree set) of integers,
    % storing all possible total rewards that can be achieved.
    % CurrentMaxReward is an integer representing the maximum reward found so far.
    % Initially, only a reward of 0 is achievable, and the maximum reward is 0.
    InitialState = {gb_sets:from_list([0]), 0},

    % Iterate through each reward value in the sorted list.
    % For each reward R, we update the set of achievable rewards.
    {_FinalSet, FinalMaxReward} = lists:foldl(
        fun(R, {CurrentSet, CurrentMax}) ->
            % For the current reward R, we want to find all new achievable rewards.
            % A new reward can be formed by adding R to an existing achievable reward S_val,
            % but only if R > S_val.
            % We also track the maximum reward that can be formed using the current R.

            % gb_sets:fold iterates over all elements in CurrentSet.
            % AccNewRewards will collect new rewards (S_val + R).
            % AccMax will track the maximum value among (S_val + R) for the current R.
            {NewRewardsList, MaxNewRewardFromR} = gb_sets:fold(
                fun(S_val, {AccNewRewards, AccMax}) ->
                    if R > S_val ->
                        NewR = S_val + R,
                        {[NewR | AccNewRewards], max(NewR, AccMax)};
                    true ->
                        % If R is not greater than S_val, we cannot use R with S_val.
                        % The accumulators remain unchanged.
                        {AccNewRewards, AccMax}
                    end
                end, {[], CurrentMax}, CurrentSet), % Initialize AccMax with CurrentMax

            % Add all newly found rewards to the CurrentSet.
            % lists:foldl is used to add elements one by one to the gb_set.
            UpdatedSet = lists:foldl(fun(NewR, AccSet) -> gb_sets:add(NewR, AccSet) end, CurrentSet, NewRewardsList),

            % The new overall maximum reward is the maximum of the previous CurrentMax
            % and the maximum reward generated by adding the current R (MaxNewRewardFromR).
            {UpdatedSet, MaxNewRewardFromR}
        end,
        InitialState,
        SortedRewards
    ),

    % The final maximum total reward achieved.
    FinalMaxReward.