-module(solution).
-export([primePalindrome/1]).

primePalindrome(N) ->
    % The problem guarantees the answer is less than 2 * 10^8.
    % Initialize CurrentMin with a value greater than any possible answer.
    InitialMin = 200000000, 

    % Find the smallest odd-length prime palindrome P such that P >= N.
    % We iterate 'X' from 1. make_odd_palindrome(X) generates odd-length palindromes
    % in increasing order. The largest palindrome to check is 199999991,
    % which is generated by X = 19999.
    MinOddLengthPrimePalindrome = find_min_odd_length_prime_palindrome(N, 1, InitialMin),

    % 11 is the only even-length prime palindrome.
    % We must check if 11 is a candidate and potentially smaller than 
    % MinOddLengthPrimePalindrome found from odd-length palindromes.
    Result = 
        if 
            N =< 11 andalso is_prime(11) -> 
                min(MinOddLengthPrimePalindrome, 11);
            true -> 
                MinOddLengthPrimePalindrome
        end,
    Result.

find_min_odd_length_prime_palindrome(N, X, CurrentMin) when X > 19999 ->
    CurrentMin;
find_min_odd_length_prime_palindrome(N, X, CurrentMin) ->
    P = make_odd_palindrome(X),
    NewMin = 
        if 
            P >= N andalso is_prime(P) -> min(CurrentMin, P);
            true -> CurrentMin
        end,
    find_min_odd_length_prime_palindrome(N, X + 1, NewMin).

make_odd_palindrome(X) ->
    Str = integer_to_list(X),
    Prefix = lists:droplast(Str),
    list_to_integer(Str ++ lists:reverse(Prefix)).

is_prime(2) -> true;
is_prime(3) -> true;
is_prime(N) when N < 2; N rem 2 == 0 -> false;
is_prime(N) ->
    is_prime_check(N, 3, trunc(math:sqrt(N))).

is_prime_check(N, Divisor, Limit) when Divisor > Limit -> true;
is_prime_check(N, Divisor, Limit) when N rem Divisor == 0 -> false;
is_prime_check(N, Divisor, Limit) ->
    is_prime_check(N, Divisor + 2, Limit).