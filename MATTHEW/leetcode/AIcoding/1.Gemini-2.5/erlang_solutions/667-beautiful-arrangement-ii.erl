-module(solution).
-export([beautiful_arrangement_ii/2]).

beautiful_arrangement_ii(N, K) ->
    % The first part of the array generates K distinct differences.
    % It alternates between numbers from 1 (increasing) and K+1 (decreasing).
    % This uses K+1 numbers and generates K distinct differences (K, K-1, ..., 1).
    AlternatingPart = generate_alternating(1, K + 1, K + 1, K + 1, []),

    % The second part of the array fills the remaining numbers (from K+2 to N)
    % in increasing order. This ensures any new differences are 1, which is
    % already part of the K distinct differences generated by the first part.
    SequentialStart = K + 2,
    SequentialPart = generate_sequential(SequentialStart, N, []),

    AlternatingPart ++ SequentialPart.

generate_alternating(Left, Right, K_plus_1, Count, Acc) when Count > 0 ->
    Current_Index = K_plus_1 - Count,
    if Current_Index rem 2 == 0 -> % If current index is even (0, 2, ...), append Left
        generate_alternating(Left + 1, Right, K_plus_1, Count - 1, [Left | Acc]);
    true -> % If current index is odd (1, 3, ...), append Right
        generate_alternating(Left, Right - 1, K_plus_1, Count - 1, [Right | Acc])
    end;
generate_alternating(_Left, _Right, _K_plus_1, 0, Acc) ->
    lists:reverse(Acc). % Reverse the accumulated list to get the correct order

generate_sequential(Current, N, Acc) when Current =< N ->
    generate_sequential(Current + 1, N, [Current | Acc]);
generate_sequential(_Current, _N, Acc) ->
    lists:reverse(Acc). % Reverse the accumulated list to get the correct order