(define/contract (next-larger-nodes head)
  (-> (or/c list-node? #f) (listof exact-integer?))
  (define (list-node-val node) (if node (list-node-val node) 0))
  (define (list-node-next node) (if node (list-node-next node) #f))
  (let loop ([node head] [stack '()] [result '()] [index 0])
    (if (not node)
        (reverse result)
        (let ([val (list-node-val node)])
          (let inner-loop ([s stack] [r result] [i index])
            (if (null? s)
                (loop (list-node-next node) (cons (cons index val) stack) (cons 0 r) (+ index 1))
                (let ([top (car s)])
                  (if (> val (cdr top))
                      (inner-loop (cdr s) (list-set r (- index (car top) 1) val) i)
                      (loop (list-node-next node) (cons (cons index val) stack) (cons 0 r) (+ index 1))))))))))