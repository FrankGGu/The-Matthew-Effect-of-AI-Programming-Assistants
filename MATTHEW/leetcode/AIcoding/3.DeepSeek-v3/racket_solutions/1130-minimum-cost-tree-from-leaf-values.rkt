(define/contract (mct-from-leaf-values arr)
  (-> (listof exact-integer?) exact-integer?)
  (let loop ([stack (list (inf.0))] [res 0] [arr arr])
    (if (null? arr)
        (let ([stack (cdr stack)])
          (for/fold ([res res]) ([a (in-list stack)] [b (in-list (cdr stack))])
            (+ res (* a b))))
        (let ([x (car arr)])
          (if (<= x (car stack))
              (loop (cons x stack) res (cdr arr))
              (let-values ([(popped stack) (let pop ([stack stack] [popped null])
                                             (if (<= x (car stack))
                                                 (values popped (cons x stack))
                                                 (pop (cdr stack) (cons (car stack) popped))))])
                (loop (if (null? popped)
                          (cons x stack)
                          (cons (min x (car popped)) (cons (max x (car popped)) stack)))
                      (+ res (if (null? popped)
                                 0
                                 (* (car popped) (min x (if (null? (cdr popped)) (inf.0) (cadr popped))))))
                      (cdr arr))))))))