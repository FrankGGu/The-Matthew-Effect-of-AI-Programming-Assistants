#lang racket

(define (is-rational-equal s t)
  (define (parse s)
    (define (helper s i)
      (if (>= i (string-length s))
          '()
          (let ((c (string-ref s i)))
            (if (char=? c #\.)
                (cons (substring s 0 i) (helper s (+ i 1)))
                (if (char=? c #\())
                    (let ((j (string-index s #\) i)))
                      (if j
                          (cons (substring s 0 i) (cons (substring s (+ i 1) j) (helper s (+ j 1))))
                          (cons (substring s 0 i) '())))
                    (helper s (+ i 1))))))
    (let ((parts (helper s 0)))
      (cond ((null? parts) (list "0" "0"))
            ((= (length parts) 1) (list (car parts) "0"))
            (else (list (car parts) (cadr parts))))))

  (define (to-fraction a b)
    (define (gcd a b)
      (if (= b 0)
          a
          (gcd b (modulo a b))))
    (define (reduce a b)
      (let ((g (gcd (abs a) (abs b))))
        (values (/ a g) (/ b g))))
    (let-values (((a b) (reduce (string->number a) (string->number b))))
      (if (= b 0)
          (values 0 1)
          (values a b))))

  (define (compare a1 a2 b1 b2)
    (let-values (((a1 b1) (to-fraction a1 b1))
                  ((a2 b2) (to-fraction a2 b2)))
      (= (* a1 b2) (* a2 b1))))

  (let* ((s-parts (parse s))
         (t-parts (parse t))
         (s-num (car s-parts))
         (s-den (cadr s-parts))
         (t-num (car t-parts))
         (t-den (cadr t-parts)))
    (compare s-num t-num s-den t-den)) )