#lang racket

(define (delete-duplicate-folders folders)
  (define (build-tree)
    (define tree (make-hash))
    (define (insert path)
      (let loop ([path path] [node tree])
        (cond [(null? path) #f]
              [else
               (let ([dir (car path)])
                 (if (hash-has-key? node dir)
                     (loop (cdr path) (hash-ref node dir))
                     (begin
                       (hash-set! node dir (make-hash))
                       (loop (cdr path) (hash-ref node dir))))])))
    (for-each insert folders)
    tree)

  (define (collect-leaf-paths tree)
    (define paths '())
    (define (dfs node prefix)
      (when (hash? node)
        (for-each
         (lambda (k)
           (let ([child (hash-ref node k)])
             (if (hash-empty? child)
                 (set! paths (cons (reverse (cons k prefix)) paths))
                 (dfs child (cons k prefix)))))
         (hash-keys node)))
      paths)
    (dfs tree '()))

  (define (is-duplicate? path1 path2)
    (and (= (length path1) (length path2))
         (equal? path1 path2)))

  (define (get-duplicates paths)
    (define (count-occurrences lst)
      (define counts (make-hash))
      (for-each
       (lambda (p)
         (hash-set! counts p (add1 (hash-ref counts p 0))))
       lst)
      counts)
    (define counts (count-occurrences paths))
    (filter (lambda (p) (> (hash-ref counts p) 1)) paths))

  (define tree (build-tree))
  (define leaf-paths (collect-leaf-paths tree))
  (define duplicates (get-duplicates leaf-paths))
  (define (is-in-duplicates? path)
    (member path duplicates))
  (define (prune tree)
    (define (dfs node)
      (if (hash? node)
          (let ([new-node (make-hash)])
            (for-each
             (lambda (k)
               (let ([child (hash-ref node k)])
                 (if (and (hash? child) (not (is-in-duplicates? (cons k (reverse (list (hash-keys node)))))))
                     (hash-set! new-node k (dfs child))))
             (hash-keys node))
            new-node)
          #f))
    (dfs tree))

  (define pruned-tree (prune tree))
  (define (collect-all-paths node prefix)
    (if (hash? node)
        (append
         (map
          (lambda (k)
            (let ([child (hash-ref node k)])
              (if (hash? child)
                  (append (collect-all-paths child (cons k prefix)) (list (reverse (cons k prefix))))
                  (list (reverse (cons k prefix)))))
          (hash-keys node))
         '())
        '()))
  (define all-paths (collect-all-paths pruned-tree '()))
  (define (sort-path p)
    (sort p string<?))
  (define sorted-paths (map sort-path all-paths))
  (define unique-paths (remove-duplicates sorted-paths))
  (map (lambda (p) (string-join (map symbol->string p) "/")) unique-paths))