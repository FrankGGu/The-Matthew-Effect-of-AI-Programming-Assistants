#lang racket

(define (greatest-common-divisor-traversal nums)
  (define n (length nums))
  (define parent (make-vector n))
  (define (find x)
    (if (not (= (vector-ref parent x) x))
        (vector-set! parent x (find (vector-ref parent x)))
        x))
  (define (union x y)
    (define fx (find x))
    (define fy (find y))
    (when (not (= fx fy))
      (vector-set! parent fy fx)))
  (for ([i (in-range n)])
    (vector-set! parent i i))
  (define (get-primes x)
    (define res '())
    (define i 2)
    (let loop ()
      (when (<= i (sqrt x))
        (when (= (modulo x i) 0)
          (set! res (cons i res))
          (while (= (modulo x i) 0)
            (set! x (/ x i))))
        (set! i (+ i 1))
        (loop)))
    (if (> x 1)
        (cons x res)
        res))
  (define primes (make-hash))
  (for ([i (in-range n)])
    (for ([p (get-primes (list-ref nums i))])
      (hash-update! primes p (Î» (lst) (cons i lst)) '())))
  (for ([p (hash-keys primes)])
    (define lst (hash-ref primes p))
    (for ([i (in-range (sub1 (length lst)))])
      (union (list-ref lst i) (list-ref lst (add1 i)))))
  (define root (find 0))
  (for ([i (in-range 1 n)])
    (unless (= (find i) root)
      (return #f)))
  #t)