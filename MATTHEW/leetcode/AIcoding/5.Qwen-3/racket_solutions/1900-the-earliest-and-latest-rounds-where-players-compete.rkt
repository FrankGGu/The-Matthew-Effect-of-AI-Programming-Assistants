(define (earliest-and-latest n edges)
  (define graph (make-hash))
  (for-each (lambda (edge)
              (let ((u (car edge)) (v (cadr edge)))
                (hash-set! graph u (cons v (hash-ref graph u '())))
                (hash-set! graph v (cons u (hash-ref graph v '())))))
            edges)

  (define (bfs start)
    (let ((visited (make-hash))
          (queue (list start))
          (rounds (list 0)))
      (hash-set! visited start #t)
      (let loop ()
        (when (not (null? queue))
          (let ((size (length queue)))
            (set! rounds (append rounds (list (length rounds))))
            (let inner-loop ()
              (when (not (zero? size))
                (let ((node (car queue)))
                  (set! queue (cdr queue))
                  (for-each (lambda (neighbor)
                              (when (not (hash-has-key? visited neighbor))
                                (hash-set! visited neighbor #t)
                                (set! queue (append queue (list neighbor)))))
                            (hash-ref graph node '())))
                (inner-loop)))
          (loop)))
      (last rounds)))

  (let ((earliest (bfs 0))
        (latest (bfs (sub1 n))))
    (list earliest latest)))