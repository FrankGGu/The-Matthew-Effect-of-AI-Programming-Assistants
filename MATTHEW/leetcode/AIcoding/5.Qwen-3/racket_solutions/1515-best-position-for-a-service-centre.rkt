#lang racket

(define (best-position points)
  (define (distance x y)
    (for/sum ([p points])
      (sqrt (+ (expt (- (car p) x) 2) (expt (- (cdr p) y) 2)))))

  (define (gradient-descent)
    (define learning-rate 0.01)
    (define epsilon 1e-6)
    (define x 0.0)
    (define y 0.0)
    (define dx 0.0)
    (define dy 0.0)
    (define (compute-gradient)
      (let ((dx-sum 0.0)
            (dy-sum 0.0))
        (for-each
         (lambda (p)
           (define px (car p))
           (define py (cdr p))
           (define dist (sqrt (+ (expt (- px x) 2) (expt (- py y) 2))))
           (when (> dist 0)
             (set! dx-sum (+ dx-sum (/ (- px x) dist)))
             (set! dy-sum (+ dy-sum (/ (- py y) dist)))))
         points)
      (values dx-sum dy-sum)))

    (let loop ()
      (define-values (new-dx new-dy) (compute-gradient))
      (set! dx new-dx)
      (set! dy new-dy)
      (set! x (- x (* learning-rate dx)))
      (set! y (- y (* learning-rate dy)))
      (if (< (abs dx) epsilon)
          (values x y)
          (loop))))

  (define-values (x y) (gradient-descent))
  (list x y))