(define (nearest-entrance maze entrance)
  (define rows (length maze))
  (define cols (if (> rows 0) (length (car maze)) 0))
  (define directions '((0 1) (1 0) (0 -1) (-1 0)))
  (define (is-valid? r c)
    (and (>= r 0) (< r rows) (>= c 0) (< c cols) (equal? (list-ref (list-ref maze r) c) #\.) ))
  (define (bfs start-r start-c)
    (define queue (list (list start-r start-c 0)))
    (define visited (set (cons start-r start-c)))
    (let loop ((q queue))
      (if (null? q)
          -1
          (let* ((current (car q))
                 (r (car current))
                 (c (cadr current))
                 (steps (caddr current)))
            (if (and (or (not (= r start-r)) (not (= c start-c))) (or (= r 0) (= r (- rows 1)) (= c 0) (= c (- cols 1))))
                steps
                (let loop2 ((d directions) (new-queue '()))
                  (if (null? d)
                      (loop (append (reverse new-queue) (cdr q)))
                      (let* ((dr (caar d))
                             (dc (cadar d))
                             (nr (+ r dr))
                             (nc (+ c dc)))
                        (if (and (is-valid? nr nc) (not (set-member? visited (cons nr nc))))
                            (begin
                              (set! visited (set-add visited (cons nr nc)))
                              (loop2 (cdr d) (cons (list nr nc (+ steps 1)) new-queue)))
                            (loop2 (cdr d) new-queue)))))))))
  (bfs (car entrance) (cadr entrance)))