(define (kth-smallest matrix k)
  (define (heap? x) (and (vector? x) (= (vector-length x) 3)))
  (define (heap-ref i x) (vector-ref x i))
  (define (heap-set! i x v) (vector-set! x i v))
  (define (heap-size x) (heap-ref 0 x))
  (define (heap-elt x) (heap-ref 1 x))
  (define (heap-idx x) (heap-ref 2 x))
  (define (heap-empty? x) (= (heap-size x) 0))
  (define (heap-pop! x)
    (let ((size (heap-size x)))
      (when (> size 0)
        (let ((root (heap-elt x)))
          (heap-set! 1 x (heap-elt (heap-ref 2 x)))
          (heap-set! 0 x (- size 1))
          (heapify-down! x 1)
          root))))
  (define (heapify-down! x i)
    (let ((size (heap-size x)))
      (let loop ((i i))
        (let ((left (+ (* i 2) 1))
              (right (+ (* i 2) 2)))
          (let ((min-i i))
            (when (and (< left size) (< (heap-elt x) (heap-elt (heap-ref left x))))
              (set! min-i left))
            (when (and (< right size) (< (heap-elt x) (heap-elt (heap-ref right x))))
              (set! min-i right))
            (when (not (= min-i i))
              (let ((temp (heap-ref i x)))
                (heap-set! i x (heap-ref min-i x))
                (heap-set! min-i x temp)
                (loop min-i)))))))
  (define (heapify-up! x i)
    (let loop ((i i))
      (let ((parent (quotient (- i 1) 2)))
        (when (and (> i 0) (< (heap-elt x) (heap-elt (heap-ref parent x))))
          (let ((temp (heap-ref i x)))
            (heap-set! i x (heap-ref parent x))
            (heap-set! parent x temp)
            (loop parent))))))
  (define (heap-push! x val idx)
    (heap-set! 0 x (+ (heap-size x) 1))
    (heap-set! (heap-size x) x (vector val idx))
    (heapify-up! x (heap-size x)))
  (define (heap-top x) (heap-elt x))
  (define (heap-init)
    (vector 0 #f 0))
  (define heap (heap-init))
  (let ((n (length matrix)))
    (when (> n 0)
      (heap-push! heap (list-ref (list-ref matrix 0) 0) 0)
      (let loop ((k k))
        (if (= k 1)
            (heap-top heap)
            (begin
              (let* ((val (heap-pop! heap))
                     (row (heap-idx heap))
                     (col (+ (car val) 1)))
                (when (< col n)
                  (heap-push! heap (list-ref (list-ref matrix row) col) row))
                (loop (- k 1))))))))
  (error "invalid input"))