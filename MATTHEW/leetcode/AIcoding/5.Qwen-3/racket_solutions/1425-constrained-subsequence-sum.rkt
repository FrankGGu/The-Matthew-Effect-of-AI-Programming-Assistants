#lang racket

(define/contract (constrained-subsequence-sum nums k)
  (-> (listof exact-integer?) exact-integer? exact-integer?)
  (let ([n (length nums)])
    (let ([dq (make-vector 0)])
      (define (push x)
        (vector-set! dq 0 (cons x (vector-ref dq 0))))
      (define (pop)
        (vector-set! dq 0 (cdr (vector-ref dq 0))))
      (define (front)
        (car (vector-ref dq 0)))
      (define (back)
        (last (vector-ref dq 0)))
      (define dp (make-vector n 0))
      (vector-set! dp 0 (vector-ref nums 0))
      (push 0)
      (for ([i (in-range 1 n)])
        (while (and (not (null? (vector-ref dq 0))) (> (- i (car (vector-ref dq 0))) k))
          (pop))
        (vector-set! dp i (+ (vector-ref nums i) (if (null? (vector-ref dq 0)) 0 (vector-ref dp (car (vector-ref dq 0))))))
        (while (and (not (null? (vector-ref dq 0))) (<= (vector-ref dp (car (vector-ref dq 0))) (vector-ref dp i)))
          (pop))
        (push i))
      (apply max (vector->list dp))))
  )