#lang racket

(define (repeat-limits s)
  (define counts (make-hash))
  (for ([c s])
    (hash-set! counts c (+ 1 (hash-ref counts c 0))))
  (define pq (priority-queue #:priority (λ (a b) (> (car a) (car b)))))
  (for ([k (in-hash-keys counts)])
    (priority-queue-add! pq (cons (hash-ref counts k) k)))
  (define res '())
  (let loop ()
    (when (priority-queue-empty? pq)
      (apply string res))
    (define-values (cnt c) (priority-queue-remove! pq))
    (when (null? res)
      (set! res (list c))
      (when (> cnt 1)
        (priority-queue-add! pq (cons (- cnt 1) c)))
      (loop))
    (define last-char (car res))
    (if (equal? last-char c)
        (begin
          (when (priority-queue-empty? pq)
            (set! res (append res (make-list cnt c)))
            (loop))
          (define-values (next-cnt next-c) (priority-queue-remove! pq))
          (set! res (append res (list next-c)))
          (when (> next-cnt 1)
            (priority-queue-add! pq (cons (- next-cnt 1) next-c)))
          (priority-queue-add! pq (cons cnt c))
          (loop))
        (begin
          (set! res (append res (make-list (min cnt 2) c)))
          (when (> cnt 2)
            (priority-queue-add! pq (cons (- cnt 2) c)))
          (loop)))))

(define (repeated-string-with-repeat-limit s)
  (define counts (make-hash))
  (for ([c s])
    (hash-set! counts c (+ 1 (hash-ref counts c 0))))
  (define pq (priority-queue #:priority (λ (a b) (> (car a) (car b)))))
  (for ([k (in-hash-keys counts)])
    (priority-queue-add! pq (cons (hash-ref counts k) k)))
  (define res '())
  (let loop ()
    (when (priority-queue-empty? pq)
      (apply string res))
    (define-values (cnt c) (priority-queue-remove! pq))
    (if (and (not (null? res)) (equal? (car res) c))
        (begin
          (when (priority-queue-empty? pq)
            (set! res (append res (make-list cnt c)))
            (loop))
          (define-values (next-cnt next-c) (priority-queue-remove! pq))
          (set! res (append res (list next-c)))
          (when (> next-cnt 1)
            (priority-queue-add! pq (cons (- next-cnt 1) next-c)))
          (priority-queue-add! pq (cons cnt c))
          (loop))
        (begin
          (set! res (append res (make-list (min cnt 2) c)))
          (when (> cnt 2)
            (priority-queue-add! pq (cons (- cnt 2) c)))
          (loop)))))

(define (construct-string-with-repeat-limit s)
  (repeated-string-with-repeat-limit s))