#lang racket

(define (minimum-edge-weight-equilibrium-queries n edges)
  (define tree (make-hash))
  (for-each (lambda (e)
              (let ([u (car e)] [v (cadr e)] [w (caddr e)])
                (hash-set! tree u (cons (cons v w) (hash-ref tree u '())))
                (hash-set! tree v (cons (cons u w) (hash-ref tree v '())))))
            edges)
  (define (dfs node parent)
    (let ([sum 0] [count 0])
      (for-each (lambda (neighbor)
                  (let ([child (car neighbor)] [weight (cdr neighbor)])
                    (when (not (= child parent))
                      (let* ([sub-sum (dfs child node)]
                             [sub-count (car sub-sum)]
                             [sub-sum (cdr sub-sum)])
                        (set! sum (+ sum sub-sum))
                        (set! count (+ count sub-count))))))
            (hash-ref tree node '()))
      (cons count sum)))
  (define (query node)
    (let ([total (cdr (dfs node -1))])
      (let loop ([node node] [parent -1])
        (for-each (lambda (neighbor)
                    (let ([child (car neighbor)] [weight (cdr neighbor)])
                      (when (not (= child parent))
                        (let* ([sub-sum (cdr (dfs child -1))]
                               [remaining (- total sub-sum)])
                          (if (= sub-sum remaining)
                              (begin
                                (display weight)
                                (newline)
                                #t)
                              (loop child node)))))
              (hash-ref tree node '()))
        #f)))
  (for-each query (range n)))