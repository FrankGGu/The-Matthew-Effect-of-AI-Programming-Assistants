(define (game-of-life board)
  (define (count-neighbors x y)
    (define (in-bounds a b)
      (and (>= a 0) (< a (length board)) (>= b 0) (< b (length (list-ref board 0)))))
    (define neighbors '())
    (for-each (lambda (dx)
                (for-each (lambda (dy)
                            (when (and (not (= dx 0) (not (= dy 0)))
                                       (in-bounds (+ x dx) (+ y dy)))
                              (set! neighbors (cons (list-ref (list-ref board (+ x dx)) (+ y dy)) neighbors))))
              '(1 -1 0)))
    (length (filter (lambda (n) (= n 1)) neighbors)))
  (define (next-state x y)
    (let ((live (list-ref (list-ref board x) y)))
      (let ((neighbors (count-neighbors x y)))
        (if (= live 1)
            (if (or (= neighbors 2) (= neighbors 3)) 1 0)
            (if (= neighbors 3) 1 0))))
  (define (update-board)
    (let ((new-board (map (lambda (row) (map (lambda (cell) 0) row)) board)))
      (for-each (lambda (i)
                  (for-each (lambda (j)
                              (set! (list-ref (list-ref new-board i) j) (next-state i j)))
                (range (length (list-ref board 0)))))
      new-board))
  (update-board))