#lang racket

(define (shortest-path n red-blue)
  (define adj (make-hash))
  (for ([i (in-range n)])
    (hash-set! adj i '()))
  (for ([edge (in-list red-blue)])
    (define u (car edge))
    (define v (cadr edge))
    (define color (caddr edge))
    (if (= color 0)
        (hash-set! adj u (cons v (hash-ref adj u)))
        (hash-set! adj u (cons v (hash-ref adj u)))))
  (define dist (make-vector n -1))
  (define q (queue))
  (vector-set! dist 0 0)
  (queue-put! q (cons 0 #f))
  (while (not (queue-empty? q))
    (define current (queue-get! q))
    (define node (car current))
    (define is-red (cdr current))
    (for ([neighbor (hash-ref adj node)])
      (define next-color (not is-red))
      (when (or (and (not is-red) (= (vector-ref dist neighbor) -1))
                (and is-red (= (vector-ref dist neighbor) -1)))
        (vector-set! dist neighbor (+ (vector-ref dist node) 1))
        (queue-put! q (cons neighbor next-color)))))
  (vector->list dist))