#lang racket

(define (find-the-city n edges distance-cutoff)
  (define graph (make-hash))
  (for ([i (in-range n)])
    (hash-set! graph i '()))
  (for ([edge (in-list edges)])
    (define u (car edge))
    (define v (cadr edge))
    (define w (caddr edge))
    (hash-update! graph u (Î» (lst) (cons (cons v w) lst)))
    (hash-update! graph v (Î» (lst) (cons (cons u w) lst))))

  (define (dijkstra start)
    (define dist (make-vector n +inf.0))
    (vector-set! dist start 0)
    (define pq (list (cons 0 start)))
    (define (heap? x) (and (pair? x) (number? (car x)) (number? (cdr x))))
    (define (heap-insert pq val)
      (cond [(null? pq) (list val)]
            [(<= (caar pq) (car val)) (cons val pq)]
            [else (cons (car pq) (heap-insert (cdr pq) val))]))
    (define (heap-extract pq)
      (if (null? pq)
          (values #f #f)
          (values (car pq) (cdr pq))))

    (let loop ()
      (when (not (null? pq))
        (define-values (current-dist current-node) (heap-extract pq))
        (when (< current-dist (vector-ref dist current-node))
          (for ([neighbor (hash-ref graph current-node)])
            (define next-node (car neighbor))
            (define weight (cdr neighbor))
            (define new-dist (+ current-dist weight))
            (when (< new-dist (vector-ref dist next-node))
              (vector-set! dist next-node new-dist)
              (set! pq (heap-insert pq (cons new-dist next-node))))))
        (loop)))
    (for/sum ([i (in-range n)] #:when (< (vector-ref dist i) distance-cutoff)) 1))

  (define (min-city)
    (define min-count +inf.0)
    (define result -1)
    (for ([i (in-range n)])
      (define count (dijkstra i))
      (when (or (< count min-count) (and (= count min-count) (> i result)))
        (set! min-count count)
        (set! result i)))
    result)

  (min-city))