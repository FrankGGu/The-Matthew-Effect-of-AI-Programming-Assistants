#lang racket

(define (max a b)
  (if (> a b) a b))

(define (min a b)
  (if (< a b) a b))

(define (bfs grid)
  (define rows (length grid))
  (define cols (length (car grid)))
  (define visited (make-vector rows (make-vector cols #f)))
  (define q (queue '()))
  (vector-set! visited 0 0 #t)
  (queue-add! q (cons 0 0))
  (define steps 0)
  (define directions (list (cons 1 0) (cons -1 0) (cons 0 1) (cons 0 -1)))
  (let loop ()
    (when (not (queue-empty? q))
      (define size (queue-length q))
      (for ([i (in-range size)])
        (define pos (queue-remove! q))
        (define r (car pos))
        (define c (cdr pos))
        (when (and (= r (sub1 rows)) (= c (sub1 cols)))
          (set! steps (add1 steps))
          (break))
        (for ([d (in-list directions)])
          (define nr (+ r (car d)))
          (define nc (+ c (cdr d)))
          (when (and (<= 0 nr (sub1 rows)) (<= 0 nc (sub1 cols)) (not (vector-ref (vector-ref visited nr) nc)) (>= (vector-ref (vector-ref grid nr) nc) 0))
            (vector-set! visited nr nc #t)
            (queue-add! q (cons nr nc)))))
      (set! steps (add1 steps))
      (loop))))

(define (minimumVisitedCells grid)
  (define rows (length grid))
  (define cols (length (car grid)))
  (define dp (make-vector rows (make-vector cols 0)))
  (define (get-min r c)
    (if (or (= r rows) (= c cols)) 0
        (let ([min-val (vector-ref (vector-ref dp r) c)])
          (if (zero? min-val)
              (begin
                (define val (add1 (apply min (filter (lambda (x) (not (zero? x))) (list (if (> r 0) (vector-ref (vector-ref dp (sub1 r)) c) 0)
                                                                                             (if (> c 0) (vector-ref (vector-ref dp r) (sub1 c)) 0)
                                                                                             (if (and (> r 0) (> c 0)) (vector-ref (vector-ref dp (sub1 r)) (sub1 c)) 0)))))))
              (vector-set! (vector-ref dp r) c val)
              val)
          (vector-ref (vector-ref dp r) c))))
  (for ([r (in-range rows)])
    (for ([c (in-range cols)])
      (if (and (= r 0) (= c 0))
          (vector-set! (vector-ref dp r) c 1)
          (vector-set! (vector-ref dp r) c (get-min r c)))))
  (vector-ref (vector-ref dp (sub1 rows)) (sub1 cols)))

(define (solve)
  (define input (current-input-port))
  (define grid (read input))
  (displayln (minimumVisitedCells grid)))

(solve)