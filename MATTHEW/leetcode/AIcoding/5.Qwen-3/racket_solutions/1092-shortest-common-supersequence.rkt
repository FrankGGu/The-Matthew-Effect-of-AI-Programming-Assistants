#lang racket

(define (shortest-common-supersequence str1 str2)
  (define (lcs a b)
    (define n (string-length a))
    (define m (string-length b))
    (define dp (make-vector (add1 n) (make-vector (add1 m) "")))
    (for ([i (in-range n)])
      (for ([j (in-range m)])
        (if (equal? (string-ref a i) (string-ref b j))
            (vector-set! (vector-ref dp (add1 i)) (add1 j) (string-append (vector-ref (vector-ref dp i) j) (string (string-ref a i))))
            (vector-set! (vector-ref dp (add1 i)) (add1 j) (if (> (string-length (vector-ref (vector-ref dp i) j)) (string-length (vector-ref (vector-ref dp i) (add1 j)))) (vector-ref (vector-ref dp i) j) (vector-ref (vector-ref dp i) (add1 j)))))))
    (vector-ref (vector-ref dp n) m))

  (define lcs-str (lcs str1 str2))
  (define i 0)
  (define j 0)
  (define k 0)
  (define result '())
  (while (and (< i (string-length str1)) (< j (string-length str2)))
    (cond ((equal? (string-ref str1 i) (string-ref str2 j))
           (set! result (append result (list (string (string-ref str1 i)))))
           (set! i (add1 i))
           (set! j (add1 j))
           (set! k (add1 k)))
          ((equal? (string-ref str1 i) (string-ref lcs-str k))
           (set! result (append result (list (string (string-ref str1 i)))))
           (set! i (add1 i))
           (set! k (add1 k)))
          (else
           (set! result (append result (list (string (string-ref str2 j)))))
           (set! j (add1 j)))))
  (while (< i (string-length str1))
    (set! result (append result (list (string (string-ref str1 i)))))
    (set! i (add1 i)))
  (while (< j (string-length str2))
    (set! result (append result (list (string (string-ref str2 j)))))
    (set! j (add1 j)))
  (apply string-append result))