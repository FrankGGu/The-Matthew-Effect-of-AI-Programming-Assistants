#lang racket

(define (sum-of-k-subarrays-with-length-at-least-m nums k m)
  (define n (length nums))
  (define prefix (make-vector (+ n 1) 0))
  (for ([i (in-range n)])
    (vector-set! prefix (+ i 1) (+ (vector-ref prefix i) (list-ref nums i))))
  (define (get-sum l r)
    (- (vector-ref prefix (+ r 1)) (vector-ref prefix l)))
  (define (valid? subarrs)
    (let loop ([subarrs subarrs] [prev -inf.0])
      (cond [(null? subarrs) #t]
            [(<= (caar subarrs) prev) #f]
            [else (loop (cdr subarrs) (cdar subarrs))])))
  (define (generate)
    (let loop ([i 0] [res '()])
      (if (>= i (- n m))
          res
          (loop (+ i 1) (cons (cons i (+ i m -1)) res)))))
  (define candidates (generate))
  (define (dfs idx path res)
    (if (= (length path) k)
        (when (valid? path)
          (set! res (append res (list path))))
        (for ([i (in-range idx (length candidates))])
          (dfs (+ i 1) (append path (list (list-ref candidates i))) res))))
  (define res '())
  (dfs 0 '() res)
  (define total 0)
  (for ([p (in-list res)])
    (define sum 0)
    (for ([seg p])
      (define l (car seg))
      (define r (cadr seg))
      (set! sum (+ sum (get-sum l r))))
    (set! total (+ total sum)))
  total)