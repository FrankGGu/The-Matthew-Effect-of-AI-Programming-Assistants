#lang racket

(define (count-strings n)
  (define dp (make-vector 3 (vector 0 0 0)))
  (vector-set! (vector-ref dp 0) 0 1)
  (for ([i (in-range 1 (add1 n))])
    (define next-dp (vector (vector 0 0 0) (vector 0 0 0) (vector 0 0 0)))
    (for ([j (in-range 3)])
      (for ([k (in-range 3)])
        (when (and (not (= j 2)) (not (= k 0)))
          (vector-set! (vector-ref next-dp (+ j k)) 0 (+ (vector-ref (vector-ref next-dp (+ j k)) 0) (vector-ref (vector-ref dp j) k)))))
    (set! dp next-dp))
  (apply + (vector-map (lambda (v) (vector-ref v 0)) dp)))

(define (find-good-strings n a b)
  (define (count s)
    (define len (string-length s))
    (define dp (make-vector 3 (vector 0 0 0)))
    (vector-set! (vector-ref dp 0) 0 1)
    (for ([i (in-range len)])
      (define next-dp (vector (vector 0 0 0) (vector 0 0 0) (vector 0 0 0)))
      (for ([j (in-range 3)])
        (for ([k (in-range 3)])
          (when (and (not (= j 2)) (not (= k 0)))
            (define c (string-ref s i))
            (define new-j (if (and (= j 0) (= c (string-ref a 0))) 1 (if (and (= j 1) (= c (string-ref a 1))) 2 j)))
            (define new-k (if (and (= k 0) (= c (string-ref b 0))) 1 (if (and (= k 1) (= c (string-ref b 1))) 2 k)))
            (vector-set! (vector-ref next-dp new-j) new-k (+ (vector-ref (vector-ref next-dp new-j) new-k) (vector-ref (vector-ref dp j) k)))))
      (set! dp next-dp))
    (apply + (vector-map (lambda (v) (vector-ref v 0)) dp)))
  (define total (count-strings n))
  (define a-count (count a))
  (define b-count (count b))
  (define ab-count (count (string-append a b)))
  (- (- total a-count) b-count) ab-count)

(define (main)
  (define n (read))
  (define a (read))
  (define b (read))
  (display (find-good-strings n a b)))

(main)