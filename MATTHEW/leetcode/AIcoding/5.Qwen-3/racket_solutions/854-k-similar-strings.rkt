#lang racket

(define (k-similar s t)
  (define n (string-length s))
  (define target (string->list t))
  (define (swap i j lst)
    (define lst2 (list-copy lst))
    (define temp (list-ref lst2 i))
    (set! (list-ref lst2 i) (list-ref lst2 j))
    (set! (list-ref lst2 j) temp)
    lst2)
  (define (get-neighbors lst)
    (for/list ([i (in-range n)]
               #:when (= (list-ref lst i) (list-ref target i)))
      (for/list ([j (in-range (+ i 1) n)]
                 #:when (and (= (list-ref lst j) (list-ref target i))
                             (= (list-ref lst i) (list-ref target j))))
        (swap i j lst))))
  (define (bfs start)
    (define visited (make-hash))
    (define queue (queue '()))
    (queue-add! queue (cons start 0))
    (hash-set! visited start #t)
    (let loop ()
      (when (not (queue-empty? queue))
        (define current (queue-remove! queue))
        (define state (car current))
        (define steps (cdr current))
        (if (equal? state target)
            steps
            (for-each
             (lambda (neighbor)
               (when (not (hash-has-key? visited neighbor))
                 (hash-set! visited neighbor #t)
                 (queue-add! queue (cons neighbor (+ steps 1)))))
             (get-neighbors state))
            (loop))))
    #f)
  (bfs (string->list s)))