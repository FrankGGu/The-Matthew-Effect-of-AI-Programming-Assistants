#lang racket

(define (total-cost-to-hire-k-workers costs k)
  (define n (length costs))
  (define heap1 (make-heap #:priority <))
  (define heap2 (make-heap #:priority >))
  (for ([i (in-range n)])
    (heap-add! heap1 (list-ref costs i) i))
  (define res 0)
  (define i 0)
  (define j 0)
  (define (get-min)
    (if (heap-empty? heap1)
        (begin
          (heap-add! heap2 (heap-remove! heap1))
          (heap-top heap2))
        (if (heap-empty? heap2)
            (heap-top heap1)
            (let ([v1 (heap-top heap1)]
                  [v2 (heap-top heap2)])
              (if (< (car v1) (car v2))
                  (heap-top heap1)
                  (heap-top heap2))))))
  (for ([_ (in-range k)])
    (define min-val (get-min))
    (set! res (+ res (car min-val)))
    (when (and (>= (cadr min-val) i) (<= (cadr min-val) j))
      (heap-remove! heap1)
      (set! i (add1 i))
      (when (< i n)
        (heap-add! heap1 (list-ref costs i) i)))
    (when (and (<= (cadr min-val) j) (>= (cadr min-val) i))
      (heap-remove! heap2)
      (set! j (add1 j))
      (when (< j n)
        (heap-add! heap2 (list-ref costs j) j)))
    (when (heap-empty? heap1)
      (heap-add! heap2 (heap-remove! heap2)))
    (when (heap-empty? heap2)
      (heap-add! heap1 (heap-remove! heap1))))
  res)