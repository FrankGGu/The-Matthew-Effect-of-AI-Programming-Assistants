#lang racket

(define (find-minimum-height-trees n edges)
  (if (= n 1)
      '(0)
      (let* ([adj (make-hash)]
             [degree (make-hash)]
             [leaves (box '())])
        (for-each (lambda (e)
                    (let ([u (car e)] [v (cadr e)])
                      (hash-set! adj u (cons v (hash-ref adj u '())))
                      (hash-set! adj v (cons u (hash-ref adj v '())))
                      (hash-set! degree u (+ 1 (hash-ref degree u 0)))
                      (hash-set! degree v (+ 1 (hash-ref degree v 0))))
                  edges)
        (for-each (lambda (k) (when (= (hash-ref degree k 0) 1) (set-box! leaves (cons k (unbox leaves))))) (hash-keys degree))
        (let loop ()
          (when (not (= (length (unbox leaves)) 0))
            (let ([new-leaves (box '())])
              (for-each (lambda (l)
                          (for-each (lambda (n)
                                      (when (> (hash-ref degree n 0) 1)
                                        (hash-set! degree n (- (hash-ref degree n 0) 1))
                                        (when (= (hash-ref degree n 0) 1)
                                          (set-box! new-leaves (cons n (unbox new-leaves))))))
                        (hash-ref adj l '()))
              (set-box! leaves (unbox new-leaves))
              (loop)))
          (reverse (unbox leaves))))))