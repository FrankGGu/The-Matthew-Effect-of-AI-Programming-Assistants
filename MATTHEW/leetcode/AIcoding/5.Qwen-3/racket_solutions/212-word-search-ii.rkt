#lang racket

(define (find-words board words)
  (define trie (make-trie))
  (for-each (lambda (word) (insert-word trie word)) words)
  (define result (set))
  (define rows (length board))
  (define cols (length (car board)))
  (define visited (make-vector rows (make-vector cols #f)))

  (define (dfs i j node)
    (when (and (>= i 0) (< i rows) (>= j 0) (< j cols) (not (vector-ref (vector-ref visited i) j)))
      (define char (string-ref (vector-ref board i) j))
      (when (hash-has-key? node char)
        (vector-set! (vector-ref visited i) j #t)
        (when (hash-has-key? (hash-ref node char) 'is-end)
          (set-add! result (hash-ref (hash-ref node char) 'is-end)))
        (for-each (lambda (dir) (dfs (+ i (car dir)) (+ j (cadr dir)) (hash-ref node char)))
                  '((0 1) (1 0) (0 -1) (-1 0)))
        (vector-set! (vector-ref visited i) j #f)))
    #t)

  (define (make-trie)
    (hash))

  (define (insert-word trie word)
    (define (helper trie word index)
      (if (= index (string-length word))
          (begin (hash-set! trie 'is-end word) trie)
          (let ((char (string-ref word index)))
            (if (hash-has-key? trie char)
                (helper (hash-ref trie char) word (+ index 1))
                (begin (hash-set! trie char (make-trie))
                       (helper (hash-ref trie char) word (+ index 1))))))
    (helper trie word 0))

  (for ([i (in-range rows)])
    (for ([j (in-range cols)])
      (dfs i j trie)))
  (set->list result))