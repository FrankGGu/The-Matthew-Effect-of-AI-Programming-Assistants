#lang racket

(define (make-heap size)
  (let ((heap (make-vector (+ size 1) 0)))
    (define (build i)
      (when (<= i size)
        (vector-set! heap i 0)
        (build (+ i 1))))
    (build 1)
    heap))

(define (update-heap heap index value)
  (vector-set! heap index value)
  (let loop ((i index))
    (when (> i 1)
      (let ((parent (quotient i 2)))
        (when (> (vector-ref heap i) (vector-ref heap parent))
          (vector-set! heap i (vector-ref heap parent))
          (vector-set! heap parent (vector-ref heap i))
          (loop parent))))))

(define (query-heap heap index)
  (if (= index 0)
      0
      (let loop ((i index) (res 0))
        (if (= i 0)
            res
            (loop (quotient i 2) (+ res (vector-ref heap i)))))))

(define (range-sum-query-mutable nums)
  (let* ((n (length nums))
         (heap (make-heap n))
         (size n))
    (define (update index value)
      (let ((i (+ index 1)))
        (vector-set! heap i value)
        (let loop ((i i))
          (when (> i 1)
            (let ((parent (quotient i 2)))
              (when (> (vector-ref heap i) (vector-ref heap parent))
                (vector-set! heap i (vector-ref heap parent))
                (vector-set! heap parent (vector-ref heap i))
                (loop parent))))))
    (define (query index)
      (let loop ((i (+ index 1)) (res 0))
        (if (= i 0)
            res
            (loop (quotient i 2) (+ res (vector-ref heap i))))))
    (define (init i)
      (when (< i n)
        (update i (list-ref nums i))
        (init (+ i 1))))
    (init 0)
    (lambda (op . args)
      (cond ((eq? op 'update) (update (car args) (cadr args)))
            ((eq? op 'sum) (query (car args))))))