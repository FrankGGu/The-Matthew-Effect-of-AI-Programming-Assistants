(define (min-palindrome s)
  (define (is-palindrome? s)
    (equal? s (reverse s)))
  (define (next-char c)
    (integer->char (+ (char->integer c) 1)))
  (define (prev-char c)
    (integer->char (- (char->integer c) 1)))
  (define (build-palindrome s)
    (let loop ((i 0) (j (- (string-length s) 1)) (s (string->list s)))
      (if (>= i j)
          (list->string s)
          (begin
            (when (not (= (char->integer (list-ref s i)) (char->integer (list-ref s j))))
              (set! s (list-set s j (next-char (list-ref s i))))
              (set! s (list-set s i (list-ref s j))))
            (loop (+ i 1) (- j 1) s)))))
  (define (lex-smallest s)
    (let loop ((i 0) (s (string->list s)))
      (if (= i (string-length s))
          (list->string s)
          (let ((c (list-ref s i)))
            (if (and (< (char->integer c) 122) (not (member (next-char c) '(#\a #\e #\i #\o #\u))))
                (begin
                  (set! s (list-set s i (next-char c)))
                  (loop 0 s))
                (loop (+ i 1) s))))))
  (let loop ((s s))
    (if (is-palindrome? s)
        s
        (loop (build-palindrome s)))))

(define (solution s)
  (lex-smallest s))