#lang racket

(define (can-convert? grid rows cols)
  (define visited (make-vector (* rows cols) #f))
  (define (dfs r c)
    (when (and (>= r 0) (< r rows) (>= c 0) (< c cols) (not (vector-ref visited (+ (* r cols) c))) (eq? (vector-ref grid r) #\1))
      (vector-set! visited (+ (* r cols) c) #t)
      (when (or (= r 0) (= r (- rows 1)) (= c 0) (= c (- cols 1)))
        (set! can-convert #t))
      (dfs (+ r 1) c)
      (dfs (- r 1) c)
      (dfs r (+ c 1))
      (dfs r (- c 1))))
  (define can-convert #f)
  (for ([r (in-range rows)])
    (for ([c (in-range cols)])
      (when (and (eq? (vector-ref grid r) #\1) (not (vector-ref visited (+ (* r cols) c))))
        (dfs r c)
        (when can-convert
          (set! can-convert #t)
          (break))))
  can-convert)

(define (is-safe? grid rows cols)
  (define visited (make-vector (* rows cols) #f))
  (define (dfs r c)
    (when (and (>= r 0) (< r rows) (>= c 0) (< c cols) (not (vector-ref visited (+ (* r cols) c))) (eq? (vector-ref grid r) #\1))
      (vector-set! visited (+ (* r cols) c) #t)
      (when (or (= r 0) (= r (- rows 1)) (= c 0) (= c (- cols 1)))
        (set! is-safe #t))
      (dfs (+ r 1) c)
      (dfs (- r 1) c)
      (dfs r (+ c 1))
      (dfs r (- c 1))))
  (define is-safe #f)
  (for ([r (in-range rows)])
    (for ([c (in-range cols)])
      (when (and (eq? (vector-ref grid r) #\1) (not (vector-ref visited (+ (* r cols) c))))
        (dfs r c)
        (when is-safe
          (set! is-safe #t)
          (break))))
  is-safe)

(define (last-day-you-can-still-cross row col grid)
  (define (binary-search low high)
    (if (> low high)
        high
        (let* ([mid (quotient (+ low high) 2)]
               [new-grid (map (lambda (r) (list->string (take r mid))) grid)])
          (if (can-convert? new-grid row col)
              (binary-search (+ mid 1) high)
              (binary-search low (- mid 1))))))
  (binary-search 0 (add1 col)))

(define (main)
  (define input (read-line))
  (define row (string->number input))
  (define col (string->number (read-line)))
  (define grid (for/list ([i (in-range row)]) (read-line)))
  (display (last-day-you-can-still-cross row col grid)))

(main)