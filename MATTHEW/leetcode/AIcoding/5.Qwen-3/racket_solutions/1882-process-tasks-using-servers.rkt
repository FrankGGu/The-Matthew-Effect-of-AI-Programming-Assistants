#lang racket

(define (process-tasks servers tasks)
  (define n (length servers))
  (define m (length tasks))
  (define pq (make-heap #:priority <))
  (for ([i (in-range n)])
    (heap-add! pq (cons 0 i)))
  (define res '())
  (define time 0)
  (define task-pq (make-heap #:priority <))
  (for ([i (in-range m)])
    (heap-add! task-pq (cons (list-ref tasks i) i)))
  (define (get-next-time)
    (if (heap-empty? task-pq)
        #f
        (let ([t (heap-top task-pq)])
          (car t))))
  (define (assign-task task-id)
    (let ([server (heap-top pq)])
      (heap-remove! pq)
      (set! res (append res (list (cdr server))))
      (heap-add! pq (cons (+ time (list-ref tasks task-id)) (cdr server)))))
  (define (release-servers)
    (let loop ()
      (when (and (not (heap-empty? pq)) (< (caar pq) time))
        (heap-remove! pq)
        (loop)))
    (when (not (heap-empty? pq))
      (let ([server (heap-top pq)])
        (when (< (car server) time)
          (heap-remove! pq)
          (heap-add! pq (cons 0 (cdr server)))))))
  (let loop ()
    (when (not (heap-empty? task-pq))
      (let ([next-time (get-next-time)])
        (when next-time
          (set! time next-time)
          (release-servers)
          (let ([task (heap-top task-pq)])
            (heap-remove! task-pq)
            (assign-task (cdr task))
            (loop)))))
  res)