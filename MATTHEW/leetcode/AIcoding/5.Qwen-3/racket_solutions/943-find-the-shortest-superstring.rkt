#lang racket

(define (find-shortest-superstring words)
  (define n (length words))
  (define (overlap a b)
    (define len (min (string-length a) (string-length b)))
    (for/first ([i (in-range len 0 -1)])
      (when (equal? (substring a (- (string-length a) i)) (substring b 0 i))
        i)))
  (define dp (make-vector n (make-vector n 0)))
  (for ([i (in-range n)])
    (for ([j (in-range n)])
      (when (not (= i j))
        (vector-set! (vector-ref dp i) j (overlap (list-ref words i) (list-ref words j))))))
  (define (get-adjacent x y)
    (if (zero? (vector-ref (vector-ref dp x) y))
        0
        (vector-ref (vector-ref dp x) y)))
  (define (merge a b)
    (define o (get-adjacent a b))
    (string-append (list-ref words a) (substring (list-ref words b) o)))
  (define (dfs mask i)
    (cond [(= mask (bitwise-not 0)) 0]
          [else
           (let loop ([j 0] [best #f])
             (if (= j n)
                 (if best (vector-ref (vector-ref dp i) best) 0)
                 (if (bitwise-and mask (arithmetic-shift 1 j))
                     (loop (+ j 1) best)
                     (let ([new-mask (bitwise-ior mask (arithmetic-shift 1 j))])
                       (let ([next (dfs new-mask j)])
                         (if (and next (or (not best) (< (string-length (merge i j)) (string-length (merge i best)))))
                             (loop (+ j 1) j)
                             (loop (+ j 1) best)))))))]))
  (define (get-result)
    (let loop ([mask 0] [i 0] [best 0])
      (if (= mask (bitwise-not 0))
          (list-ref words best)
          (let ([next (dfs mask i)])
            (loop (bitwise-ior mask (arithmetic-shift 1 i)) next (if (and next (or (not best) (< (string-length (merge i best)) (string-length (merge i best)))))) i best))))))
  (get-result))