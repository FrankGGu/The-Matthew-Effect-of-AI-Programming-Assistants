#lang racket

(require rackunit)

(define (max-subarray-min-product nums)
  (define (solve nums)
    (define n (length nums))
    (define left (make-vector n -1))
    (define right (make-vector n n))
    (define stack '())
    (for ([i (in-range n)])
      (let loop ()
        (when (and (not (null? stack)) (< (vector-ref nums (car stack)) (vector-ref nums i)))
          (vector-set! right (car stack) i)
          (set! stack (cdr stack))
          (loop)))
      (when (not (null? stack))
        (vector-set! left i (car stack)))
      (set! stack (cons i stack)))
    (set! stack '())
    (for ([i (in-range (- n 1) -1 -1)])
      (let loop ()
        (when (and (not (null? stack)) (< (vector-ref nums (car stack)) (vector-ref nums i)))
          (vector-set! left (car stack) i)
          (set! stack (cdr stack))
          (loop)))
      (when (not (null? stack))
        (vector-set! right i (car stack)))
      (set! stack (cons i stack)))
    (define sum (make-vector n 0))
    (define total 0)
    (for ([i (in-range n)])
      (vector-set! sum i (* (vector-ref nums i) (- (vector-ref right i) (vector-ref left i))))
      (set! total (+ total (vector-ref sum i))))
    total)
  (solve (list->vector nums)))