#lang racket

(define (find-anagrams s p)
  (define (char->index c) (- (char->integer c) (char->integer #\a)))
  (define (count-chars str)
    (let ([counts (make-vector 26 0)])
      (for-each (lambda (c) (vector-set! counts (char->index c) (+ (vector-ref counts (char->index c)) 1))) (string->list str))
      counts))
  (define p-counts (count-chars p))
  (define s-counts (count-chars (substring s 0 (string-length p))))
  (define result '())
  (define (equal? a b)
    (for/and ([i (in-range 26)]) (= (vector-ref a i) (vector-ref b i))))
  (if (equal? s-counts p-counts)
      (set! result (cons 0 result)))
  (for ([i (in-range (string-length p) (string-length s))])
    (vector-set! s-counts (char->index (string-ref s (- i 1))) (- (vector-ref s-counts (char->index (string-ref s (- i 1)))) 1))
    (vector-set! s-counts (char->index (string-ref s i)) (+ (vector-ref s-counts (char->index (string-ref s i))) 1))
    (when (equal? s-counts p-counts)
      (set! result (cons (- i (string-length p) +1) result))))
  (reverse result))