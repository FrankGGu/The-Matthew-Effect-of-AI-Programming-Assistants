#lang racket

(define (odd-even-jump arr)
  (define n (length arr))
  (define sorted (sort (map cons arr (range n)) (lambda (a b) (< (car a) (car b)))))
  (define next-odd (make-vector n -1))
  (define next-even (make-vector n -1))
  (define index-map (make-hash))
  (for ([i (in-range n)])
    (hash-set! index-map (list-ref arr i) i))
  (for ([i (in-range n)])
    (let ([val (list-ref arr i)])
      (let loop ([j (+ i 1)])
        (when (< j n)
          (when (= (vector-ref next-odd i) -1)
            (when (>= (list-ref arr j) val)
              (vector-set! next-odd i j)))
          (when (= (vector-ref next-even i) -1)
            (when (<= (list-ref arr j) val)
              (vector-set! next-even i j)))
          (loop (+ j 1)))))
  (define odd (make-vector n #f))
  (define even (make-vector n #f))
  (vector-set! odd (- n 1) #t)
  (vector-set! even (- n 1) #t)
  (for ([i (reverse (range n))])
    (when (vector-ref next-odd i)
      (vector-set! odd i (vector-ref even (vector-ref next-odd i))))
    (when (vector-ref next-even i)
      (vector-set! even i (vector-ref odd (vector-ref next-even i)))))
  (vector-count identity odd))

(define (main)
  (define input (read))
  (displayln (odd-even-jump input)))

(main)