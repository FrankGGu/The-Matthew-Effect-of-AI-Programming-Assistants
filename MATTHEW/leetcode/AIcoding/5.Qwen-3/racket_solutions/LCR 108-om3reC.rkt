#lang racket

(define (ladder-length begin-word end-word word-list)
  (define word-set (list->set word-list))
  (define (is-in-set? word) (set-member? word-set word))
  (define (neighbors word)
    (for/list ([i (in-range (string-length word))])
      (for/fold ([res '()])
                ([c (in-range 97 123)])
        (define new-word (string-set! (string-copy word) i (integer->char c)))
        (if (is-in-set? new-word) (cons new-word res) res))))
  (define (bfs)
    (define queue (queue (cons begin-word 1)))
    (define visited (set begin-word))
    (let loop ()
      (when (not (queue-empty? queue))
        (define current (queue-dequeue! queue))
        (define current-word (car current))
        (define level (cdr current))
        (when (equal? current-word end-word)
          (return level))
        (for-each
         (lambda (neighbor)
           (when (is-in-set? neighbor)
             (unless (set-member? visited neighbor)
               (set-add! visited neighbor)
               (queue-enqueue! queue (cons neighbor (+ level 1))))))
         (neighbors current-word))
        (loop))))
  (if (not (is-in-set? end-word)) 0 (bfs)))

(define (main)
  (define input (current-command-line-arguments))
  (define begin-word (vector-ref input 0))
  (define end-word (vector-ref input 1))
  (define word-list (vector->list (vector-tail input 2)))
  (display (ladder-length begin-word end-word word-list)))

(main)