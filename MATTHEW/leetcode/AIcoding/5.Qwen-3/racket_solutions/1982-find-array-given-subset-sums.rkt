#lang racket

(define (find-array given-sums)
  (define (count-freq lst)
    (define freq (make-hash))
    (for-each (lambda (x) (hash-set! freq x (+ (hash-ref freq x 0) 1))) lst)
    freq)

  (define (remove-one lst x)
    (define (helper lst x cnt)
      (cond ((null? lst) '())
            ((= (car lst) x) (if (= cnt 1) (cdr lst) (cons x (helper (cdr lst) x (- cnt 1)))))
            (else (cons (car lst) (helper (cdr lst) x cnt)))))
    (helper lst x 1))

  (define (solve s)
    (when (null? s) '())
    (define n (length s))
    (define s-sorted (sort s <))
    (define total (apply + s-sorted))
    (define freq (count-freq s-sorted))
    (define res '())
    (define (dfs remaining target path)
      (when (null? remaining) (set! res path) (void))
      (when (and (not (null? res)) (<= (length path) (length s-sorted))) (void))
      (when (not (null? res)) (void))
      (let loop ((i 0))
        (when (< i (length remaining))
          (define val (list-ref remaining i))
          (define new-remaining (remove-one remaining val))
          (define new-target (- target val))
          (when (and (>= new-target 0) (hash-has-key? freq new-target))
            (dfs new-remaining new-target (append path (list val))))
          (loop (+ i 1)))))
    (dfs s-sorted total '())
    res)

  (solve given-sums))