#lang racket

(define (collect-coins . args)
  (let ((n (car args))
        (edges (cadr args))
        (coins (caddr args)))
    (define graph (make-hash))
    (for-each
     (lambda (e)
       (let ((u (car e)) (v (cadr e)))
         (hash-set! graph u (cons v (hash-ref graph u '())))
         (hash-set! graph v (cons u (hash-ref graph v '())))))
     edges)
    (define (bfs start)
      (let ((visited (make-hash))
            (queue (list start))
            (distances (make-hash)))
        (hash-set! visited start #t)
        (hash-set! distances start 0)
        (let loop ()
          (when (not (null? queue))
            (let ((node (car queue)))
              (for-each
               (lambda (neighbor)
                 (when (not (hash-has-key? visited neighbor))
                   (hash-set! visited neighbor #t)
                   (hash-set! distances neighbor (+ (hash-ref distances node) 1))
                   (set! queue (append queue (list neighbor)))))
               (hash-ref graph node))
              (loop))))
        distances))
    (define (get-leaves)
      (filter
       (lambda (u)
         (= (length (hash-ref graph u)) 1))
       (hash-keys graph)))
    (define (prune-leaves leaves)
      (let ((new-leaves '()))
        (for-each
         (lambda (u)
           (let ((neighbors (hash-ref graph u)))
             (if (= (length neighbors) 1)
                 (begin
                   (let ((v (car neighbors)))
                     (hash-remove! graph u)
                     (hash-set! graph v (remove u (hash-ref graph v)))
                     (set! new-leaves (cons v new-leaves))))
                 (set! new-leaves (cons u new-leaves)))))
         leaves)
        new-leaves))
    (define (count-deep-leaf)
      (let ((distances (bfs (car (get-leaves)))))
        (apply max (hash-values distances))))
    (define (count-deep-path)
      (let ((leaves (get-leaves)))
        (let loop ((leaves leaves) (depth 0))
          (if (null? leaves)
              depth
              (let ((new-leaves (prune-leaves leaves)))
                (loop new-leaves (+ depth 1)))))))
    (let ((deep-leaf (count-deep-leaf)))
      (if (<= deep-leaf 0)
          0
          (- (* 2 (max 0 (- deep-leaf 1))) 1))))))