#lang racket

(define (distance-nodes n edges)
  (define graph (make-hash))
  (for-each
   (lambda (e)
     (let ([u (car e)] [v (cadr e)])
       (hash-update! graph u (lambda (lst) (cons v lst)) '())
       (hash-update! graph v (lambda (lst) (cons u lst)) '())))
   edges)
  (define result (make-hash))
  (define (bfs start)
    (define visited (make-hash))
    (define queue (list (cons start 0)))
    (hash-set! visited start #t)
    (let loop ()
      (when (not (null? queue))
        (let* ([node (caar queue)] [dist (cdar queue)])
          (hash-set! result dist (add1 (hash-ref result dist 0)))
          (for-each
           (lambda (neighbor)
             (when (not (hash-has-key? visited neighbor))
               (hash-set! visited neighbor #t)
               (set! queue (append queue (list (cons neighbor (add1 dist)))))))
           (hash-ref graph node))
          (loop))))
  (for ([i (in-range n)])
    (bfs i))
  (hash-ref result 1 0))