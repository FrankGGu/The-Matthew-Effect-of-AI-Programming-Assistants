#lang racket

(define (sum-of-distances-in-tree n edges)
  (define tree (make-hash))
  (define res (make-vector n 0))
  (define count (make-vector n 1))
  (define (dfs u p)
    (for ([v (hash-ref tree u)])
      (when (not (= v p))
        (dfs v u)
        (vector-set! res u (+ (vector-ref res u) (vector-ref res v) (vector-ref count v)))
        (vector-set! count u (+ (vector-ref count u) (vector-ref count v)))))
    #t)
  (define (dfs2 u p)
    (for ([v (hash-ref tree u)])
      (when (not (= v p))
        (vector-set! res v (+ (vector-ref res u) (- n (vector-ref count v))))
        (vector-set! res v (- (vector-ref res v) (vector-ref count v)))
        (dfs2 v u)))
    #t)
  (for ([u (in-range n)])
    (hash-set! tree u '()))
  (for ([e edges])
    (let ([u (car e)] [v (cadr e)])
      (hash-update! tree u (Î» (lst) (cons v lst)))
      (hash-update! tree v (Î» (lst) (cons u lst)))))
  (dfs 0 -1)
  (dfs2 0 -1)
  (vector->list res))