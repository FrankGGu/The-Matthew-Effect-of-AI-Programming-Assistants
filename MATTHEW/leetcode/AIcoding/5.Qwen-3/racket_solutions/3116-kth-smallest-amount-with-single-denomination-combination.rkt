#lang racket

(define (kth-smallest coins k)
  (define (bfs)
    (define pq (make-priority-queue #:priority <))
    (define visited (set))
    (priority-queue-push! pq (cons 0 '()))
    (let loop ()
      (when (and (not (priority-queue-empty? pq)) (> k 0))
        (define current (priority-queue-pop! pq))
        (define sum (car current))
        (define path (cdr current))
        (when (not (set-member? visited sum))
          (set! visited (set-add visited sum))
          (when (= k 1)
            (apply + path))
          (set! k (- k 1))
          (for-each (lambda (coin)
                      (define new-sum (+ sum coin))
                      (unless (set-member? visited new-sum)
                        (priority-queue-push! pq (cons new-sum (append path (list coin))))))
                    coins)
          (loop)))))
  (bfs))