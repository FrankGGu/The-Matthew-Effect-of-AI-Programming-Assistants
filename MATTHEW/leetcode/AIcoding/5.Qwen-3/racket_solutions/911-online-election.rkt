#lang racket

(define (qsort lst)
  (if (null? lst)
      '()
      (let* ([pivot (car lst)]
             [rest (cdr lst)]
             [less (filter (lambda (x) (< x pivot)) rest)]
             [greater (filter (lambda (x) (>= x pivot)) rest)])
        (append (qsort less) (list pivot) (qsort greater)))))

(define (ranked-candidates candidates)
  (define counts (make-hash))
  (for-each (lambda (c) (hash-set! counts c (+ 1 (hash-ref counts c 0)))) candidates)
  (define sorted (qsort (hash-keys counts)))
  (define total (length candidates))
  (define (get-majority idx)
    (let loop ([i 0] [current 0] [candidate #f])
      (if (>= i (length sorted))
          candidate
          (let ([count (hash-ref counts (list-ref sorted i))])
            (if (> (+ current count) (/ total 2))
                (list-ref sorted i)
                (loop (+ i 1) (+ current count) candidate))))))
  (define majority (get-majority 0))
  (define (get-winner idx)
    (if (equal? (list-ref sorted idx) majority)
        (list-ref sorted idx)
        (get-winner (+ idx 1))))
  (define winner (get-winner 0))
  (define (get-rank candidate)
    (let loop ([i 0] [current 0])
      (if (equal? candidate (list-ref sorted i))
          i
          (loop (+ i 1) (+ current (hash-ref counts (list-ref sorted i)))))))
  (define (query t)
    (let ([votes (filter (lambda (x) (<= x t)) candidates)])
      (define counts (make-hash))
      (for-each (lambda (c) (hash-set! counts c (+ 1 (hash-ref counts c 0)))) votes)
      (define sorted-votes (qsort (hash-keys counts)))
      (define total-votes (length votes))
      (define (get-majority-vote idx)
        (let loop ([i 0] [current 0] [candidate #f])
          (if (>= i (length sorted-votes))
              candidate
              (let ([count (hash-ref counts (list-ref sorted-votes i))])
                (if (> (+ current count) (/ total-votes 2))
                    (list-ref sorted-votes i)
                    (loop (+ i 1) (+ current count) candidate))))))
      (define majority-vote (get-majority-vote 0))
      (define (get-winner-vote idx)
        (if (equal? (list-ref sorted-votes idx) majority-vote)
            (list-ref sorted-votes idx)
            (get-winner-vote (+ idx 1))))
      (define winner-vote (get-winner-vote 0))
      (get-rank winner-vote)))
  (lambda (t) (query t)))

(define (new-election candidates)
  (define (query t)
    (let ([votes (filter (lambda (x) (<= x t)) candidates)])
      (define counts (make-hash))
      (for-each (lambda (c) (hash-set! counts c (+ 1 (hash-ref counts c 0)))) votes)
      (define sorted (qsort (hash-keys counts)))
      (define total (length votes))
      (define (get-majority idx)
        (let loop ([i 0] [current 0] [candidate #f])
          (if (>= i (length sorted))
              candidate
              (let ([count (hash-ref counts (list-ref sorted i))])
                (if (> (+ current count) (/ total 2))
                    (list-ref sorted i)
                    (loop (+ i 1) (+ current count) candidate))))))
      (define majority (get-majority 0))
      (define (get-winner idx)
        (if (equal? (list-ref sorted idx) majority)
            (list-ref sorted idx)
            (get-winner (+ idx 1))))
      (get-winner 0)))
  (lambda (t) (query t)))

(define (main)
  (define candidates (list 1 1 2 2 3))
  (define election (new-election candidates))
  (displayln (election 3))
  (displayln (election 1))
  (displayln (election 2))
  (displayln (election 4)))

(main)