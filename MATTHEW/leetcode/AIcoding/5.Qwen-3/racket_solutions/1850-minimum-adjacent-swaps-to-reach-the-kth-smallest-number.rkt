#lang racket

(define (get-kth-permutation s k)
  (define n (string-length s))
  (define lst (string->list s))
  (define (factorial x)
    (if (= x 0) 1 (* x (factorial (- x 1)))))
  (define fact (map factorial (range 0 (+ n 1))))
  (define (swap! lst i j)
    (define tmp (list-ref lst i))
    (list-set! lst i (list-ref lst j))
    (list-set! lst j tmp))
  (define (next-perm lst)
    (define len (length lst))
    (define i (- len 2))
    (when (and (>= i 0) (<= (list-ref lst i) (list-ref lst (+ i 1))))
      (set! i (- i 1)))
    (when (< i 0) #f)
    (define j (- len 1))
    (while (<= (list-ref lst j) (list-ref lst i)) (set! j (- j 1)))
    (swap! lst i j)
    (define k (+ i 1))
    (define l (- len 1))
    (while (< k l)
      (swap! lst k l)
      (set! k (+ k 1))
      (set! l (- l 1)))
    #t)
  (define (permutations lst)
    (let loop ((count 0) (lst lst))
      (if (= count k) lst
          (begin
            (next-perm lst)
            (loop (+ count 1) lst)))))
  (list->string (permutations lst)))

(define (min-adjacent-swaps s k)
  (define lst (string->list s))
  (define (find-index lst val)
    (for/first ([i (in-range (length lst))] #:when (= (list-ref lst i) val)) i))
  (define (count-swaps lst)
    (define res 0)
    (define (swap i j)
      (set! res (+ res (- j i)))
      (define tmp (list-ref lst i))
      (list-set! lst i (list-ref lst j))
      (list-set! lst j tmp))
    (for ([i (in-range (length lst))])
      (define idx (find-index (drop lst i) (list-ref lst i)))
      (when (not (= idx 0))
        (swap i (+ i idx))))
    res)
  (define kth (get-kth-permutation s k))
  (count-swaps (string->list kth)))