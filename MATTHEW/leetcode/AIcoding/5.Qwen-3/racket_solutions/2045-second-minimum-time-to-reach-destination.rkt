#lang racket

(define (second-minimum n edges time)
  (define graph (make-hash))
  (for-each (lambda (edge)
              (let ([u (car edge)]
                    [v (cadr edge)])
                (hash-update! graph u (λ (lst) (cons v lst)) '())
                (hash-update! graph v (λ (lst) (cons u lst)) '())))
            edges)
  (define (bfs start)
    (define dist (make-hash))
    (define q (queue))
    (queue-add! q start)
    (hash-set! dist start 0)
    (while (not (queue-empty? q))
      (let ([u (queue-remove! q)])
        (for-each (lambda (v)
                    (when (not (hash-has-key? dist v))
                      (hash-set! dist v (+ (hash-ref dist u) time))
                      (queue-add! q v)))
                  (hash-ref graph u))))
    dist)
  (define dist1 (bfs 0))
  (define dist2 (bfs 1))
  (let ([min-time (apply min (map (lambda (i) (+ (hash-ref dist1 i) (hash-ref dist2 i))) (range n)))])
    (if (and (hash-has-key? dist1 (sub1 n)) (hash-has-key? dist2 (sub1 n)))
        min-time
        -1)))