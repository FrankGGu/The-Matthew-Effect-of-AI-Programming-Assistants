(define (cherry-pickup grid)
  (define n (length grid))
  (define memo (make-hash))
  (define (dfs r1 c1 r2 c2)
    (let ((key (list r1 c1 r2 c2)))
      (if (hash-has-key? memo key)
          (hash-ref memo key)
          (begin
            (when (or (>= r1 n) (>= c1 n) (>= r2 n) (>= c2 n) (< r1 0) (< c1 0) (< r2 0) (< c2 0))
              (set! (hash-ref memo key) -inf.0)
              (hash-set! memo key -inf.0)
              -inf.0)
            (let ((curr (if (= r1 r2) (list-ref (list-ref grid r1) c1) (+ (list-ref (list-ref grid r1) c1) (list-ref (list-ref grid r2) c2)))))
              (if (or (= r1 (- n 1)) (= r2 (- n 1)))
                  (begin
                    (set! (hash-ref memo key) curr)
                    (hash-set! memo key curr)
                    curr)
                  (let* ((nexts (list (list (+ r1 1) c1) (list r1 (+ c1 1)) (list (+ r1 1) (+ c1 1))))
                         (max-cherry -inf.0))
                    (for-each
                     (lambda (next1)
                       (let ((r1a (car next1)) (c1a (cadr next1)))
                         (for-each
                          (lambda (next2)
                            (let ((r2a (car next2)) (c2a (cadr next2)))
                              (set! max-cherry (max max-cherry (+ curr (dfs r1a c1a r2a c2a))))))
                          (list (list (+ r2 1) c2) (list r2 (+ c2 1)) (list (+ r2 1) (+ c2 1))))))
                     nexts)
                    (set! (hash-ref memo key) max-cherry)
                    (hash-set! memo key max-cherry)
                    max-cherry)))))))
  (max (dfs 0 0 0 0) 0))