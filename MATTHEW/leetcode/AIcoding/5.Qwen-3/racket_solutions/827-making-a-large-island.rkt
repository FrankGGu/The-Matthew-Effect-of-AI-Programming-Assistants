#lang racket

(define (largest-island grid)
  (define rows (length grid))
  (define cols (if (> rows 0) (length (car grid)) 0))
  (define id 2)
  (define area (make-hash))

  (define (dfs r c current-id)
    (when (and (>= r 0) (< r rows) (>= c 0) (< c cols) (= (list-ref (list-ref grid r) c) 1))
      (set! (list-ref (list-ref grid r) c) current-id)
      (hash-update! area current-id (lambda (x) (+ x 1)) 1)
      (dfs (add1 r) c current-id)
      (dfs (sub1 r) c current-id)
      (dfs r (add1 c) current-id)
      (dfs r (sub1 c) current-id)))

  (for ([r (in-range rows)])
    (for ([c (in-range cols)])
      (when (= (list-ref (list-ref grid r) c) 1)
        (dfs r c id)
        (set! id (add1 id)))))

  (define max-area 0)
  (define directions '((1 0) (-1 0) (0 1) (0 -1)))

  (for ([r (in-range rows)])
    (for ([c (in-range cols)])
      (when (= (list-ref (list-ref grid r) c) 0)
        (define seen (set))
        (define total 0)
        (for ([d directions])
          (define nr (+ r (first d)))
          (define nc (+ c (second d)))
          (when (and (>= nr 0) (< nr rows) (>= nc 0) (< nc cols))
            (define neighbor-id (list-ref (list-ref grid nr) nc))
            (when (and (>= neighbor-id 2) (not (set-member? seen neighbor-id)))
              (set-add! seen neighbor-id)
              (set! total (+ total (hash-ref area neighbor-id 0))))))
        (set! max-area (max max-area total))))

  (if (= rows 0) 0 (max max-area (hash-ref area 2 0)))

  (define (to-lists lst)
    (map (lambda (x) (if (pair? x) (to-lists x) x)) lst))

  (define (to-vector lst)
    (list->vector (map to-vector lst)))

  (define (convert-grid grid)
    (to-vector (map (lambda (row) (map (lambda (x) x) row)) grid)))

  (define converted (convert-grid grid))
  (largest-island-helper converted))

(define (largest-island-helper grid)
  (define rows (vector-length grid))
  (define cols (if (> rows 0) (vector-length (vector-ref grid 0)) 0))
  (define id 2)
  (define area (make-hash))

  (define (dfs r c current-id)
    (when (and (>= r 0) (< r rows) (>= c 0) (< c cols) (= (vector-ref (vector-ref grid r) c) 1))
      (vector-set! (vector-ref grid r) c current-id)
      (hash-update! area current-id (lambda (x) (+ x 1)) 1)
      (dfs (add1 r) c current-id)
      (dfs (sub1 r) c current-id)
      (dfs r (add1 c) current-id)
      (dfs r (sub1 c) current-id)))

  (for ([r (in-range rows)])
    (for ([c (in-range cols)])
      (when (= (vector-ref (vector-ref grid r) c) 1)
        (dfs r c id)
        (set! id (add1 id)))))

  (define max-area 0)
  (define directions '((1 0) (-1 0) (0 1) (0 -1)))

  (for ([r (in-range rows)])
    (for ([c (in-range cols)])
      (when (= (vector-ref (vector-ref grid r) c) 0)
        (define seen (set))
        (define total 0)
        (for ([d directions])
          (define nr (+ r (first d)))
          (define nc (+ c (second d)))
          (when (and (>= nr 0) (< nr rows) (>= nc 0) (< nc cols))
            (define neighbor-id (vector-ref (vector-ref grid nr) nc))
            (when (and (>= neighbor-id 2) (not (set-member? seen neighbor-id)))
              (set-add! seen neighbor-id)
              (set! total (+ total (hash-ref area neighbor-id 0))))))
        (set! max-area (max max-area total))))

  (if (= rows 0) 0 (max max-area (hash-ref area 2 0))))