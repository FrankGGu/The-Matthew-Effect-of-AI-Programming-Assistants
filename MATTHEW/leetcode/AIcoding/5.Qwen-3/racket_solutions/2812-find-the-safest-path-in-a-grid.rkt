#lang racket

(define (safe-path grid)
  (define rows (length grid))
  (define cols (length (car grid)))
  (define-values (max-distances)
    (let ([distances (make-vector rows (make-vector cols 0))])
      (for ([i (in-range rows)])
        (for ([j (in-range cols)])
          (when (= (vector-ref (vector-ref grid i) j) 0)
            (vector-set! (vector-ref distances i) j 0)))
      (for ([i (in-range rows)])
        (for ([j (in-range cols)])
          (when (not (= (vector-ref (vector-ref grid i) j) 0))
            (vector-set! (vector-ref distances i) j 
                         (apply min (filter (lambda (x) (not (eq? x #f)))
                                            (list (if (> i 0) (vector-ref (vector-ref distances (- i 1) j)) #f)
                                                  (if (< i (- rows 1)) (vector-ref (vector-ref distances (+ i 1) j)) #f)
                                                  (if (> j 0) (vector-ref (vector-ref distances i (- j 1)) #f) #f)
                                                  (if (< j (- cols 1)) (vector-ref (vector-ref distances i (+ j 1)) #f) #f)))))))
      distances))
  (define (bfs start)
    (define visited (make-vector rows (make-vector cols #f)))
    (define q (queue (cons start 0)))
    (vector-set! (vector-ref visited (car start)) (cdr start) #t)
    (let loop ()
      (when (not (queue-empty? q))
        (define current (queue-dequeue q))
        (define pos (car current))
        (define dist (cdr current))
        (when (and (= (car pos) (- rows 1)) (= (cdr pos) (- cols 1)))
          (values dist))
        (for-each
         (lambda (dir)
           (define new-pos (cons (+ (car pos) (car dir)) (+ (cdr pos) (cdr dir))))
           (define new-i (car new-pos))
           (define new-j (cdr new-pos))
           (when (and (>= new-i 0) (< new-i rows) (>= new-j 0) (< new-j cols) (not (vector-ref (vector-ref visited new-i) new-j)))
             (vector-set! (vector-ref visited new-i) new-j #t)
             (queue-enqueue! q (cons new-pos (min dist (vector-ref (vector-ref max-distances new-i) new-j)))))
         '((0 1) (1 0) (0 -1) (-1 0))))
        (loop))))
  (define start (cons 0 0))
  (define end (cons (- rows 1) (- cols 1)))
  (if (or (= (vector-ref (vector-ref grid 0) 0) 0) (= (vector-ref (vector-ref grid (- rows 1)) (- cols 1)) 0))
      0
      (let ([dist (bfs start)])
        dist)))

(define (main)
  (define input (read))
  (displayln (safe-path input)))

(main)