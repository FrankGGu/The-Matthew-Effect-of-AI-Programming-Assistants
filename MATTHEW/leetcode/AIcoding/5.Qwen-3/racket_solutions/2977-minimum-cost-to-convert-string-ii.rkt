(define (min-cost-to-convert-string start-target cost s t)
  (define n (string-length s))
  (define m (string-length t))
  (when (/= n m) (error "Strings must be of equal length"))
  (define adj (make-hash))
  (for ([i (in-range 26)])
    (hash-set! adj i (list)))
  (for ([i (in-range 26)])
    (for ([j (in-range 26)])
      (when (not (= i j))
        (hash-set! adj i (cons j (hash-ref adj i))))))
  (define (char->index c) (- (char->integer c) (char->integer #\a)))
  (define start (char->index (string-ref s 0)))
  (define target (char->index (string-ref t 0)))
  (define dist (make-vector 26 1/0))
  (vector-set! dist start 0)
  (define (relax u v w)
    (when (< (+ (vector-ref dist u) w) (vector-ref dist v))
      (vector-set! dist v (+ (vector-ref dist u) w))))
  (for ([i (in-range n)])
    (define u (char->index (string-ref s i)))
    (define v (char->index (string-ref t i)))
    (unless (= u v)
      (relax u v (vector-ref cost u))
      (relax v u (vector-ref cost v))))
  (for ([i (in-range 26)])
    (for ([j (hash-ref adj i)])
      (relax i j (vector-ref cost i))))
  (vector-ref dist target))