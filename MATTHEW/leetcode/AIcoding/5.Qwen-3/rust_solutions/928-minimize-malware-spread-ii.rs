impl Solution {

use std::collections::{HashSet, VecDeque};

impl Solution {
    pub fn min_malware_spread(mut reachability: Vec<Vec<i32>>, malware: Vec<i32>) -> i32 {
        let n = reachability.len();
        let mut infected = HashSet::new();
        for &m in &malware {
            infected.insert(m as usize);
        }

        let mut max_safe = 0;
        let mut result = -1;

        for i in 0..n {
            if !infected.contains(&i) {
                let mut visited = vec![false; n];
                let mut queue = VecDeque::new();
                queue.push_back(i);
                visited[i] = true;
                let mut count = 0;

                while let Some(node) = queue.pop_front() {
                    count += 1;
                    for neighbor in 0..n {
                        if reachability[node][neighbor] == 1 && !visited[neighbor] {
                            visited[neighbor] = true;
                            queue.push_back(neighbor);
                        }
                    }
                }

                let mut safe = true;
                for &m in &malware {
                    if infected.contains(&(m as usize)) {
                        let mut visited_m = vec![false; n];
                        let mut queue_m = VecDeque::new();
                        queue_m.push_back(m as usize);
                        visited_m[m as usize] = true;
                        let mut infected_count = 0;

                        while let Some(node) = queue_m.pop_front() {
                            infected_count += 1;
                            for neighbor in 0..n {
                                if reachability[node][neighbor] == 1 && !visited_m[neighbor] {
                                    visited_m[neighbor] = true;
                                    queue_m.push_back(neighbor);
                                }
                            }
                        }

                        if infected_count > 1 {
                            safe = false;
                            break;
                        }
                    }
                }

                if safe && count > max_safe {
                    max_safe = count;
                    result = i as i32;
                }
            }
        }

        result
    }
}
}