impl Solution {

use std::collections::{HashSet, VecDeque};

impl Solution {
    pub fn min_malware_spread(rooms: Vec<Vec<i32>>, malware: Vec<i32>) -> i32 {
        let n = rooms.len();
        let mut visited = vec![false; n];
        let mut graph = vec![vec![]; n];

        for i in 0..n {
            for j in 0..n {
                if rooms[i][j] == 1 {
                    graph[i].push(j);
                }
            }
        }

        let mut mal_set: HashSet<i32> = malware.into_iter().collect();
        let mut max_clean = 0;
        let mut result = 0;

        for start in 0..n {
            if mal_set.contains(&(start as i32)) {
                continue;
            }

            let mut queue = VecDeque::new();
            queue.push_back(start);
            let mut clean = 0;
            let mut infected = false;

            let mut temp_visited = vec![false; n];
            temp_visited[start] = true;

            while let Some(node) = queue.pop_front() {
                clean += 1;

                for &neighbor in &graph[node] {
                    if !temp_visited[neighbor] {
                        if mal_set.contains(&(neighbor as i32)) {
                            infected = true;
                        } else {
                            temp_visited[neighbor] = true;
                            queue.push_back(neighbor);
                        }
                    }
                }
            }

            if !infected {
                if clean > max_clean {
                    max_clean = clean;
                    result = start as i32;
                }
            }
        }

        result
    }
}
}