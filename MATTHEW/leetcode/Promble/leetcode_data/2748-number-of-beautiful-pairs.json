{
  "id": "2748",
  "title": "Number of Beautiful Pairs",
  "titleSlug": "number-of-beautiful-pairs",
  "difficulty": "Easy",
  "category": "Algorithms",
  "topics": [
    "Array",
    "Hash Table",
    "Math",
    "Counting",
    "Number Theory"
  ],
  "content": "<p>You are given a <strong>0-indexed </strong>integer array <code>nums</code>. A pair of indices <code>i</code>, <code>j</code> where <code>0 &lt;=&nbsp;i &lt; j &lt; nums.length</code> is called beautiful if the <strong>first digit</strong> of <code>nums[i]</code> and the <strong>last digit</strong> of <code>nums[j]</code> are <strong>coprime</strong>.</p>\n\n<p>Return <em>the total number of beautiful pairs in </em><code>nums</code>.</p>\n\n<p>Two integers <code>x</code> and <code>y</code> are <strong>coprime</strong> if there is no integer greater than 1 that divides both of them. In other words, <code>x</code> and <code>y</code> are coprime if <code>gcd(x, y) == 1</code>, where <code>gcd(x, y)</code> is the <strong>greatest common divisor</strong> of <code>x</code> and <code>y</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,5,1,4]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> There are 5 beautiful pairs in nums:\nWhen i = 0 and j = 1: the first digit of nums[0] is 2, and the last digit of nums[1] is 5. We can confirm that 2 and 5 are coprime, since gcd(2,5) == 1.\nWhen i = 0 and j = 2: the first digit of nums[0] is 2, and the last digit of nums[2] is 1. Indeed, gcd(2,1) == 1.\nWhen i = 1 and j = 2: the first digit of nums[1] is 5, and the last digit of nums[2] is 1. Indeed, gcd(5,1) == 1.\nWhen i = 1 and j = 3: the first digit of nums[1] is 5, and the last digit of nums[3] is 4. Indeed, gcd(5,4) == 1.\nWhen i = 2 and j = 3: the first digit of nums[2] is 1, and the last digit of nums[3] is 4. Indeed, gcd(1,4) == 1.\nThus, we return 5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [11,21,12]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are 2 beautiful pairs:\nWhen i = 0 and j = 1: the first digit of nums[0] is 1, and the last digit of nums[1] is 1. Indeed, gcd(1,1) == 1.\nWhen i = 0 and j = 2: the first digit of nums[0] is 1, and the last digit of nums[2] is 2. Indeed, gcd(1,2) == 1.\nThus, we return 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 9999</code></li>\n\t<li><code>nums[i] % 10 != 0</code></li>\n</ul>\n",
  "codeSnippets": {
    "cpp": "class Solution {\npublic:\n    int countBeautifulPairs(vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int countBeautifulPairs(int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def countBeautifulPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def countBeautifulPairs(self, nums: List[int]) -> int:\n        ",
    "c": "int countBeautifulPairs(int* nums, int numsSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int CountBeautifulPairs(int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar countBeautifulPairs = function(nums) {\n    \n};",
    "typescript": "function countBeautifulPairs(nums: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function countBeautifulPairs($nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func countBeautifulPairs(_ nums: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun countBeautifulPairs(nums: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int countBeautifulPairs(List<int> nums) {\n    \n  }\n}",
    "golang": "func countBeautifulPairs(nums []int) int {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @return {Integer}\ndef count_beautiful_pairs(nums)\n    \nend",
    "scala": "object Solution {\n    def countBeautifulPairs(nums: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn count_beautiful_pairs(nums: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (count-beautiful-pairs nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec count_beautiful_pairs(Nums :: [integer()]) -> integer().\ncount_beautiful_pairs(Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec count_beautiful_pairs(nums :: [integer]) :: integer\n  def count_beautiful_pairs(nums) do\n    \n  end\nend",
    "cangjie": "class Solution {\n    func countBeautifulPairs(nums: Array<Int64>): Int64 {\n\n    }\n}"
  },
  "exampleTestcases": "[2,5,1,4]\n[11,21,12]",
  "hints": [
    "Since nums.length is small, you can find all pairs of indices and check if each pair is beautiful.",
    "Use integer to string conversion to get the first and last digit of each number."
  ]
}