{
  "id": "2449",
  "title": "Minimum Number of Operations to Make Arrays Similar",
  "titleSlug": "minimum-number-of-operations-to-make-arrays-similar",
  "difficulty": "Hard",
  "category": "Algorithms",
  "topics": [
    "Greedy",
    "Array",
    "Sorting"
  ],
  "content": "<p>You are given two positive integer arrays <code>nums</code> and <code>target</code>, of the same length.</p>\n\n<p>In one operation, you can choose any two <strong>distinct</strong> indices <code>i</code> and <code>j</code> where <code>0 &lt;= i, j &lt; nums.length</code> and:</p>\n\n<ul>\n\t<li>set <code>nums[i] = nums[i] + 2</code> and</li>\n\t<li>set <code>nums[j] = nums[j] - 2</code>.</li>\n</ul>\n\n<p>Two arrays are considered to be <strong>similar</strong> if the frequency of each element is the same.</p>\n\n<p>Return <em>the minimum number of operations required to make </em><code>nums</code><em> similar to </em><code>target</code>. The test cases are generated such that <code>nums</code> can always be similar to <code>target</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [8,12,6], target = [2,14,10]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> It is possible to make nums similar to target in two operations:\n- Choose i = 0 and j = 2, nums = [10,12,4].\n- Choose i = 1 and j = 2, nums = [10,14,2].\nIt can be shown that 2 is the minimum number of operations needed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,5], target = [4,1,3]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We can make nums similar to target in one operation:\n- Choose i = 1 and j = 2, nums = [1,4,3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1,1,1], target = [1,1,1,1,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The array nums is already similiar to target.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], target[i] &lt;= 10<sup>6</sup></code></li>\n\t<li>It is possible to make <code>nums</code> similar to <code>target</code>.</li>\n</ul>\n",
  "codeSnippets": {
    "cpp": "class Solution {\npublic:\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\n        \n    }\n};",
    "java": "class Solution {\n    public long makeSimilar(int[] nums, int[] target) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def makeSimilar(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        ",
    "c": "long long makeSimilar(int* nums, int numsSize, int* target, int targetSize) {\n    \n}",
    "csharp": "public class Solution {\n    public long MakeSimilar(int[] nums, int[] target) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number[]} target\n * @return {number}\n */\nvar makeSimilar = function(nums, target) {\n    \n};",
    "typescript": "function makeSimilar(nums: number[], target: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer[] $target\n     * @return Integer\n     */\n    function makeSimilar($nums, $target) {\n        \n    }\n}",
    "swift": "class Solution {\n    func makeSimilar(_ nums: [Int], _ target: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun makeSimilar(nums: IntArray, target: IntArray): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int makeSimilar(List<int> nums, List<int> target) {\n    \n  }\n}",
    "golang": "func makeSimilar(nums []int, target []int) int64 {\n    \n}",
    "ruby": "# @param {Integer[]} nums\n# @param {Integer[]} target\n# @return {Integer}\ndef make_similar(nums, target)\n    \nend",
    "scala": "object Solution {\n    def makeSimilar(nums: Array[Int], target: Array[Int]): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn make_similar(nums: Vec<i32>, target: Vec<i32>) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (make-similar nums target)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec make_similar(Nums :: [integer()], Target :: [integer()]) -> integer().\nmake_similar(Nums, Target) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec make_similar(nums :: [integer], target :: [integer]) :: integer\n  def make_similar(nums, target) do\n    \n  end\nend",
    "cangjie": "class Solution {\n    func makeSimilar(nums: Array<Int64>, target: Array<Int64>): Int64 {\n\n    }\n}"
  },
  "exampleTestcases": "[8,12,6]\n[2,14,10]\n[1,2,5]\n[4,1,3]\n[1,1,1,1,1]\n[1,1,1,1,1]",
  "hints": [
    "Solve for even and odd numbers separately.",
    "Greedily match smallest even element from nums to smallest even element from target, then similarly next smallest element and so on.",
    "Similarly, match odd elements too."
  ]
}