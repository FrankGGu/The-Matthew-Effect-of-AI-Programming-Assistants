{
  "id": "1557",
  "title": "Minimum Number of Vertices to Reach All Nodes",
  "titleSlug": "minimum-number-of-vertices-to-reach-all-nodes",
  "difficulty": "Medium",
  "category": "Algorithms",
  "topics": [
    "Graph"
  ],
  "content": "<p>Given a<strong>&nbsp;directed acyclic graph</strong>,&nbsp;with&nbsp;<code>n</code>&nbsp;vertices numbered from&nbsp;<code>0</code>&nbsp;to&nbsp;<code>n-1</code>,&nbsp;and an array&nbsp;<code>edges</code>&nbsp;where&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;represents a directed edge from node&nbsp;<code>from<sub>i</sub></code>&nbsp;to node&nbsp;<code>to<sub>i</sub></code>.</p>\n\n<p>Find <em>the smallest set of vertices from which all nodes in the graph are reachable</em>. It&#39;s guaranteed that a unique solution exists.</p>\n\n<p>Notice that you can return the vertices in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/07/untitled22.png\" style=\"width: 231px; height: 181px;\" /></p>\n\n<pre>\n<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]\n<strong>Output:</strong> [0,3]\n<b>Explanation: </b>It&#39;s not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3].</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/07/untitled.png\" style=\"width: 201px; height: 201px;\" /></p>\n\n<pre>\n<strong>Input:</strong> n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]\n<strong>Output:</strong> [0,2,3]\n<strong>Explanation: </strong>Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(10^5, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= from<sub>i,</sub>&nbsp;to<sub>i</sub> &lt; n</code></li>\n\t<li>All pairs <code>(from<sub>i</sub>, to<sub>i</sub>)</code> are distinct.</li>\n</ul>\n",
  "codeSnippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> findSmallestSetOfVertices(int n, vector<vector<int>>& edges) {\n        \n    }\n};",
    "java": "class Solution {\n    public List<Integer> findSmallestSetOfVertices(int n, List<List<Integer>> edges) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def findSmallestSetOfVertices(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findSmallestSetOfVertices(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public IList<int> FindSmallestSetOfVertices(int n, IList<IList<int>> edges) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[]}\n */\nvar findSmallestSetOfVertices = function(n, edges) {\n    \n};",
    "typescript": "function findSmallestSetOfVertices(n: number, edges: number[][]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @return Integer[]\n     */\n    function findSmallestSetOfVertices($n, $edges) {\n        \n    }\n}",
    "swift": "class Solution {\n    func findSmallestSetOfVertices(_ n: Int, _ edges: [[Int]]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun findSmallestSetOfVertices(n: Int, edges: List<List<Int>>): List<Int> {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> findSmallestSetOfVertices(int n, List<List<int>> edges) {\n    \n  }\n}",
    "golang": "func findSmallestSetOfVertices(n int, edges [][]int) []int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @return {Integer[]}\ndef find_smallest_set_of_vertices(n, edges)\n    \nend",
    "scala": "object Solution {\n    def findSmallestSetOfVertices(n: Int, edges: List[List[Int]]): List[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn find_smallest_set_of_vertices(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (find-smallest-set-of-vertices n edges)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))\n  )",
    "erlang": "-spec find_smallest_set_of_vertices(N :: integer(), Edges :: [[integer()]]) -> [integer()].\nfind_smallest_set_of_vertices(N, Edges) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec find_smallest_set_of_vertices(n :: integer, edges :: [[integer]]) :: [integer]\n  def find_smallest_set_of_vertices(n, edges) do\n    \n  end\nend",
    "cangjie": "class Solution {\n    func findSmallestSetOfVertices(n: Int64, edges: ArrayList<ArrayList<Int64>>): ArrayList<Int64> {\n\n    }\n}"
  },
  "exampleTestcases": "6\n[[0,1],[0,2],[2,5],[3,4],[4,2]]\n5\n[[0,1],[2,1],[3,1],[1,4],[2,4]]",
  "hints": [
    "A node that does not have any incoming edge can only be reached by itself.",
    "Any other node with incoming edges can be reached from some other node.",
    "We only have to count the number of nodes with zero incoming edges."
  ]
}