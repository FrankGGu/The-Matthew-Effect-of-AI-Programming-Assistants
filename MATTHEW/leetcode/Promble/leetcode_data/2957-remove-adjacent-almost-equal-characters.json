{
  "id": "2957",
  "title": "Remove Adjacent Almost-Equal Characters",
  "titleSlug": "remove-adjacent-almost-equal-characters",
  "difficulty": "Medium",
  "category": "Algorithms",
  "topics": [
    "Greedy",
    "String",
    "Dynamic Programming"
  ],
  "content": "<p>You are given a <strong>0-indexed</strong> string <code>word</code>.</p>\n\n<p>In one operation, you can pick any index <code>i</code> of <code>word</code> and change <code>word[i]</code> to any lowercase English letter.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of operations needed to remove all adjacent <strong>almost-equal</strong> characters from</em> <code>word</code>.</p>\n\n<p>Two characters <code>a</code> and <code>b</code> are <strong>almost-equal</strong> if <code>a == b</code> or <code>a</code> and <code>b</code> are adjacent in the alphabet.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> word = &quot;aaaaa&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can change word into &quot;a<strong><u>c</u></strong>a<u><strong>c</strong></u>a&quot; which does not have any adjacent almost-equal characters.\nIt can be shown that the minimum number of operations needed to remove all adjacent almost-equal characters from word is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> word = &quot;abddez&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can change word into &quot;<strong><u>y</u></strong>bd<u><strong>o</strong></u>ez&quot; which does not have any adjacent almost-equal characters.\nIt can be shown that the minimum number of operations needed to remove all adjacent almost-equal characters from word is 2.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> word = &quot;zyxyxyz&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can change word into &quot;z<u><strong>a</strong></u>x<u><strong>a</strong></u>x<strong><u>a</u></strong>z&quot; which does not have any adjacent almost-equal characters. \nIt can be shown that the minimum number of operations needed to remove all adjacent almost-equal characters from word is 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>word</code> consists only of lowercase English letters.</li>\n</ul>\n",
  "codeSnippets": {
    "cpp": "class Solution {\npublic:\n    int removeAlmostEqualCharacters(string word) {\n        \n    }\n};",
    "java": "class Solution {\n    public int removeAlmostEqualCharacters(String word) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def removeAlmostEqualCharacters(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def removeAlmostEqualCharacters(self, word: str) -> int:\n        ",
    "c": "int removeAlmostEqualCharacters(char* word) {\n    \n}",
    "csharp": "public class Solution {\n    public int RemoveAlmostEqualCharacters(string word) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} word\n * @return {number}\n */\nvar removeAlmostEqualCharacters = function(word) {\n    \n};",
    "typescript": "function removeAlmostEqualCharacters(word: string): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $word\n     * @return Integer\n     */\n    function removeAlmostEqualCharacters($word) {\n        \n    }\n}",
    "swift": "class Solution {\n    func removeAlmostEqualCharacters(_ word: String) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun removeAlmostEqualCharacters(word: String): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int removeAlmostEqualCharacters(String word) {\n    \n  }\n}",
    "golang": "func removeAlmostEqualCharacters(word string) int {\n    \n}",
    "ruby": "# @param {String} word\n# @return {Integer}\ndef remove_almost_equal_characters(word)\n    \nend",
    "scala": "object Solution {\n    def removeAlmostEqualCharacters(word: String): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn remove_almost_equal_characters(word: String) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (remove-almost-equal-characters word)\n  (-> string? exact-integer?)\n  )",
    "erlang": "-spec remove_almost_equal_characters(Word :: unicode:unicode_binary()) -> integer().\nremove_almost_equal_characters(Word) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec remove_almost_equal_characters(word :: String.t) :: integer\n  def remove_almost_equal_characters(word) do\n    \n  end\nend",
    "cangjie": "class Solution {\n    func removeAlmostEqualCharacters(word: String): Int64 {\n\n    }\n}"
  },
  "exampleTestcases": "\"aaaaa\"\n\"abddez\"\n\"zyxyxyz\"",
  "hints": [
    "For <code>i > 0</code>, if <code>word[i]</code> and <code>word[i - 1]</code> are adjacent, we will change <code>word[i]</code> to another character. Which character should we change it to?",
    "We will change <code>word[i]</code> to some character that is not adjacent to <code>word[i - 1]</code> nor <code>word[i + 1]</code> (if it exists). Such a character always exists. However, since the problem does not ask for the final state of the string, It is enough to prove that the character exists and we do not need to find it."
  ]
}