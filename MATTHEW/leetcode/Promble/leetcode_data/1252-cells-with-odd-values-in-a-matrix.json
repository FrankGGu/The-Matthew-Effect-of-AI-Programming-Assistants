{
  "id": "1252",
  "title": "Cells with Odd Values in a Matrix",
  "titleSlug": "cells-with-odd-values-in-a-matrix",
  "difficulty": "Easy",
  "category": "Algorithms",
  "topics": [
    "Array",
    "Math",
    "Simulation"
  ],
  "content": "<p>There is an <code>m x n</code> matrix that is initialized to all <code>0</code>&#39;s. There is also a 2D array <code>indices</code> where each <code>indices[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> represents a <strong>0-indexed location</strong> to perform some increment operations on the matrix.</p>\n\n<p>For each location <code>indices[i]</code>, do <strong>both</strong> of the following:</p>\n\n<ol>\n\t<li>Increment <strong>all</strong> the cells on row <code>r<sub>i</sub></code>.</li>\n\t<li>Increment <strong>all</strong> the cells on column <code>c<sub>i</sub></code>.</li>\n</ol>\n\n<p>Given <code>m</code>, <code>n</code>, and <code>indices</code>, return <em>the <strong>number of odd-valued cells</strong> in the matrix after applying the increment to all locations in </em><code>indices</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/30/e1.png\" style=\"width: 600px; height: 118px;\" />\n<pre>\n<strong>Input:</strong> m = 2, n = 3, indices = [[0,1],[1,1]]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Initial matrix = [[0,0,0],[0,0,0]].\nAfter applying first increment it becomes [[1,2,1],[0,1,0]].\nThe final matrix is [[1,3,1],[1,3,1]], which contains 6 odd numbers.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/30/e2.png\" style=\"width: 600px; height: 150px;\" />\n<pre>\n<strong>Input:</strong> m = 2, n = 2, indices = [[1,1],[0,0]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Final matrix = [[2,2],[2,2]]. There are no odd numbers in the final matrix.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= indices.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= r<sub>i</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= c<sub>i</sub> &lt; n</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve this in <code>O(n + m + indices.length)</code> time with only <code>O(n + m)</code> extra space?</p>\n",
  "codeSnippets": {
    "cpp": "class Solution {\npublic:\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\n        \n    }\n};",
    "java": "class Solution {\n    public int oddCells(int m, int n, int[][] indices) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def oddCells(self, m, n, indices):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type indices: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        ",
    "c": "int oddCells(int m, int n, int** indices, int indicesSize, int* indicesColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int OddCells(int m, int n, int[][] indices) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} m\n * @param {number} n\n * @param {number[][]} indices\n * @return {number}\n */\nvar oddCells = function(m, n, indices) {\n    \n};",
    "typescript": "function oddCells(m: number, n: number, indices: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $m\n     * @param Integer $n\n     * @param Integer[][] $indices\n     * @return Integer\n     */\n    function oddCells($m, $n, $indices) {\n        \n    }\n}",
    "swift": "class Solution {\n    func oddCells(_ m: Int, _ n: Int, _ indices: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun oddCells(m: Int, n: Int, indices: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int oddCells(int m, int n, List<List<int>> indices) {\n    \n  }\n}",
    "golang": "func oddCells(m int, n int, indices [][]int) int {\n    \n}",
    "ruby": "# @param {Integer} m\n# @param {Integer} n\n# @param {Integer[][]} indices\n# @return {Integer}\ndef odd_cells(m, n, indices)\n    \nend",
    "scala": "object Solution {\n    def oddCells(m: Int, n: Int, indices: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn odd_cells(m: i32, n: i32, indices: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (odd-cells m n indices)\n  (-> exact-integer? exact-integer? (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec odd_cells(M :: integer(), N :: integer(), Indices :: [[integer()]]) -> integer().\nodd_cells(M, N, Indices) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec odd_cells(m :: integer, n :: integer, indices :: [[integer]]) :: integer\n  def odd_cells(m, n, indices) do\n    \n  end\nend",
    "cangjie": "class Solution {\n    func oddCells(m: Int64, n: Int64, indices: Array<Array<Int64>>): Int64 {\n\n    }\n}"
  },
  "exampleTestcases": "2\n3\n[[0,1],[1,1]]\n2\n2\n[[1,1],[0,0]]",
  "hints": [
    "Simulation : With small constraints, it is possible to apply changes to each row and column and count odd cells after applying it.",
    "You can accumulate the number you should add to each row and column and then you can count the number of odd cells."
  ]
}