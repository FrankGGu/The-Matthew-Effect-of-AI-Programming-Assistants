{
  "id": "3425",
  "title": "Longest Special Path",
  "titleSlug": "longest-special-path",
  "difficulty": "Hard",
  "category": "Algorithms",
  "topics": [
    "Tree",
    "Depth-First Search",
    "Array",
    "Hash Table",
    "Prefix Sum"
  ],
  "content": "<p>You are given an undirected tree rooted at node <code>0</code> with <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>, represented by a 2D array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, length<sub>i</sub>]</code> indicates an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with length <code>length<sub>i</sub></code>. You are also given an integer array <code>nums</code>, where <code>nums[i]</code> represents the value at node <code>i</code>.</p>\n\n<p>A <b data-stringify-type=\"bold\">special path</b> is defined as a <b data-stringify-type=\"bold\">downward</b> path from an ancestor node to a descendant node such that all the values of the nodes in that path are <b data-stringify-type=\"bold\">unique</b>.</p>\n\n<p><strong>Note</strong> that a path may start and end at the same node.</p>\n\n<p>Return an array <code data-stringify-type=\"code\">result</code> of size 2, where <code>result[0]</code> is the <b data-stringify-type=\"bold\">length</b> of the <strong>longest</strong> special path, and <code>result[1]</code> is the <b data-stringify-type=\"bold\">minimum</b> number of nodes in all <i data-stringify-type=\"italic\">possible</i> <strong>longest</strong> special paths.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">edges = [[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], nums = [2,1,2,1,3,1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[6,2]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<h4>In the image below, nodes are colored by their corresponding values in <code>nums</code></h4>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/11/02/tree3.jpeg\" style=\"width: 250px; height: 350px;\" /></p>\n\n<p>The longest special paths are <code>2 -&gt; 5</code> and <code>0 -&gt; 1 -&gt; 4</code>, both having a length of 6. The minimum number of nodes across all longest special paths is 2.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">edges = [[1,0,8]], nums = [2,2]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[0,1]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/11/02/tree4.jpeg\" style=\"width: 190px; height: 75px;\" /></p>\n\n<p>The longest special paths are <code>0</code> and <code>1</code>, both having a length of 0. The minimum number of nodes across all longest special paths is 1.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 5 * 10<sup><span style=\"font-size: 10.8333px;\">4</span></sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>\n\t<li><code>1 &lt;= length<sub>i</sub> &lt;= 10<sup>3</sup></code></li>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>The input is generated such that <code>edges</code> represents a valid tree.</li>\n</ul>\n",
  "codeSnippets": {
    "cpp": "class Solution {\npublic:\n    vector<int> longestSpecialPath(vector<vector<int>>& edges, vector<int>& nums) {\n        \n    }\n};",
    "java": "class Solution {\n    public int[] longestSpecialPath(int[][] edges, int[] nums) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def longestSpecialPath(self, edges, nums):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def longestSpecialPath(self, edges: List[List[int]], nums: List[int]) -> List[int]:\n        ",
    "c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* longestSpecialPath(int** edges, int edgesSize, int* edgesColSize, int* nums, int numsSize, int* returnSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int[] LongestSpecialPath(int[][] edges, int[] nums) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[][]} edges\n * @param {number[]} nums\n * @return {number[]}\n */\nvar longestSpecialPath = function(edges, nums) {\n    \n};",
    "typescript": "function longestSpecialPath(edges: number[][], nums: number[]): number[] {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[][] $edges\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function longestSpecialPath($edges, $nums) {\n        \n    }\n}",
    "swift": "class Solution {\n    func longestSpecialPath(_ edges: [[Int]], _ nums: [Int]) -> [Int] {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun longestSpecialPath(edges: Array<IntArray>, nums: IntArray): IntArray {\n        \n    }\n}",
    "dart": "class Solution {\n  List<int> longestSpecialPath(List<List<int>> edges, List<int> nums) {\n    \n  }\n}",
    "golang": "func longestSpecialPath(edges [][]int, nums []int) []int {\n    \n}",
    "ruby": "# @param {Integer[][]} edges\n# @param {Integer[]} nums\n# @return {Integer[]}\ndef longest_special_path(edges, nums)\n    \nend",
    "scala": "object Solution {\n    def longestSpecialPath(edges: Array[Array[Int]], nums: Array[Int]): Array[Int] = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn longest_special_path(edges: Vec<Vec<i32>>, nums: Vec<i32>) -> Vec<i32> {\n        \n    }\n}",
    "racket": "(define/contract (longest-special-path edges nums)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?) (listof exact-integer?))\n  )",
    "erlang": "-spec longest_special_path(Edges :: [[integer()]], Nums :: [integer()]) -> [integer()].\nlongest_special_path(Edges, Nums) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec longest_special_path(edges :: [[integer]], nums :: [integer]) :: [integer]\n  def longest_special_path(edges, nums) do\n    \n  end\nend",
    "cangjie": "class Solution {\n    func longestSpecialPath(edges: Array<Array<Int64>>, nums: Array<Int64>): Array<Int64> {\n\n    }\n}"
  },
  "exampleTestcases": "[[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]]\n[2,1,2,1,3,1]\n[[1,0,8]]\n[2,2]",
  "hints": [
    "Use DFS to traverse the tree and maintain the current path length from the root (starting at 0) to the current node.",
    "Use prefix sums to calculate the longest path ending at the current node with all unique values."
  ]
}