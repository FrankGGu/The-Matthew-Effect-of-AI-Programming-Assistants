{
  "id": "2603",
  "title": "Collect Coins in a Tree",
  "titleSlug": "collect-coins-in-a-tree",
  "difficulty": "Hard",
  "category": "Algorithms",
  "topics": [
    "Tree",
    "Graph",
    "Topological Sort",
    "Array"
  ],
  "content": "<p>There exists an undirected and unrooted tree with <code>n</code> nodes indexed from <code>0</code> to <code>n - 1</code>. You are given an integer <code>n</code> and a 2D integer array edges of length <code>n - 1</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree. You are also given&nbsp;an array <code>coins</code> of size <code>n</code> where <code>coins[i]</code> can be either <code>0</code> or <code>1</code>, where <code>1</code> indicates the presence of a coin in the vertex <code>i</code>.</p>\n\n<p>Initially, you choose to start at any vertex in&nbsp;the tree.&nbsp;Then, you can perform&nbsp;the following operations any number of times:&nbsp;</p>\n\n<ul>\n\t<li>Collect all the coins that are at a distance of at most <code>2</code> from the current vertex, or</li>\n\t<li>Move to any adjacent vertex in the tree.</li>\n</ul>\n\n<p>Find <em>the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex</em>.</p>\n\n<p>Note that if you pass an edge several times, you need to count it into the answer several times.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/01/graph-2.png\" style=\"width: 522px; height: 522px;\" />\n<pre>\n<strong>Input:</strong> coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/02/graph-4.png\" style=\"width: 522px; height: 522px;\" />\n<pre>\n<strong>Input:</strong> coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == coins.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= coins[i] &lt;= 1</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code> represents a valid tree.</li>\n</ul>\n",
  "codeSnippets": {
    "cpp": "class Solution {\npublic:\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\n        \n    }\n};",
    "java": "class Solution {\n    public int collectTheCoins(int[] coins, int[][] edges) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def collectTheCoins(self, coins, edges):\n        \"\"\"\n        :type coins: List[int]\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n        ",
    "c": "int collectTheCoins(int* coins, int coinsSize, int** edges, int edgesSize, int* edgesColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int CollectTheCoins(int[] coins, int[][] edges) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} coins\n * @param {number[][]} edges\n * @return {number}\n */\nvar collectTheCoins = function(coins, edges) {\n    \n};",
    "typescript": "function collectTheCoins(coins: number[], edges: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $coins\n     * @param Integer[][] $edges\n     * @return Integer\n     */\n    function collectTheCoins($coins, $edges) {\n        \n    }\n}",
    "swift": "class Solution {\n    func collectTheCoins(_ coins: [Int], _ edges: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun collectTheCoins(coins: IntArray, edges: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int collectTheCoins(List<int> coins, List<List<int>> edges) {\n    \n  }\n}",
    "golang": "func collectTheCoins(coins []int, edges [][]int) int {\n    \n}",
    "ruby": "# @param {Integer[]} coins\n# @param {Integer[][]} edges\n# @return {Integer}\ndef collect_the_coins(coins, edges)\n    \nend",
    "scala": "object Solution {\n    def collectTheCoins(coins: Array[Int], edges: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn collect_the_coins(coins: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (collect-the-coins coins edges)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec collect_the_coins(Coins :: [integer()], Edges :: [[integer()]]) -> integer().\ncollect_the_coins(Coins, Edges) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec collect_the_coins(coins :: [integer], edges :: [[integer]]) :: integer\n  def collect_the_coins(coins, edges) do\n    \n  end\nend",
    "cangjie": "class Solution {\n    func collectTheCoins(coins: Array<Int64>, edges: Array<Array<Int64>>): Int64 {\n\n    }\n}"
  },
  "exampleTestcases": "[1,0,0,0,0,1]\n[[0,1],[1,2],[2,3],[3,4],[4,5]]\n[0,0,0,1,1,0,0,1]\n[[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]",
  "hints": [
    "All leaves that do not have a coin are redundant and can be deleted from the tree.",
    "Remove the leaves that do not have coins on them, so that the resulting tree will have a coin on every leaf.",
    "In the remaining tree, remove each leaf node and its parent from the tree. The remaining nodes in the tree are the ones that must be visited. Hence, the answer is equal to (# remaining nodes -1) * 2"
  ]
}