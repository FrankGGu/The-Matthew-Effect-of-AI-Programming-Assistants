{
  "id": "1326",
  "title": "Minimum Number of Taps to Open to Water a Garden",
  "titleSlug": "minimum-number-of-taps-to-open-to-water-a-garden",
  "difficulty": "Hard",
  "category": "Algorithms",
  "topics": [
    "Greedy",
    "Array",
    "Dynamic Programming"
  ],
  "content": "<p>There is a one-dimensional garden on the x-axis. The garden starts at the point <code>0</code> and ends at the point <code>n</code>. (i.e., the&nbsp;length of the garden is <code>n</code>).</p>\n\n<p>There are <code>n + 1</code> taps located at points <code>[0, 1, ..., n]</code> in the garden.</p>\n\n<p>Given an integer <code>n</code> and an integer array <code>ranges</code> of length <code>n + 1</code> where <code>ranges[i]</code> (0-indexed) means the <code>i-th</code> tap can water the area <code>[i - ranges[i], i + ranges[i]]</code> if it was open.</p>\n\n<p>Return <em>the minimum number of taps</em> that should be open to water the whole garden, If the garden cannot be watered return <strong>-1</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/16/1685_example_1.png\" style=\"width: 525px; height: 255px;\" />\n<pre>\n<strong>Input:</strong> n = 5, ranges = [3,4,1,1,0,0]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The tap at point 0 can cover the interval [-3,3]\nThe tap at point 1 can cover the interval [-3,5]\nThe tap at point 2 can cover the interval [1,3]\nThe tap at point 3 can cover the interval [2,4]\nThe tap at point 4 can cover the interval [4,4]\nThe tap at point 5 can cover the interval [5,5]\nOpening Only the second tap will water the whole garden [0,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, ranges = [0,0,0,0]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> Even if you activate all the four taps you cannot water the whole garden.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>ranges.length == n + 1</code></li>\n\t<li><code>0 &lt;= ranges[i] &lt;= 100</code></li>\n</ul>\n",
  "codeSnippets": {
    "cpp": "class Solution {\npublic:\n    int minTaps(int n, vector<int>& ranges) {\n        \n    }\n};",
    "java": "class Solution {\n    public int minTaps(int n, int[] ranges) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def minTaps(self, n, ranges):\n        \"\"\"\n        :type n: int\n        :type ranges: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        ",
    "c": "int minTaps(int n, int* ranges, int rangesSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int MinTaps(int n, int[] ranges) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} n\n * @param {number[]} ranges\n * @return {number}\n */\nvar minTaps = function(n, ranges) {\n    \n};",
    "typescript": "function minTaps(n: number, ranges: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[] $ranges\n     * @return Integer\n     */\n    function minTaps($n, $ranges) {\n        \n    }\n}",
    "swift": "class Solution {\n    func minTaps(_ n: Int, _ ranges: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun minTaps(n: Int, ranges: IntArray): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int minTaps(int n, List<int> ranges) {\n    \n  }\n}",
    "golang": "func minTaps(n int, ranges []int) int {\n    \n}",
    "ruby": "# @param {Integer} n\n# @param {Integer[]} ranges\n# @return {Integer}\ndef min_taps(n, ranges)\n    \nend",
    "scala": "object Solution {\n    def minTaps(n: Int, ranges: Array[Int]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn min_taps(n: i32, ranges: Vec<i32>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (min-taps n ranges)\n  (-> exact-integer? (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec min_taps(N :: integer(), Ranges :: [integer()]) -> integer().\nmin_taps(N, Ranges) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec min_taps(n :: integer, ranges :: [integer]) :: integer\n  def min_taps(n, ranges) do\n    \n  end\nend",
    "cangjie": "class Solution {\n    func minTaps(n: Int64, ranges: Array<Int64>): Int64 {\n\n    }\n}"
  },
  "exampleTestcases": "5\n[3,4,1,1,0,0]\n3\n[0,0,0,0]",
  "hints": [
    "Create intervals of the area covered by each tap, sort intervals by the left end.",
    "We need to cover the interval [0, n]. we can start with the first interval and out of all intervals that intersect with it we choose the one that covers the farthest point to the right.",
    "What if there is a gap between intervals that is not covered ? we should stop and return -1 as there is some interval that cannot be covered."
  ]
}