{
  "id": "3474",
  "title": "Lexicographically Smallest Generated String",
  "titleSlug": "lexicographically-smallest-generated-string",
  "difficulty": "Hard",
  "category": "Algorithms",
  "topics": [
    "Greedy",
    "String",
    "String Matching"
  ],
  "content": "<p>You are given two strings, <code>str1</code> and <code>str2</code>, of lengths <code>n</code> and <code>m</code>, respectively.</p>\n\n<p>A string <code>word</code> of length <code>n + m - 1</code> is defined to be <strong>generated</strong> by <code>str1</code> and <code>str2</code> if it satisfies the following conditions for <strong>each</strong> index <code>0 &lt;= i &lt;= n - 1</code>:</p>\n\n<ul>\n\t<li>If <code>str1[i] == &#39;T&#39;</code>, the <strong><span data-keyword=\"substring-nonempty\">substring</span></strong> of <code>word</code> with size <code>m</code> starting at index <code>i</code> is <strong>equal</strong> to <code>str2</code>, i.e., <code>word[i..(i + m - 1)] == str2</code>.</li>\n\t<li>If <code>str1[i] == &#39;F&#39;</code>, the <strong><span data-keyword=\"substring-nonempty\">substring</span></strong> of <code>word</code> with size <code>m</code> starting at index <code>i</code> is <strong>not equal</strong> to <code>str2</code>, i.e., <code>word[i..(i + m - 1)] != str2</code>.</li>\n</ul>\n\n<p>Return the <strong><span data-keyword=\"lexicographically-smaller-string\">lexicographically smallest</span></strong> possible string that can be <strong>generated</strong> by <code>str1</code> and <code>str2</code>. If no string can be generated, return an empty string <code>&quot;&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">str1 = &quot;TFTF&quot;, str2 = &quot;ab&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;ababa&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<h4>The table below represents the string <code>&quot;ababa&quot;</code></h4>\n\n<table>\n\t<tbody>\n\t\t<tr>\n\t\t\t<th style=\"border: 1px solid black;\">Index</th>\n\t\t\t<th style=\"border: 1px solid black;\">T/F</th>\n\t\t\t<th style=\"border: 1px solid black;\">Substring of length <code>m</code></th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 1px solid black;\">0</td>\n\t\t\t<td style=\"border: 1px solid black;\"><code>&#39;T&#39;</code></td>\n\t\t\t<td style=\"border: 1px solid black;\">&quot;ab&quot;</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 1px solid black;\">1</td>\n\t\t\t<td style=\"border: 1px solid black;\"><code>&#39;F&#39;</code></td>\n\t\t\t<td style=\"border: 1px solid black;\">&quot;ba&quot;</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 1px solid black;\">2</td>\n\t\t\t<td style=\"border: 1px solid black;\"><code>&#39;T&#39;</code></td>\n\t\t\t<td style=\"border: 1px solid black;\">&quot;ab&quot;</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 1px solid black;\">3</td>\n\t\t\t<td style=\"border: 1px solid black;\"><code>&#39;F&#39;</code></td>\n\t\t\t<td style=\"border: 1px solid black;\">&quot;ba&quot;</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>The strings <code>&quot;ababa&quot;</code> and <code>&quot;ababb&quot;</code> can be generated by <code>str1</code> and <code>str2</code>.</p>\n\n<p>Return <code>&quot;ababa&quot;</code> since it is the lexicographically smaller string.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">str1 = &quot;TFTF&quot;, str2 = &quot;abc&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>No string that satisfies the conditions can be generated.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">str1 = &quot;F&quot;, str2 = &quot;d&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;a&quot;</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == str1.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m == str2.length &lt;= 500</code></li>\n\t<li><code>str1</code> consists only of <code>&#39;T&#39;</code> or <code>&#39;F&#39;</code>.</li>\n\t<li><code>str2</code> consists only of lowercase English characters.</li>\n</ul>\n",
  "codeSnippets": {
    "cpp": "class Solution {\npublic:\n    string generateString(string str1, string str2) {\n        \n    }\n};",
    "java": "class Solution {\n    public String generateString(String str1, String str2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def generateString(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def generateString(self, str1: str, str2: str) -> str:\n        ",
    "c": "char* generateString(char* str1, char* str2) {\n    \n}",
    "csharp": "public class Solution {\n    public string GenerateString(string str1, string str2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} str1\n * @param {string} str2\n * @return {string}\n */\nvar generateString = function(str1, str2) {\n    \n};",
    "typescript": "function generateString(str1: string, str2: string): string {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $str1\n     * @param String $str2\n     * @return String\n     */\n    function generateString($str1, $str2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func generateString(_ str1: String, _ str2: String) -> String {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun generateString(str1: String, str2: String): String {\n        \n    }\n}",
    "dart": "class Solution {\n  String generateString(String str1, String str2) {\n    \n  }\n}",
    "golang": "func generateString(str1 string, str2 string) string {\n    \n}",
    "ruby": "# @param {String} str1\n# @param {String} str2\n# @return {String}\ndef generate_string(str1, str2)\n    \nend",
    "scala": "object Solution {\n    def generateString(str1: String, str2: String): String = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn generate_string(str1: String, str2: String) -> String {\n        \n    }\n}",
    "racket": "(define/contract (generate-string str1 str2)\n  (-> string? string? string?)\n  )",
    "erlang": "-spec generate_string(Str1 :: unicode:unicode_binary(), Str2 :: unicode:unicode_binary()) -> unicode:unicode_binary().\ngenerate_string(Str1, Str2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec generate_string(str1 :: String.t, str2 :: String.t) :: String.t\n  def generate_string(str1, str2) do\n    \n  end\nend",
    "cangjie": "class Solution {\n    func generateString(str1: String, str2: String): String {\n\n    }\n}"
  },
  "exampleTestcases": "\"TFTF\"\n\"ab\"\n\"TFTF\"\n\"abc\"\n\"F\"\n\"d\"",
  "hints": [
    "Use dynamic programming.",
    "Fill the fixed part.",
    "Use KMP's next table for DP.",
    "The state is the prefix length and the longest suffix length that matches the pattern.",
    "Each unknown character can be selected from <code>['a', 'b']</code>.",
    "Can you think of a greedy approach?"
  ]
}